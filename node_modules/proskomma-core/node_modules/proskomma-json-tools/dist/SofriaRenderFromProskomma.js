"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ProskommaRender = require('./ProskommaRender');
var camelCaseToSnakeCase = s => {
  var ret = [];
  for (var c of s.split("")) {
    if (c.toUpperCase() === c && c.toLowerCase() !== c) {
      ret.push("_".concat(c.toLowerCase()));
    } else {
      ret.push(c);
    }
  }
  return ret.join("");
};
class SofriaRenderFromProskomma extends ProskommaRender {
  constructor(spec) {
    super(spec);
    if (!spec.proskomma) {
      throw new Error("No Proskomma");
    }
    this.pk = spec.proskomma;
    this._tokens = [];
    this._container = null;
    this.cachedSequenceIds = [];
    this.sequences = null;
    this.currentCV = {
      chapter: null,
      verses: null
    };
  }
  renderDocument1(_ref) {
    var {
      docId,
      config,
      context,
      workspace,
      output
    } = _ref;
    var environment = {
      config,
      context,
      workspace,
      output
    };
    context.renderer = this;
    var documentResult = this.pk.gqlQuerySync("{\n          document(id: \"".concat(docId, "\") {\n            docSetId\n            mainSequence { id }\n            nSequences\n            sequences {\n              id\n              type\n              nBlocks\n            }\n            headers {\n              key\n              value\n            }\n          } \n        }"));
    var docSetId = documentResult.data.document.docSetId;
    var mainId = documentResult.data.document.mainSequence.id;
    var nSequences = documentResult.data.document.nSequences;
    this.sequences = {};
    for (var seq of documentResult.data.document.sequences) {
      this.sequences[seq.id] = seq;
    }
    var headers = {};
    for (var header of documentResult.data.document.headers) {
      headers[header.key] = header.value;
    }
    var docSetResult = this.pk.gqlQuerySync("{docSet(id: \"".concat(docSetId, "\") {selectors {key value}}}"));
    var selectors = {};
    for (var selector of docSetResult.data.docSet.selectors) {
      selectors[selector.key] = selector.value;
    }
    context.document = {
      id: docId,
      schema: {
        "structure": "nested",
        "structure_version": "0.2.1",
        "constraints": [{
          "name": "sofria",
          "version": "0.2.1"
        }]
      },
      metadata: {
        translation: {
          id: docSetId,
          selectors,
          properties: {},
          tags: []
        },
        document: _objectSpread(_objectSpread({}, headers), {}, {
          properties: {},
          tags: []
        })
      },
      mainSequenceId: mainId,
      nSequences
    };
    if (config.chapters) {
      context.document.metadata.document.properties.chapters = config.chapters[0];
    }
    context.sequences = [];
    this.renderEvent('startDocument', environment);
    this.cachedSequenceIds.unshift(mainId);
    this.renderSequence(environment, mainId);
    this.cachedSequenceIds.shift();
    this.renderEvent('endDocument', environment);
  }
  sequenceContext(sequence, sequenceId) {
    return {
      id: sequenceId,
      type: camelCaseToSnakeCase(sequence.type),
      nBlocks: sequence.nBlocks,
      milestones: new Set([])
    };
  }
  renderSequence(environment) {
    var context = environment.context;
    var sequenceId = this.cachedSequenceIds[0];
    var documentResult = this.pk.gqlQuerySync("{document(id: \"".concat(context.document.id, "\") {sequence(id:\"").concat(sequenceId, "\") {id type nBlocks blocks { os {payload} is {payload} } } } }"));
    var sequence = documentResult.data.document.sequence;
    if (!sequence) {
      throw new Error("Sequence '".concat(sequenceId, "' not found in renderSequenceId()"));
    }
    context.sequences.unshift(this.sequenceContext(sequence, sequenceId));
    this.renderEvent('startSequence', environment);
    var outputBlockN = 0;
    for (var inputBlockN = 0; inputBlockN < sequence.nBlocks; inputBlockN++) {
      if (environment.config.chapters && sequence.type === "main") {
        var chapterScopes = [...sequence.blocks[inputBlockN].os.map(s => s.payload), ...sequence.blocks[inputBlockN].is.map(s => s.payload)].filter(s => ['chapter'].includes(s.split('/')[0])).map(s => s.split('/')[1]);
        if (chapterScopes.length === 0 || !environment.config.chapters.includes(chapterScopes[0])) {
          continue;
        }
      }
      var blocksResult = this.pk.gqlQuerySync("{\n               document(id: \"".concat(context.document.id, "\") {\n                 sequence(id:\"").concat(sequenceId, "\") {\n                   blocks(positions:").concat(inputBlockN, ") {\n                     bg {subType payload}\n                     bs {payload}\n                     items {type subType payload}\n                   }\n                 }\n               }\n             }"));
      var blockResult = blocksResult.data.document.sequence.blocks[0];
      for (var blockGraft of blockResult.bg) {
        context.sequences[0].block = {
          type: "graft",
          subType: camelCaseToSnakeCase(blockGraft.subType),
          blockN: outputBlockN,
          sequence: this.sequences[blockGraft.payload]
        };
        this.cachedSequenceIds.unshift(blockGraft.payload);
        this.renderEvent('blockGraft', environment);
        this.cachedSequenceIds.shift();
        outputBlockN++;
      }
      var subTypeValues = blockResult.bs.payload.split('/');
      var subTypeValue = subTypeValues[1] ? "usfm:".concat(subTypeValues[1]) : subTypeValues[0];
      context.sequences[0].block = {
        type: "paragraph",
        subType: subTypeValue,
        blockN: outputBlockN,
        wrappers: []
      };
      this.renderEvent('startParagraph', environment);
      this._tokens = [];
      if (sequence.type === "main" && this.currentCV.chapter) {
        var wrapper = {
          type: "wrapper",
          subType: 'chapter',
          atts: {
            number: this.currentCV.chapter
          }
        };
        environment.context.sequences[0].element = wrapper;
        environment.context.sequences[0].block.wrappers.unshift(wrapper.subType);
        this.renderEvent('startWrapper', environment);
      }
      if (sequence.type === "main" && this.currentCV.verses) {
        var _wrapper = {
          type: "wrapper",
          subType: 'verses',
          atts: {
            number: this.currentCV.verses
          }
        };
        environment.context.sequences[0].element = _wrapper;
        environment.context.sequences[0].block.wrappers.unshift(_wrapper.subType);
        this.renderEvent('startWrapper', environment);
      }
      this.renderContent(blockResult.items, environment);
      this._tokens = [];
      if (sequence.type === "main" && this.currentCV.verses) {
        var _wrapper2 = {
          type: "wrapper",
          subType: 'verses',
          atts: {
            number: this.currentCV.verses
          }
        };
        environment.context.sequences[0].element = _wrapper2;
        environment.context.sequences[0].block.wrappers.shift();
        this.renderEvent('endWrapper', environment);
      }
      if (sequence.type === "main" && this.currentCV.chapter) {
        var _wrapper3 = {
          type: "wrapper",
          subType: 'chapter',
          atts: {
            number: this.currentCV.chapter
          }
        };
        environment.context.sequences[0].element = _wrapper3;
        environment.context.sequences[0].block.wrappers.shift();
        this.renderEvent('endWrapper', environment);
      }
      this.renderEvent('endParagraph', environment);
      delete context.sequences[0].block;
      outputBlockN++;
    }
    this.renderEvent('endSequence', environment);
    context.sequences.shift();
  }
  renderContent(items, environment) {
    for (var item of items) {
      this.renderItem(item, environment);
    }
    this.maybeRenderText(environment);
  }
  renderItem(item, environment) {
    if (item.type === 'scope' && item.payload.startsWith('attribute')) {
      var scopeBits = item.payload.split('/');
      if (item.subType === "start") {
        if (!this._container) {
          this._container = {
            direction: "start",
            subType: "usfm:w",
            type: "wrapper",
            atts: {}
          };
        }
        if (scopeBits[3] in this._container.atts) {
          this._container.atts[scopeBits[3]].push(scopeBits[5]);
        } else {
          this._container.atts[scopeBits[3]] = [scopeBits[5]];
        }
      } else {
        if (!this._container) {
          this._container = {
            direction: "end",
            subType: "usfm:".concat(camelCaseToSnakeCase(scopeBits[2]))
          };
          if (scopeBits[1] === 'milestone') {
            this._container.type = "end_milestone";
          } else {
            this._container.type = "wrapper";
            this._container.atts = {};
          }
        }
      }
    } else {
      if (this._container) {
        this.maybeRenderText(environment);
        this.renderContainer(environment);
      }
      if (item.type === 'token') {
        this._tokens.push(item.payload.replace(/\s+/g, " "));
      } else if (item.type === "graft") {
        this.maybeRenderText(environment);
        var graft = {
          type: "graft",
          subType: camelCaseToSnakeCase(item.subType),
          sequence: this.sequences[item.payload]
        };
        environment.context.sequences[0].element = graft;
        this.cachedSequenceIds.unshift(item.payload);
        this.renderEvent('inlineGraft', environment);
        this.cachedSequenceIds.shift();
        delete environment.context.sequences[0].element;
      } else {
        // scope
        this.maybeRenderText(environment);
        var _scopeBits = item.payload.split('/');
        if (["chapter", "verses"].includes(_scopeBits[0])) {
          var wrapper = {
            type: "wrapper",
            subType: camelCaseToSnakeCase(_scopeBits[0]),
            atts: {
              number: _scopeBits[1]
            }
          };
          environment.context.sequences[0].element = wrapper;
          if (item.subType === 'start') {
            this.currentCV[_scopeBits[0]] = _scopeBits[1];
            environment.context.sequences[0].block.wrappers.unshift(wrapper.subType);
            this.renderEvent('startWrapper', environment);
            var cvMark = {
              "type": "mark",
              "subType": "".concat(_scopeBits[0], "_label"),
              "atts": {
                "number": _scopeBits[1]
              }
            };
            environment.context.sequences[0].element = cvMark;
            this.renderEvent('mark', environment);
            environment.context.sequences[0].element = wrapper;
          } else {
            this.renderEvent('endWrapper', environment);
            environment.context.sequences[0].block.wrappers.shift();
            delete environment.context.sequences[0].element;
            this.currentCV[_scopeBits[0]] = null;
          }
        } else if (["pubChapter", "pubVerse", "altChapter", "altVerse"].includes(_scopeBits[0])) {
          if (item.subType === 'start') {
            var mark = {
              type: "mark",
              subType: camelCaseToSnakeCase(_scopeBits[0]),
              atts: {
                number: _scopeBits[1]
              }
            };
            environment.context.sequences[0].element = mark;
            this.renderEvent('mark', environment);
            delete environment.context.sequences[0].element;
          }
        } else if (_scopeBits[0] === 'span') {
          var _wrapper4 = {
            type: "wrapper",
            subType: "usfm:".concat(_scopeBits[1]),
            atts: {}
          };
          environment.context.sequences[0].element = _wrapper4;
          if (item.subType === 'start') {
            environment.context.sequences[0].block.wrappers.unshift(_wrapper4.subType);
            this.renderEvent('startWrapper', environment);
          } else {
            this.renderEvent('endWrapper', environment);
            environment.context.sequences[0].block.wrappers.shift();
          }
          delete environment.context.sequences[0].element;
        } else if (_scopeBits[0] === 'spanWithAtts') {
          if (item.subType === 'start') {
            this._container = {
              direction: "start",
              type: "wrapper",
              subType: "usfm:".concat(_scopeBits[1]),
              atts: {}
            };
          }
        } else if (_scopeBits[0] === 'milestone' && item.subType === "start") {
          if (_scopeBits[1] === 'ts') {
            var _mark = {
              type: "mark",
              subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
              atts: {}
            };
            environment.context.sequences[0].element = _mark;
            this.renderEvent('mark', environment);
            delete environment.context.sequences[0].element;
          } else {
            this._container = {
              type: "start_milestone",
              subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
              atts: {}
            };
          }
        }
      }
    }
  }
  maybeRenderText(environment) {
    if (this._tokens.length === 0) {
      return;
    }
    var elementContext = {
      type: 'text',
      text: this._tokens.join('')
    };
    environment.context.sequences[0].element = elementContext;
    this._tokens = [];
    this.renderEvent('text', environment);
    delete environment.context.sequences[0].element;
  }
  renderContainer(environment) {
    if (this._container.type === "wrapper") {
      var direction = this._container.direction;
      delete this._container.direction;
      if (direction === 'start') {
        environment.context.sequences[0].element = this._container;
        environment.context.sequences[0].block.wrappers.unshift(this._container.subType);
        this.renderEvent('startWrapper', environment);
        delete environment.context.sequences[0].element;
      } else {
        environment.context.sequences[0].element = this._container;
        this.renderEvent('endWrapper', environment);
        environment.context.sequences[0].block.wrappers.shift();
        delete environment.context.sequences[0].element;
      }
    } else if (this._container.type === "start_milestone") {
      environment.context.sequences[0].element = this._container;
      this.renderEvent('startMilestone', environment);
      delete environment.context.sequences[0].element;
    } else if (this._container.type === "end_milestone") {
      environment.context.sequences[0].element = this._container;
      this.renderEvent('endMilestone', environment);
      delete environment.context.sequences[0].element;
    }
    this._container = null;
  }
}
module.exports = SofriaRenderFromProskomma;