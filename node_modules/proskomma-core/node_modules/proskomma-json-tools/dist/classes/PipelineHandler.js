"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var namespaceTransforms = require('../render');
var officialPipelines = require('../pipelines');
class PipelineHandler {
  /**
   *
   * @param {Proskomma} proskomma - a proskomma instance
   * @param {JSON[]} pipelines - a list of the pipelines
   * @param {JSON[]} transforms - a list of the transforms
   * @param {boolean} verbose - print pipeline reading step by step
   */
  constructor(_ref) {
    var {
      pipelines = null,
      transforms = null,
      proskomma = null,
      verbose = false
    } = _ref;
    if (proskomma !== null) {
      this.proskomma = proskomma;
      var query = '{ id }';
      var content = proskomma.gqlQuerySync(query) || {};
      if (!content || !content.data.id) {
        throw new Error('Provided Proskomma instance does not have any ID');
      }
    }
    this.pipelines = officialPipelines;
    this.namespaces = namespaceTransforms;
    this.transforms = {};
    if (pipelines != null) {
      for (var key of Object.keys(pipelines)) {
        this.pipelines[key] = pipelines[key];
      }
    }
    if (transforms != null) {
      for (var _key of Object.keys(transforms)) {
        this.transforms[_key] = transforms[_key];
      }
    }
    this.verbose = verbose;
  }
  getProskomma() {
    return this.proskomma;
  }
  setProskomma(proskomma) {
    this.proskomma = proskomma;
  }
  listPipelinesNames() {
    return Object.keys(this.pipelines).join('\n');
  }
  listTransformsNames() {
    return Object.keys(this.transforms).join('\n');
  }
  listNamespacesNames() {
    return Object.keys(this.namespaces).join('\n');
  }

  /**
   * Gets pipeline by given name
   * @param {string} pipelineName - the pipeline name
   * @param {object} data input data
   * @return {pipeline} pipeline transforms
   * @private
   */
  getPipeline(pipelineName, data) {
    if (!this.pipelines[pipelineName]) {
      throw new Error("Unknown pipeline name '".concat(pipelineName, "'"));
    }
    var pipeline = this.pipelines[pipelineName];
    var inputSpecs = pipeline[0].inputs;
    if (Object.keys(inputSpecs).length !== Object.keys(data).length) {
      throw new Error("".concat(Object.keys(inputSpecs).length, " input(s) expected by ").concat(pipelineName, " but ").concat(Object.keys(data).length, " provided (").concat(Object.keys(data).join(', '), ")"));
    }
    for (var [inputSpecName, inputSpecType] of Object.entries(inputSpecs)) {
      if (!data[inputSpecName]) {
        throw new Error("Input ".concat(inputSpecName, " not provided as input to ").concat(pipelineName));
      }
      if (typeof data[inputSpecName] === 'string' !== (inputSpecType === 'text')) {
        throw new Error("Input ".concat(inputSpecName, " must be ").concat(inputSpecType, " but ").concat(typeof data[inputSpecName] === 'string' ? 'text' : 'json', " was provided"));
      }
    }
    return pipeline;
  }

  /**
   * Generates and returns a report via a transform pipeline
   * @async
   * @param {string} pipelineName
   * @param {object} data
   * @return {Promise<array>} A report
   */
  runPipeline(pipelineName, data) {
    var _this = this;
    return _asyncToGenerator(function* () {
      var pipeline = _this.getPipeline(pipelineName, data);
      _this.loadTransforms(pipeline, 'perf');
      return yield _this.evaluateSteps({
        specSteps: pipeline,
        inputValues: data
      });
    })();
  }
  loadTransforms(pipeline) {
    var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'perf';
    var transformSteps = pipeline.filter(s => s.type === 'Transform');
    if (transformSteps.length === 0) {
      throw new Error("No Transform steps found in report steps");
    }
    var names = Object.keys(transformSteps).map(val => transformSteps[val]['name']);
    if (namespace === 'sofria') {
      var entries = null;
      for (var [key, tr] of Object.entries(this.namespaces)) {
        if (key === 'sofriaToSofria') {
          if (tr.transforms) {
            entries = Object.entries(tr.transforms);
          } else {
            entries = Object.entries(tr);
          }
          for (var [k, t] of entries) {
            if (names.includes(k)) {
              this.transforms[k] = t;
            }
          }
        }
      }
    } else {
      var _entries = null;
      for (var [_key2, _tr] of Object.entries(this.namespaces)) {
        if (_key2 !== 'sofriaToSofria') {
          if (_tr.transforms) {
            _entries = Object.entries(_tr.transforms);
          } else {
            _entries = Object.entries(_tr);
          }
          for (var [_k, _t] of _entries) {
            if (names.includes(_k)) {
              this.transforms[_k] = _t;
            }
          }
        }
      }
    }
  }
  evaluateSteps(_ref2) {
    var {
      specSteps,
      inputValues
    } = _ref2;
    this.verbose && console.log('** Evaluate **');
    // Find input, output and transforms
    var inputStep = specSteps.filter(s => s.type === 'Inputs')[0];
    if (!inputStep) {
      throw new Error("No Inputs step found in report steps");
    }
    var outputStep = specSteps.filter(s => s.type === 'Outputs')[0];
    if (!outputStep) {
      throw new Error("No Outputs step found in report steps");
    }
    var transformSteps = specSteps.filter(s => s.type === 'Transform');
    if (transformSteps.length === 0) {
      throw new Error("No Transform steps found in report steps");
    }
    var transformInputs = {};
    var transformOutputs = {};
    for (var transformStep of Object.values(transformSteps)) {
      transformInputs[transformStep.id] = {};
      for (var input of transformStep.inputs) {
        transformInputs[transformStep.id][input.name] = null;
      }
      transformOutputs[transformStep.id] = {};
      for (var output of transformStep.outputs) {
        transformOutputs[transformStep.id][output] = null;
      }
    }
    // Copy inputs to transforms
    for (var [inputKey, inputValue] of Object.entries(inputValues)) {
      for (var _transformStep of transformSteps) {
        for (var _input of _transformStep.inputs) {
          if (_input.source === "Input ".concat(inputKey)) {
            this.verbose && console.log("Copying Input ".concat(inputKey, " to Transform ").concat(_transformStep.id, " ").concat(_input.name, " input"));
            transformInputs[_transformStep.id][_input.name] = inputValue;
          }
        }
      }
    }
    // Propagate values between transforms until nothing changes
    var changed = true;
    var nWaitingTransforms = 0;
    while (changed) {
      changed = false;
      for (var _transformStep2 of transformSteps) {
        if (Object.values(transformInputs[_transformStep2.id]).filter(i => !i).length === 0 && Object.values(transformOutputs[_transformStep2.id]).filter(i => !i).length > 0) {
          this.verbose && console.log("Evaluating Transform ".concat(_transformStep2.id));
          try {
            transformOutputs[_transformStep2.id] = this.transforms[_transformStep2.name].code(_objectSpread(_objectSpread({}, transformInputs[_transformStep2.id]), {}, {
              proskomma: this.getProskomma()
            }));
          } catch (err) {
            var errMsg = "Error evaluating Transform ".concat(_transformStep2.id, " (name=").concat(_transformStep2.name, ", type=").concat(typeof _transformStep2.code, "): ").concat(err);
            throw new Error(errMsg);
          }
          for (var consumingTransform of transformSteps) {
            for (var consumingInput of consumingTransform.inputs) {
              for (var resolvedOutput of Object.keys(transformOutputs[_transformStep2.id])) {
                if (consumingInput.source === "Transform ".concat(_transformStep2.id, " ").concat(resolvedOutput)) {
                  this.verbose && console.log("Copying Transform ".concat(_transformStep2.id, " ").concat(resolvedOutput, " output to Transform ").concat(consumingTransform.id, " ").concat(consumingInput.name, " input"));
                  transformInputs[consumingTransform.id][consumingInput.name] = transformOutputs[_transformStep2.id][resolvedOutput];
                }
              }
            }
          }
          changed = true;
        }
      }
    }
    if (nWaitingTransforms) {
      throw new Error("Inputs not satisfied for ".concat(nWaitingTransforms, " transform(s)"));
    }
    // Copy to output;
    var outputValues = {};
    for (var _output of outputStep.outputs) {
      var transformN = _output.source.split(' ')[1];
      this.verbose && console.log("Copying Transform ".concat(transformN, " ").concat(_output.name, " to Output ").concat(_output.name));
      outputValues[_output.name] = transformOutputs[transformN][_output.name];
    }
    this.verbose && console.log('****');
    return outputValues;
  }
}
module.exports = PipelineHandler;

/**
 * Proskomma instance
 * @typedef Proskomma
 * @see {@link https://github.com/mvahowe/proskomma-js}
 */