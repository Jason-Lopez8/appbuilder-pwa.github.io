"use strict";

var oneifyTag = t => {
  if (['toc', 'toca', 'mt', 'imt', 's', 'ms', 'mte', 'sd'].includes(t)) {
    return t + '1';
  }
  return t;
};
var buildMilestone = function buildMilestone(type) {
  var atts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (atts == null) atts = {};
  var str = "\\".concat(type, "-s |");
  for (var [key, value] of Object.entries(atts)) {
    if (key === "x-morph" && typeof value !== "string") {
      str = str + oneifyTag(key) + "=\"" + value.join(',') + "\" ";
    } else {
      str = str + oneifyTag(key) + "=\"" + value + "\" ";
    }
  }
  ;
  return str + "\\*";
};
var buildEndWrapper = function buildEndWrapper(type) {
  var atts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var isnested = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (atts == null) atts = {};
  var str = "|";
  for (var [key, value] of Object.entries(atts)) {
    str = str + oneifyTag(key) + "=\"" + value + "\" ";
  }
  ;
  str = str + "\\";

  // if it's nested, we simply add a "+" sign before the type
  if (isnested) {
    str = str + "+";
  }
  return str + type + "*";
};
var perfToUsfmActions = {
  startDocument: [{
    description: "Set up environment",
    test: () => true,
    action: _ref => {
      var {
        context,
        workspace
      } = _ref;
      workspace.usfmBits = [''];
      workspace.nestedWrapper = 0;
      for (var [key, value] of Object.entries(context.document.metadata.document).filter(kv => !['tags', 'properties', 'bookCode', 'cl'].includes(kv[0]))) {
        workspace.usfmBits.push("\\".concat(oneifyTag(key), " ").concat(value, "\n"));
      }
      ;
    }
  }],
  blockGraft: [{
    description: "Follow block grafts",
    test: _ref2 => {
      var {
        context
      } = _ref2;
      return ['title', 'heading', 'introduction'].includes(context.sequences[0].block.subType);
    },
    action: environment => {
      var contextSequence = environment.context.sequences[0];
      var chapterValue = environment.config.report[contextSequence.block.blockN.toString()];
      var target = contextSequence.block.target;
      if (chapterValue && contextSequence.type === "main") {
        environment.workspace.usfmBits.push("\n\\c ".concat(chapterValue, "\n"));
      }
      if (target) {
        environment.context.renderer.renderSequenceId(environment, target);
      }
    }
  }],
  inlineGraft: [{
    description: "Follow inline grafts",
    test: () => true,
    action: environment => {
      var target = environment.context.sequences[0].element.target;
      if (target) {
        environment.context.renderer.renderSequenceId(environment, target);
      }
    }
  }],
  startParagraph: [{
    description: "Output footnote paragraph tag (footnote)",
    test: _ref3 => {
      var {
        context
      } = _ref3;
      return context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref";
    },
    action: _ref4 => {
      var {
        context,
        workspace,
        config
      } = _ref4;
      workspace.nestedWrapper = 0;
      var contextSequence = context.sequences[0];
      workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.block.subType.split(':')[1]), " "));
    }
  }, {
    description: "Output footnote note_caller tag (footnote)",
    test: _ref5 => {
      var {
        context
      } = _ref5;
      return context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x";
    },
    action: _ref6 => {
      var {
        context,
        workspace,
        config
      } = _ref6;
      workspace.nestedWrapper = 0;
    }
  }, {
    description: "Output paragraph tag (main)",
    test: () => true,
    action: _ref7 => {
      var {
        context,
        workspace,
        config
      } = _ref7;
      workspace.nestedWrapper = 0;
      var contextSequence = context.sequences[0];
      var chapterValue = config.report[contextSequence.block.blockN.toString()];
      if (chapterValue && contextSequence.type === "main") {
        workspace.usfmBits.push("\n\\c ".concat(chapterValue, "\n"));
      }
      workspace.usfmBits.push("\n\\".concat(oneifyTag(contextSequence.block.subType.split(':')[1]), "\n"));
    }
  }],
  endParagraph: [{
    description: "Output footnote paragraph tag (footnote)",
    test: _ref8 => {
      var {
        context
      } = _ref8;
      return context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref";
    },
    action: _ref9 => {
      var {
        context,
        workspace,
        config
      } = _ref9;
      var contextSequence = context.sequences[0];
      workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.block.subType.split(':')[1]), "*"));
    }
  }, {
    description: "Output footnote note_caller tag (footnote)",
    test: _ref10 => {
      var {
        context
      } = _ref10;
      return context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x";
    },
    action: _ref11 => {
      var {
        context,
        workspace,
        config
      } = _ref11;
    }
  }, {
    description: "Output nl",
    test: () => true,
    action: _ref12 => {
      var {
        workspace
      } = _ref12;
      workspace.usfmBits.push("\n");
    }
  }],
  startMilestone: [{
    description: "Output start milestone",
    test: () => true,
    action: _ref13 => {
      var {
        context,
        workspace
      } = _ref13;
      var contextSequenceElement = context.sequences[0].element;
      var newStartMileStone = buildMilestone(oneifyTag(contextSequenceElement.subType.split(':')[1]), contextSequenceElement.atts);
      workspace.usfmBits.push(newStartMileStone);
    }
  }],
  endMilestone: [{
    description: "Output end milestone",
    test: () => true,
    action: _ref14 => {
      var {
        context,
        workspace
      } = _ref14;
      workspace.usfmBits.push("\\".concat(oneifyTag(context.sequences[0].element.subType.split(':')[1]), "-e\\*"));
    }
  }],
  text: [{
    description: "Output text",
    test: () => true,
    action: _ref15 => {
      var {
        context,
        workspace
      } = _ref15;
      var text = context.sequences[0].element.text;
      workspace.usfmBits.push(text);
    }
  }],
  mark: [{
    description: "Output chapter or verses",
    test: () => true,
    action: _ref16 => {
      var {
        context,
        workspace
      } = _ref16;
      var element = context.sequences[0].element;
      if (element.subType === 'verses') {
        workspace.usfmBits.push("\n\\v ".concat(element.atts['number'], "\n"));
      }
    }
  }],
  endSequence: [{
    description: "Output \\cl",
    test: _ref17 => {
      var {
        context
      } = _ref17;
      return context.document.metadata.document.cl && context.sequences[0].type === "title";
    },
    action: _ref18 => {
      var {
        context,
        workspace
      } = _ref18;
      workspace.usfmBits.push("\n\\cl ".concat(context.document.metadata.document.cl, "\n"));
    }
  }],
  startWrapper: [{
    description: "Output start tag",
    test: () => true,
    action: _ref19 => {
      var {
        workspace,
        context
      } = _ref19;
      var contextSequence = context.sequences[0];
      // handle nested wrappers : https://ubsicap.github.io/usfm/characters/nesting.html
      if (workspace.nestedWrapper > 0) {
        workspace.usfmBits.push("\\+".concat(oneifyTag(contextSequence.element.subType.split(':')[1]), " "));
      } else {
        workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.element.subType.split(':')[1]), " "));
      }
      workspace.nestedWrapper += 1;
    }
  }],
  endWrapper: [{
    description: "Output end tag",
    test: _ref20 => {
      var {
        context
      } = _ref20;
      return !['fr', 'fq', 'fqa', 'fk', 'fl', 'fw', 'fp', 'ft', 'xo', 'xk', 'xq', 'xt', 'xta'].includes(context.sequences[0].element.subType.split(':')[1]);
    },
    action: _ref21 => {
      var {
        workspace,
        context
      } = _ref21;
      workspace.nestedWrapper -= 1;
      var contextSequence = context.sequences[0];
      var subType = contextSequence.element.subType.split(':')[1];
      var isNested = workspace.nestedWrapper > 0;
      if (subType === "w") {
        var newEndW = buildEndWrapper(oneifyTag(subType), contextSequence.element.atts, isNested);
        workspace.usfmBits.push(newEndW);
      } else {
        // handle nested wrappers : https://ubsicap.github.io/usfm/characters/nesting.html
        if (isNested) {
          workspace.usfmBits.push("\\+".concat(oneifyTag(contextSequence.element.subType.split(':')[1]), "*"));
        } else {
          workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.element.subType.split(':')[1]), "*"));
        }
      }
    }
  }, {
    description: "Do NOT output end tag",
    test: () => true,
    action: _ref22 => {
      var {
        workspace
      } = _ref22;
      workspace.nestedWrapper -= 1;
    }
  }],
  endDocument: [{
    description: "Build output",
    test: () => true,
    action: _ref23 => {
      var {
        workspace,
        output
      } = _ref23;
      output.usfm = workspace.usfmBits.join('').replace(/(\s*)\n(\s*)/gm, "\n");
    }
  }]
};
module.exports = {
  perfToUsfmActions
};