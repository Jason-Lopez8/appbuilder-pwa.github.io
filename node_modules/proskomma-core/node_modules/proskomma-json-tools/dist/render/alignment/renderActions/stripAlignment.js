"use strict";

var _xregexp = _interopRequireDefault(require("xregexp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var stripMarkupActions = {
  startDocument: [{
    description: "Set up",
    test: () => true,
    action: _ref => {
      var {
        workspace,
        output
      } = _ref;
      workspace.chapter = null;
      workspace.verses = null;
      workspace.lastWord = "";
      workspace.waitingMarkup = [];
      workspace.currentOccurrences = {};
      workspace.PendingStartMilestones = [];
      output.stripped = {};
      output.unalignedWords = {};
      return true;
    }
  }],
  startMilestone: [{
    description: "Ignore zaln startMilestone events",
    test: _ref2 => {
      var {
        context
      } = _ref2;
      return context.sequences[0].element.subType === "usfm:zaln";
    },
    action: _ref3 => {
      var {
        context,
        workspace
      } = _ref3;
      var payload = context.sequences[0].element;
      payload.subtype = payload.subType;
      delete payload.subType;
      workspace.waitingMarkup.push(payload);
      workspace.PendingStartMilestones.push(payload);
    }
  }],
  endMilestone: [{
    description: "Ignore zaln endMilestone events",
    test: _ref4 => {
      var {
        context
      } = _ref4;
      return context.sequences[0].element.subType === "usfm:zaln";
    },
    action: _ref5 => {
      var {
        context,
        workspace,
        output,
        config
      } = _ref5;
      var {
        chapter,
        verses,
        lastWord: word
      } = workspace;
      var {
        verseWords: totalOccurrences
      } = config;
      var strippedKey = ["after", word, workspace.currentOccurrences[word], totalOccurrences[chapter][verses][word]].join("--");
      var payload = _objectSpread({}, context.sequences[0].element);
      payload.subtype = payload.subType;
      delete payload.subType;
      var record = {
        chapter: chapter,
        verses: verses,
        occurrence: workspace.currentOccurrences[word],
        occurrences: totalOccurrences[chapter][verses][word],
        position: "after",
        word,
        payload,
        startMilestone: workspace.PendingStartMilestones.shift()
      };
      if (!output.stripped[workspace.chapter][workspace.verses][strippedKey]) {
        output.stripped[workspace.chapter][workspace.verses][strippedKey] = [record];
      } else {
        output.stripped[workspace.chapter][workspace.verses][strippedKey].push(record);
      }
      return false;
    }
  }],
  startWrapper: [{
    description: "Ignore w startWrapper events",
    test: _ref6 => {
      var {
        context
      } = _ref6;
      return context.sequences[0].element.subType === "usfm:w";
    },
    action: _ref7 => {
      var {
        context,
        workspace
      } = _ref7;
      var payload = _objectSpread({}, context.sequences[0].element);
      payload.subtype = payload.subType;
      delete payload.subType;
      workspace.waitingMarkup.push(payload);
    }
  }],
  endWrapper: [{
    description: "Ignore w endWrapper events",
    test: _ref8 => {
      var {
        context
      } = _ref8;
      return context.sequences[0].element.subType === "usfm:w";
    },
    action: _ref9 => {
      var {
        context
      } = _ref9;
    }
  }],
  text: [{
    description: "Log occurrences",
    test: () => true,
    action: _ref10 => {
      var {
        context,
        workspace,
        output,
        config
      } = _ref10;
      try {
        var sequence = context.sequences[0];
        if (sequence.type !== 'main') return true;
        var text = sequence.element.text;
        var re = (0, _xregexp.default)("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})");
        var words = _xregexp.default.match(text, re, "all");
        var {
          chapter,
          verses
        } = workspace;
        var {
          verseWords: totalOccurrences
        } = config;
        for (var word of words) {
          var _workspace$currentOcc, _workspace$currentOcc2;
          (_workspace$currentOcc2 = (_workspace$currentOcc = workspace.currentOccurrences)[word]) !== null && _workspace$currentOcc2 !== void 0 ? _workspace$currentOcc2 : _workspace$currentOcc[word] = 0;
          workspace.currentOccurrences[word]++;
          if (!workspace.PendingStartMilestones.length && workspace.waitingMarkup.length) {
            var _output$unalignedWord, _output$unalignedWord2, _output$unalignedWord3, _output$unalignedWord4;
            (_output$unalignedWord2 = (_output$unalignedWord = output.unalignedWords)[chapter]) !== null && _output$unalignedWord2 !== void 0 ? _output$unalignedWord2 : _output$unalignedWord[chapter] = {};
            (_output$unalignedWord4 = (_output$unalignedWord3 = output.unalignedWords[chapter])[verses]) !== null && _output$unalignedWord4 !== void 0 ? _output$unalignedWord4 : _output$unalignedWord3[verses] = [];
            output.unalignedWords[chapter][verses].push({
              word,
              occurrence: workspace.currentOccurrences[word],
              totalOccurrences: totalOccurrences[chapter][verses][word]
            });
          }
          while (workspace.waitingMarkup.length) {
            var payload = workspace.waitingMarkup.shift();
            var strippedKey = ["before", word, workspace.currentOccurrences[word], totalOccurrences[chapter][verses][word]].join("--");
            var record = {
              chapter: chapter,
              verses: verses,
              occurrence: workspace.currentOccurrences[word],
              occurrences: totalOccurrences[chapter][verses][word],
              position: "before",
              word,
              payload: _objectSpread(_objectSpread({}, payload), payload.subtype === "usfm:w" && {
                content: [word]
              })
            };
            if (!output.stripped[workspace.chapter][workspace.verses][strippedKey]) {
              output.stripped[workspace.chapter][workspace.verses][strippedKey] = [record];
            } else {
              output.stripped[workspace.chapter][workspace.verses][strippedKey].push(record);
            }
          }
          workspace.lastWord = word;
        }
      } catch (err) {
        console.error(err);
        throw err;
      }
      return true;
    }
  }],
  mark: [{
    description: "Update CV state",
    test: () => true,
    action: _ref11 => {
      var {
        context,
        workspace,
        output
      } = _ref11;
      try {
        var element = context.sequences[0].element;
        if (element.subType === "chapter") {
          workspace.chapter = element.atts["number"];
          workspace.verses = 0;
          workspace.lastWord = "";
          workspace.currentOccurrences = {};
          output.stripped[workspace.chapter] = {};
          output.stripped[workspace.chapter][workspace.verses] = {};
        } else if (element.subType === "verses") {
          workspace.verses = element.atts["number"];
          workspace.lastWord = "";
          workspace.currentOccurrences = {};
          output.stripped[workspace.chapter][workspace.verses] = {};
        }
      } catch (err) {
        console.error(err);
        throw err;
      }
      return true;
    }
  }]
};
module.exports = {
  stripMarkupActions
};