"use strict";

var _xregexp = _interopRequireDefault(require("xregexp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var lexingRegexes = [["printable", "wordLike", (0, _xregexp.default)("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})")], ["printable", "lineSpace", (0, _xregexp.default)("([\\p{Separator}\t]{1,127})")], ["printable", "punctuation", (0, _xregexp.default)("([\\p{Punctuation}\\p{Math_Symbol}\\p{Currency_Symbol}\\p{Modifier_Symbol}\\p{Other_Symbol}])")], ["bad", "unknown", (0, _xregexp.default)("(.)")]];
var re = _xregexp.default.union(lexingRegexes.map(x => x[2]));
var endMilestone = {
  type: "end_milestone",
  subtype: "usfm:zaln"
};
var mergeAlignmentActions = {
  startDocument: [{
    description: "setup",
    test: () => true,
    action: _ref => {
      var {
        workspace,
        output
      } = _ref;
      workspace.chapter = null;
      workspace.verses = null;
      workspace.currentOccurrences = {};
      output.unalignedWords = {};
      return true;
    }
  }],
  text: [{
    description: "add-to-text",
    test: () => true,
    action: _ref2 => {
      var {
        config,
        context,
        workspace,
        output
      } = _ref2;
      try {
        var sequence = context.sequences[0];
        if (sequence.type !== 'main') return true;
        var text = context.sequences[0].element.text;
        var words = _xregexp.default.match(text, re, "all");
        var {
          chapter,
          verses
        } = workspace;
        if (!verses) return true;
        var {
          totalOccurrences,
          strippedAlignment
        } = config;
        var alignments = {
          opened: null
        };
        var addWrappers = _ref3 => {
          var {
            subtype,
            content = [],
            atts = {}
          } = _ref3;
          if (Object.keys(atts).length > 0) {
            return {
              type: "wrapper",
              subtype,
              content,
              atts
            };
          }
          return {
            type: "wrapper",
            subtype,
            content
          };
        };
        var onHoldChars = [];
        function pushOnHoldChars() {
          while (onHoldChars.length) {
            workspace.outputContentStack[0].push(onHoldChars.shift());
          }
        }
        var _loop = function _loop(word) {
          var _xre$match, _workspace$currentOcc, _workspace$currentOcc2;
          var isWord = (_xre$match = _xregexp.default.match(word, lexingRegexes[0][2], "all")) === null || _xre$match === void 0 ? void 0 : _xre$match.length;
          if (!isWord) {
            onHoldChars.push(word);
            return "continue";
          }
          (_workspace$currentOcc2 = (_workspace$currentOcc = workspace.currentOccurrences)[word]) !== null && _workspace$currentOcc2 !== void 0 ? _workspace$currentOcc2 : _workspace$currentOcc[word] = 0;
          workspace.currentOccurrences[word]++;
          var strippedKey = position => [position, word, workspace.currentOccurrences[word], totalOccurrences[chapter][verses][word]].join("--");
          var markup = strippedAlignment[chapter][verses];
          var skipStartMilestone = false;
          var afterWord = markup[strippedKey("after")];
          var beforeWord = markup[strippedKey("before")];
          if (beforeWord !== null && beforeWord !== void 0 && beforeWord.length) pushOnHoldChars();
          if (afterWord !== null && afterWord !== void 0 && afterWord.length && !alignments.opened) {
            afterWord.map(_ref4 => {
              var {
                startMilestone
              } = _ref4;
              return workspace.outputContentStack[0].push(startMilestone);
            });
            skipStartMilestone = true;
          }

          //TODO: Count number of opened alignments, to close them when there is a modified/new word in the current iteration.
          beforeWord === null || beforeWord === void 0 ? void 0 : beforeWord.forEach(_ref5 => {
            var {
              payload
            } = _ref5;
            if (payload.type !== "start_milestone") {
              workspace.outputContentStack[0].push(payload);
            }
            if (payload.type === "start_milestone" && !skipStartMilestone) {
              workspace.outputContentStack[0].push(payload);
              alignments.opened = true;
            }
          });

          //TODO: Decrease number of opened alignments as they are being pushed
          afterWord === null || afterWord === void 0 ? void 0 : afterWord.forEach(_ref6 => {
            var {
              payload
            } = _ref6;
            alignments.opened = false;
            workspace.outputContentStack[0].push(payload);
          });

          //TODO: Add as many endMilestones as there are opened in alignments.opened, and set the later to 0.
          if (!(beforeWord !== null && beforeWord !== void 0 && beforeWord.length)) {
            var _output$unalignedWord, _output$unalignedWord2, _output$unalignedWord3, _output$unalignedWord4;
            if (alignments.opened) {
              workspace.outputContentStack[0].push(endMilestone);
              alignments.opened = false;
            }
            pushOnHoldChars();
            (_output$unalignedWord2 = (_output$unalignedWord = output.unalignedWords)[chapter]) !== null && _output$unalignedWord2 !== void 0 ? _output$unalignedWord2 : _output$unalignedWord[chapter] = {};
            (_output$unalignedWord4 = (_output$unalignedWord3 = output.unalignedWords[chapter])[verses]) !== null && _output$unalignedWord4 !== void 0 ? _output$unalignedWord4 : _output$unalignedWord3[verses] = [];
            output.unalignedWords[workspace.chapter][workspace.verses].push({
              word,
              occurrence: workspace.currentOccurrences[word],
              totalOccurrences: totalOccurrences[chapter][verses][word]
            });
            var wrappedWord = addWrappers({
              subtype: "usfm:w",
              content: [word]
            });
            workspace.outputContentStack[0].push(wrappedWord);
          }
        };
        for (var word of words) {
          var _ret = _loop(word);
          if (_ret === "continue") continue;
        }
        pushOnHoldChars();
        return false;
      } catch (err) {
        console.error(err);
        throw err;
      }
    }
  }],
  mark: [{
    description: "mark-chapters",
    test: _ref7 => {
      var {
        context
      } = _ref7;
      return context.sequences[0].element.subType === "chapter";
    },
    action: _ref8 => {
      var {
        config,
        context,
        workspace,
        output
      } = _ref8;
      var element = context.sequences[0].element;
      workspace.chapter = element.atts["number"];
      workspace.verses = 0;
      return true;
    }
  }, {
    description: "mark-verses",
    test: _ref9 => {
      var {
        context
      } = _ref9;
      return context.sequences[0].element.subType === "verses";
    },
    action: _ref10 => {
      var {
        config,
        context,
        workspace,
        output
      } = _ref10;
      var element = context.sequences[0].element;
      workspace.verses = element.atts["number"];
      workspace.currentOccurrences = {};
      return true;
    }
  }]
};
module.exports = {
  mergeAlignmentActions
};