import {
  require_fast_deep_equal,
  require_uri_all
} from "./chunk-OFYVAPBY.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  init_buffer,
  init_process,
  process
} from "./chunk-RCGB56J2.js";

// node_modules/core-js-pure/internals/global.js
var require_global = __commonJS({
  "node_modules/core-js-pure/internals/global.js"(exports, module) {
    init_process();
    init_buffer();
    var check = function(it) {
      return it && it.Math == Math && it;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof globalThis == "object" && globalThis) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js-pure/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js-pure/internals/fails.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js-pure/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-native.js"(exports, module) {
    init_process();
    init_buffer();
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js-pure/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js-pure/internals/function-apply.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js-pure/internals/classof-raw.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var toString3 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString3(it), 8, -1);
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-clause.js"(exports, module) {
    init_process();
    init_buffer();
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// node_modules/core-js-pure/internals/document-all.js
var require_document_all = __commonJS({
  "node_modules/core-js-pure/internals/document-all.js"(exports, module) {
    init_process();
    init_buffer();
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});

// node_modules/core-js-pure/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js-pure/internals/is-callable.js"(exports, module) {
    init_process();
    init_buffer();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js-pure/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js-pure/internals/descriptors.js"(exports, module) {
    init_process();
    init_buffer();
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});

// node_modules/core-js-pure/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js-pure/internals/function-call.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// node_modules/core-js-pure/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js-pure/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js-pure/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/create-property-descriptor.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js-pure/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/indexed-object.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// node_modules/core-js-pure/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js-pure/internals/is-null-or-undefined.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// node_modules/core-js-pure/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js-pure/internals/require-object-coercible.js"(exports, module) {
    init_process();
    init_buffer();
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it))
        throw $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/to-indexed-object.js"(exports, module) {
    init_process();
    init_buffer();
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// node_modules/core-js-pure/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js-pure/internals/is-object.js"(exports, module) {
    init_process();
    init_buffer();
    var isCallable = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// node_modules/core-js-pure/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js-pure/internals/path.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in.js"(exports, module) {
    init_process();
    init_buffer();
    var path = require_path();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = function(variable) {
      return isCallable(variable) ? variable : void 0;
    };
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
    };
  }
});

// node_modules/core-js-pure/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-is-prototype-of.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js-pure/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "node_modules/core-js-pure/internals/engine-user-agent.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  }
});

// node_modules/core-js-pure/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-v8-version.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process2 = global2.process;
    var Deno = global2.Deno;
    var versions2 = process2 && process2.versions || Deno && Deno.version;
    var v8 = versions2 && versions2.v8;
    var match;
    var version3;
    if (v8) {
      match = v8.split(".");
      version3 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version3 && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version3 = +match[1];
      }
    }
    module.exports = version3;
  }
});

// node_modules/core-js-pure/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-constructor-detection.js"(exports, module) {
    init_process();
    init_buffer();
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js-pure/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js-pure/internals/use-symbol-as-uid.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js-pure/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js-pure/internals/is-symbol.js"(exports, module) {
    init_process();
    init_buffer();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// node_modules/core-js-pure/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js-pure/internals/try-to-string.js"(exports, module) {
    init_process();
    init_buffer();
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js-pure/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js-pure/internals/a-callable.js"(exports, module) {
    init_process();
    init_buffer();
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js-pure/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js-pure/internals/get-method.js"(exports, module) {
    init_process();
    init_buffer();
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js-pure/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/ordinary-to-primitive.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject2 = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
        return val;
      throw $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js-pure/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js-pure/internals/is-pure.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = true;
  }
});

// node_modules/core-js-pure/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js-pure/internals/define-global-property.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js-pure/internals/shared-store.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
    module.exports = store;
  }
});

// node_modules/core-js-pure/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js-pure/internals/shared.js"(exports, module) {
    init_process();
    init_buffer();
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.27.2",
      mode: IS_PURE ? "pure" : "global",
      copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js-pure/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js-pure/internals/to-object.js"(exports, module) {
    init_process();
    init_buffer();
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js-pure/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js-pure/internals/has-own-property.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty3 = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty3(toObject(it), key);
    };
  }
});

// node_modules/core-js-pure/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js-pure/internals/uid.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString3 = uncurryThis(1 .toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString3(++id + postfix, 36);
    };
  }
});

// node_modules/core-js-pure/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = global2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// node_modules/core-js-pure/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/to-primitive.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var isObject2 = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject2(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject2(result) || isSymbol(result))
          return result;
        throw $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js-pure/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js-pure/internals/to-property-key.js"(exports, module) {
    init_process();
    init_buffer();
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// node_modules/core-js-pure/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js-pure/internals/document-create-element.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var isObject2 = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject2(document2) && isObject2(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js-pure/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js-pure/internals/ie8-dom-define.js"(exports, module) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-descriptor.js"(exports) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (hasOwn(O, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    };
  }
});

// node_modules/core-js-pure/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js-pure/internals/is-forced.js"(exports, module) {
    init_process();
    init_buffer();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js-pure/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-context.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind = uncurryThis(uncurryThis.bind);
    module.exports = function(fn, that) {
      aCallable(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js-pure/internals/v8-prototype-define-bug.js"(exports, module) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype != 42;
    });
  }
});

// node_modules/core-js-pure/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js-pure/internals/an-object.js"(exports, module) {
    init_process();
    init_buffer();
    var isObject2 = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject2(argument))
        return argument;
      throw $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js-pure/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js-pure/internals/object-define-property.js"(exports) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
  }
});

// node_modules/core-js-pure/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js-pure/internals/create-non-enumerable-property.js"(exports, module) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js-pure/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js-pure/internals/export.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var global2 = require_global();
    var apply = require_function_apply();
    var uncurryThis = require_function_uncurry_this_clause();
    var isCallable = require_is_callable();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var isForced = require_is_forced();
    var path = require_path();
    var bind = require_function_bind_context();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var wrapConstructor = function(NativeConstructor) {
      var Wrapper = function(a, b, c) {
        if (this instanceof Wrapper) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a);
            case 2:
              return new NativeConstructor(a, b);
          }
          return new NativeConstructor(a, b, c);
        }
        return apply(NativeConstructor, this, arguments);
      };
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    };
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var PROTO = options.proto;
      var nativeSource = GLOBAL ? global2 : STATIC ? global2[TARGET] : (global2[TARGET] || {}).prototype;
      var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
      var targetPrototype = target.prototype;
      var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key in source) {
        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
        USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
        targetProperty = target[key];
        if (USE_NATIVE)
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(nativeSource, key);
            nativeProperty = descriptor && descriptor.value;
          } else
            nativeProperty = nativeSource[key];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
        if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)
          continue;
        if (options.bind && USE_NATIVE)
          resultProperty = bind(sourceProperty, global2);
        else if (options.wrap && USE_NATIVE)
          resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty))
          resultProperty = uncurryThis(sourceProperty);
        else
          resultProperty = sourceProperty;
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(resultProperty, "sham", true);
        }
        createNonEnumerableProperty(target, key, resultProperty);
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
          }
          createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
          if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
            createNonEnumerableProperty(targetPrototype, key, sourceProperty);
          }
        }
      }
    };
  }
});

// node_modules/core-js-pure/modules/es.object.define-property.js
var require_es_object_define_property = __commonJS({
  "node_modules/core-js-pure/modules/es.object.define-property.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var defineProperty = require_object_define_property().f;
    $({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
      defineProperty
    });
  }
});

// node_modules/core-js-pure/es/object/define-property.js
var require_define_property = __commonJS({
  "node_modules/core-js-pure/es/object/define-property.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_object_define_property();
    var path = require_path();
    var Object2 = path.Object;
    var defineProperty = module.exports = function defineProperty2(it, key, desc) {
      return Object2.defineProperty(it, key, desc);
    };
    if (Object2.defineProperty.sham)
      defineProperty.sham = true;
  }
});

// node_modules/core-js-pure/stable/object/define-property.js
var require_define_property2 = __commonJS({
  "node_modules/core-js-pure/stable/object/define-property.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_define_property();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js
var require_define_property3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_define_property2();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/interopRequireDefault.js"(exports, module) {
    init_process();
    init_buffer();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/internals/is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js-pure/internals/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    var classof = require_classof_raw();
    module.exports = Array.isArray || function isArray3(argument) {
      return classof(argument) == "Array";
    };
  }
});

// node_modules/core-js-pure/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js-pure/internals/to-string-tag-support.js"(exports, module) {
    init_process();
    init_buffer();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// node_modules/core-js-pure/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js-pure/internals/classof.js"(exports, module) {
    init_process();
    init_buffer();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js-pure/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "node_modules/core-js-pure/internals/inspect-source.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// node_modules/core-js-pure/internals/is-constructor.js
var require_is_constructor = __commonJS({
  "node_modules/core-js-pure/internals/is-constructor.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var classof = require_classof();
    var getBuiltIn = require_get_built_in();
    var inspectSource = require_inspect_source();
    var noop2 = function() {
    };
    var empty = [];
    var construct = getBuiltIn("Reflect", "construct");
    var constructorRegExp = /^\s*(?:class|function)\b/;
    var exec = uncurryThis(constructorRegExp.exec);
    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop2);
    var isConstructorModern = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      try {
        construct(noop2, empty, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    var isConstructorLegacy = function isConstructor(argument) {
      if (!isCallable(argument))
        return false;
      switch (classof(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    module.exports = !construct || fails(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
  }
});

// node_modules/core-js-pure/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js-pure/internals/math-trunc.js"(exports, module) {
    init_process();
    init_buffer();
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    };
  }
});

// node_modules/core-js-pure/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js-pure/internals/to-integer-or-infinity.js"(exports, module) {
    init_process();
    init_buffer();
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// node_modules/core-js-pure/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js-pure/internals/to-absolute-index.js"(exports, module) {
    init_process();
    init_buffer();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// node_modules/core-js-pure/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js-pure/internals/to-length.js"(exports, module) {
    init_process();
    init_buffer();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js-pure/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js-pure/internals/length-of-array-like.js"(exports, module) {
    init_process();
    init_buffer();
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js-pure/internals/create-property.js
var require_create_property = __commonJS({
  "node_modules/core-js-pure/internals/create-property.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var toPropertyKey = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = function(object, key, value) {
      var propertyKey = toPropertyKey(key);
      if (propertyKey in object)
        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
      else
        object[propertyKey] = value;
    };
  }
});

// node_modules/core-js-pure/internals/array-method-has-species-support.js
var require_array_method_has_species_support = __commonJS({
  "node_modules/core-js-pure/internals/array-method-has-species-support.js"(exports, module) {
    init_process();
    init_buffer();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var SPECIES = wellKnownSymbol("species");
    module.exports = function(METHOD_NAME) {
      return V8_VERSION >= 51 || !fails(function() {
        var array = [];
        var constructor = array.constructor = {};
        constructor[SPECIES] = function() {
          return { foo: 1 };
        };
        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
  }
});

// node_modules/core-js-pure/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js-pure/internals/array-slice.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js-pure/modules/es.array.slice.js
var require_es_array_slice = __commonJS({
  "node_modules/core-js-pure/modules/es.array.slice.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var isArray3 = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject2 = require_is_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var toIndexedObject = require_to_indexed_object();
    var createProperty = require_create_property();
    var wellKnownSymbol = require_well_known_symbol();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var nativeSlice = require_array_slice();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    var max = Math.max;
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      slice: function slice2(start, end) {
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var Constructor, result, n;
        if (isArray3(O)) {
          Constructor = O.constructor;
          if (isConstructor(Constructor) && (Constructor === $Array || isArray3(Constructor.prototype))) {
            Constructor = void 0;
          } else if (isObject2(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null)
              Constructor = void 0;
          }
          if (Constructor === $Array || Constructor === void 0) {
            return nativeSlice(O, k, fin);
          }
        }
        result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
        for (n = 0; k < fin; k++, n++)
          if (k in O)
            createProperty(result, n, O[k]);
        result.length = n;
        return result;
      }
    });
  }
});

// node_modules/core-js-pure/internals/entry-virtual.js
var require_entry_virtual = __commonJS({
  "node_modules/core-js-pure/internals/entry-virtual.js"(exports, module) {
    init_process();
    init_buffer();
    var path = require_path();
    module.exports = function(CONSTRUCTOR) {
      return path[CONSTRUCTOR + "Prototype"];
    };
  }
});

// node_modules/core-js-pure/es/array/virtual/slice.js
var require_slice = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/slice.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_slice();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").slice;
  }
});

// node_modules/core-js-pure/es/instance/slice.js
var require_slice2 = __commonJS({
  "node_modules/core-js-pure/es/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_slice();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.slice;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.slice ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/slice.js
var require_slice3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_slice2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js
var require_slice4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_slice3();
  }
});

// node_modules/core-js-pure/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js-pure/internals/to-string.js"(exports, module) {
    init_process();
    init_buffer();
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js-pure/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js-pure/internals/string-multibyte.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString3 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString3(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js-pure/internals/weak-map-basic-detection.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap2 = global2.WeakMap;
    module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// node_modules/core-js-pure/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js-pure/internals/shared-key.js"(exports, module) {
    init_process();
    init_buffer();
    var shared = require_shared();
    var uid = require_uid();
    var keys2 = shared("keys");
    module.exports = function(key) {
      return keys2[key] || (keys2[key] = uid(key));
    };
  }
});

// node_modules/core-js-pure/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js-pure/internals/hidden-keys.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js-pure/internals/internal-state.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject2 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = function(it) {
      return has(it) ? get(it) : set(it, {});
    };
    var getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject2(it) || (state = get(it)).type !== TYPE) {
          throw TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = function(it, metadata) {
        if (store.has(it))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store.get(it) || {};
      };
      has = function(it) {
        return store.has(it);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = function(it, metadata) {
        if (hasOwn(it, STATE))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn(it, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js-pure/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js-pure/internals/function-name.js"(exports, module) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && function something() {
    }.name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js-pure/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js-pure/internals/array-includes.js"(exports, module) {
    init_process();
    init_buffer();
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js-pure/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js-pure/internals/object-keys-internal.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf3 = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i)
        if (hasOwn(O, key = names[i++])) {
          ~indexOf3(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js-pure/internals/enum-bug-keys.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js-pure/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js-pure/internals/object-keys.js"(exports, module) {
    init_process();
    init_buffer();
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys2(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
  }
});

// node_modules/core-js-pure/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js-pure/internals/object-define-properties.js"(exports) {
    init_process();
    init_buffer();
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys2 = objectKeys(Properties);
      var length = keys2.length;
      var index = 0;
      var key;
      while (length > index)
        definePropertyModule.f(O, key = keys2[index++], props[key]);
      return O;
    };
  }
});

// node_modules/core-js-pure/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js-pure/internals/html.js"(exports, module) {
    init_process();
    init_buffer();
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js-pure/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js-pure/internals/object-create.js"(exports, module) {
    init_process();
    init_buffer();
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js-pure/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js-pure/internals/correct-prototype-getter.js"(exports, module) {
    init_process();
    init_buffer();
    var fails = require_fails();
    module.exports = !fails(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-get-prototype-of.js"(exports, module) {
    init_process();
    init_buffer();
    var hasOwn = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
      var object = toObject(O);
      if (hasOwn(object, IE_PROTO))
        return object[IE_PROTO];
      var constructor = object.constructor;
      if (isCallable(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }
      return object instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js-pure/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js-pure/internals/define-built-in.js"(exports, module) {
    init_process();
    init_buffer();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(target, key, value, options) {
      if (options && options.enumerable)
        target[key] = value;
      else
        createNonEnumerableProperty(target, key, value);
      return target;
    };
  }
});

// node_modules/core-js-pure/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js-pure/internals/iterators-core.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject2 = require_is_object();
    var create = require_object_create();
    var getPrototypeOf = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails(function() {
      var test = {};
      return IteratorPrototype[ITERATOR].call(test) !== test;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype = {};
    else if (IS_PURE)
      IteratorPrototype = create(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js-pure/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js-pure/internals/object-to-string.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js-pure/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js-pure/internals/set-to-string-tag.js"(exports, module) {
    init_process();
    init_buffer();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineProperty = require_object_define_property().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var toString3 = require_object_to_string();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(it, TAG, STATIC, SET_METHOD) {
      if (it) {
        var target = STATIC ? it : it.prototype;
        if (!hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
        if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
          createNonEnumerableProperty(target, "toString", toString3);
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js-pure/internals/iterators.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js-pure/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js-pure/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js-pure/internals/a-possible-prototype.js"(exports, module) {
    init_process();
    init_buffer();
    var isCallable = require_is_callable();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (typeof argument == "object" || isCallable(argument))
        return argument;
      throw $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js-pure/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-set-prototype-of.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;
      try {
        setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
  }
});

// node_modules/core-js-pure/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js-pure/internals/iterator-define.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var call = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf = require_object_get_prototype_of();
    var setPrototypeOf = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys2() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE)
            Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return call(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js-pure/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js-pure/internals/create-iter-result-object.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function(value, done2) {
      return { value, done: done2 };
    };
  }
});

// node_modules/core-js-pure/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.string.iterator.js"() {
    "use strict";
    init_process();
    init_buffer();
    var charAt = require_string_multibyte().charAt;
    var toString3 = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString3(iterated),
        index: 0
      });
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length)
        return createIterResultObject(void 0, true);
      point = charAt(string, index);
      state.index += point.length;
      return createIterResultObject(point, false);
    });
  }
});

// node_modules/core-js-pure/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js-pure/internals/iterator-close.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/call-with-safe-iteration-closing.js
var require_call_with_safe_iteration_closing = __commonJS({
  "node_modules/core-js-pure/internals/call-with-safe-iteration-closing.js"(exports, module) {
    init_process();
    init_buffer();
    var anObject = require_an_object();
    var iteratorClose = require_iterator_close();
    module.exports = function(iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (error) {
        iteratorClose(iterator, "throw", error);
      }
    };
  }
});

// node_modules/core-js-pure/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/is-array-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it) {
      if (!isNullOrUndefined(it))
        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod))
        return anObject(call(iteratorMethod, argument));
      throw $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js-pure/internals/array-from.js
var require_array_from = __commonJS({
  "node_modules/core-js-pure/internals/array-from.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var bind = require_function_bind_context();
    var call = require_function_call();
    var toObject = require_to_object();
    var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var isConstructor = require_is_constructor();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var $Array = Array;
    module.exports = function from2(arrayLike) {
      var O = toObject(arrayLike);
      var IS_CONSTRUCTOR = isConstructor(this);
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
      var mapping = mapfn !== void 0;
      if (mapping)
        mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = getIterator(O, iteratorMethod);
        next = iterator.next;
        result = IS_CONSTRUCTOR ? new this() : [];
        for (; !(step = call(next, iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = lengthOfArrayLike(O);
        result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }
      result.length = index;
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/check-correctness-of-iteration.js
var require_check_correctness_of_iteration = __commonJS({
  "node_modules/core-js-pure/internals/check-correctness-of-iteration.js"(exports, module) {
    init_process();
    init_buffer();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    var SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    var called;
    var iteratorWithReturn;
    module.exports = function(exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
      var ITERATION_SUPPORT = false;
      try {
        var object = {};
        object[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec(object);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
  }
});

// node_modules/core-js-pure/modules/es.array.from.js
var require_es_array_from = __commonJS({
  "node_modules/core-js-pure/modules/es.array.from.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var from2 = require_array_from();
    var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
      Array.from(iterable);
    });
    $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
      from: from2
    });
  }
});

// node_modules/core-js-pure/es/array/from.js
var require_from = __commonJS({
  "node_modules/core-js-pure/es/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_string_iterator();
    require_es_array_from();
    var path = require_path();
    module.exports = path.Array.from;
  }
});

// node_modules/core-js-pure/stable/array/from.js
var require_from2 = __commonJS({
  "node_modules/core-js-pure/stable/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_from();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/array/from.js
var require_from3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_from2();
  }
});

// node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js
var require_does_not_exceed_safe_integer = __commonJS({
  "node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js"(exports, module) {
    init_process();
    init_buffer();
    var $TypeError = TypeError;
    var MAX_SAFE_INTEGER = 9007199254740991;
    module.exports = function(it) {
      if (it > MAX_SAFE_INTEGER)
        throw $TypeError("Maximum allowed index exceeded");
      return it;
    };
  }
});

// node_modules/core-js-pure/internals/array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js-pure/internals/array-species-constructor.js"(exports, module) {
    init_process();
    init_buffer();
    var isArray3 = require_is_array();
    var isConstructor = require_is_constructor();
    var isObject2 = require_is_object();
    var wellKnownSymbol = require_well_known_symbol();
    var SPECIES = wellKnownSymbol("species");
    var $Array = Array;
    module.exports = function(originalArray) {
      var C;
      if (isArray3(originalArray)) {
        C = originalArray.constructor;
        if (isConstructor(C) && (C === $Array || isArray3(C.prototype)))
          C = void 0;
        else if (isObject2(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? $Array : C;
    };
  }
});

// node_modules/core-js-pure/internals/array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js-pure/internals/array-species-create.js"(exports, module) {
    init_process();
    init_buffer();
    var arraySpeciesConstructor = require_array_species_constructor();
    module.exports = function(originalArray, length) {
      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
    };
  }
});

// node_modules/core-js-pure/modules/es.array.concat.js
var require_es_array_concat = __commonJS({
  "node_modules/core-js-pure/modules/es.array.concat.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var fails = require_fails();
    var isArray3 = require_is_array();
    var isObject2 = require_is_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
    var createProperty = require_create_property();
    var arraySpeciesCreate = require_array_species_create();
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var wellKnownSymbol = require_well_known_symbol();
    var V8_VERSION = require_engine_v8_version();
    var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var isConcatSpreadable = function(O) {
      if (!isObject2(O))
        return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== void 0 ? !!spreadable : isArray3(O);
    };
    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
    $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      concat: function concat2(arg) {
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;
        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];
          if (isConcatSpreadable(E)) {
            len = lengthOfArrayLike(E);
            doesNotExceedSafeInteger(n + len);
            for (k = 0; k < len; k++, n++)
              if (k in E)
                createProperty(A, n, E[k]);
          } else {
            doesNotExceedSafeInteger(n + 1);
            createProperty(A, n++, E);
          }
        }
        A.length = n;
        return A;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.object.to-string.js
var require_es_object_to_string = __commonJS({
  "node_modules/core-js-pure/modules/es.object.to-string.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-names.js"(exports) {
    init_process();
    init_buffer();
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
  }
});

// node_modules/core-js-pure/internals/array-slice-simple.js
var require_array_slice_simple = __commonJS({
  "node_modules/core-js-pure/internals/array-slice-simple.js"(exports, module) {
    init_process();
    init_buffer();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createProperty = require_create_property();
    var $Array = Array;
    var max = Math.max;
    module.exports = function(O, start, end) {
      var length = lengthOfArrayLike(O);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
      var result = $Array(max(fin - k, 0));
      for (var n = 0; k < fin; k++, n++)
        createProperty(result, n, O[k]);
      result.length = n;
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-names-external.js
var require_object_get_own_property_names_external = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-names-external.js"(exports, module) {
    init_process();
    init_buffer();
    var classof = require_classof_raw();
    var toIndexedObject = require_to_indexed_object();
    var $getOwnPropertyNames = require_object_get_own_property_names().f;
    var arraySlice = require_array_slice_simple();
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = function(it) {
      try {
        return $getOwnPropertyNames(it);
      } catch (error) {
        return arraySlice(windowNames);
      }
    };
    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
    };
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-symbols.js"(exports) {
    init_process();
    init_buffer();
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js-pure/internals/well-known-symbol-wrapped.js
var require_well_known_symbol_wrapped = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol-wrapped.js"(exports) {
    init_process();
    init_buffer();
    var wellKnownSymbol = require_well_known_symbol();
    exports.f = wellKnownSymbol;
  }
});

// node_modules/core-js-pure/internals/well-known-symbol-define.js
var require_well_known_symbol_define = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol-define.js"(exports, module) {
    init_process();
    init_buffer();
    var path = require_path();
    var hasOwn = require_has_own_property();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineProperty = require_object_define_property().f;
    module.exports = function(NAME) {
      var Symbol2 = path.Symbol || (path.Symbol = {});
      if (!hasOwn(Symbol2, NAME))
        defineProperty(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
    };
  }
});

// node_modules/core-js-pure/internals/symbol-define-to-primitive.js
var require_symbol_define_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/symbol-define-to-primitive.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var getBuiltIn = require_get_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var defineBuiltIn = require_define_built_in();
    module.exports = function() {
      var Symbol2 = getBuiltIn("Symbol");
      var SymbolPrototype = Symbol2 && Symbol2.prototype;
      var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
        defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
          return call(valueOf, this);
        }, { arity: 1 });
      }
    };
  }
});

// node_modules/core-js-pure/internals/array-iteration.js
var require_array_iteration = __commonJS({
  "node_modules/core-js-pure/internals/array-iteration.js"(exports, module) {
    init_process();
    init_buffer();
    var bind = require_function_bind_context();
    var uncurryThis = require_function_uncurry_this();
    var IndexedObject = require_indexed_object();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var arraySpeciesCreate = require_array_species_create();
    var push = uncurryThis([].push);
    var createMethod = function(TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var IS_FILTER_REJECT = TYPE == 7;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self2 = IndexedObject(O);
        var boundFunction = bind(callbackfn, that);
        var length = lengthOfArrayLike(self2);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
        var value, result;
        for (; length > index; index++)
          if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O);
            if (TYPE) {
              if (IS_MAP)
                target[index] = result;
              else if (result)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return value;
                  case 6:
                    return index;
                  case 2:
                    push(target, value);
                }
              else
                switch (TYPE) {
                  case 4:
                    return false;
                  case 7:
                    push(target, value);
                }
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };
    module.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.es/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.es/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.es/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.es/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.es/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.es/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.es/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6),
      // `Array.prototype.filterReject` method
      // https://github.com/tc39/proposal-array-filtering
      filterReject: createMethod(7)
    };
  }
});

// node_modules/core-js-pure/modules/es.symbol.constructor.js
var require_es_symbol_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.constructor.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var global2 = require_global();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var $toString = require_to_string();
    var createPropertyDescriptor = require_create_property_descriptor();
    var nativeObjectCreate = require_object_create();
    var objectKeys = require_object_keys();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    var definePropertiesModule = require_object_define_properties();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var defineBuiltIn = require_define_built_in();
    var shared = require_shared();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var uid = require_uid();
    var wellKnownSymbol = require_well_known_symbol();
    var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var defineSymbolToPrimitive = require_symbol_define_to_primitive();
    var setToStringTag = require_set_to_string_tag();
    var InternalStateModule = require_internal_state();
    var $forEach = require_array_iteration().forEach;
    var HIDDEN = sharedKey("hidden");
    var SYMBOL = "Symbol";
    var PROTOTYPE = "prototype";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = global2.Symbol;
    var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
    var TypeError2 = global2.TypeError;
    var QObject = global2.QObject;
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var push = uncurryThis([].push);
    var AllSymbols = shared("symbols");
    var ObjectPrototypeSymbols = shared("op-symbols");
    var WellKnownSymbolsStore = shared("wks");
    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDescriptor = DESCRIPTORS && fails(function() {
      return nativeObjectCreate(nativeDefineProperty({}, "a", {
        get: function() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor)
        delete ObjectPrototype[P];
      nativeDefineProperty(O, P, Attributes);
      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    } : nativeDefineProperty;
    var wrap2 = function(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
      setInternalState(symbol, {
        type: SYMBOL,
        tag,
        description
      });
      if (!DESCRIPTORS)
        symbol.description = description;
      return symbol;
    };
    var $defineProperty = function defineProperty(O, P, Attributes) {
      if (O === ObjectPrototype)
        $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPropertyKey(P);
      anObject(Attributes);
      if (hasOwn(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!hasOwn(O, HIDDEN))
            nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
          O[HIDDEN][key] = true;
        } else {
          if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
            O[HIDDEN][key] = false;
          Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
        }
        return setSymbolDescriptor(O, key, Attributes);
      }
      return nativeDefineProperty(O, key, Attributes);
    };
    var $defineProperties = function defineProperties(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys2, function(key) {
        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
          $defineProperty(O, key, properties[key]);
      });
      return O;
    };
    var $create = function create(O, Properties) {
      return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
    };
    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
      var P = toPropertyKey(V);
      var enumerable = call(nativePropertyIsEnumerable, this, P);
      if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
        return false;
      return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };
    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
      var it = toIndexedObject(O);
      var key = toPropertyKey(P);
      if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
        return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key);
      if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
        descriptor.enumerable = true;
      }
      return descriptor;
    };
    var $getOwnPropertyNames = function getOwnPropertyNames(O) {
      var names = nativeGetOwnPropertyNames(toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
          push(result, key);
      });
      return result;
    };
    var $getOwnPropertySymbols = function(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function(key) {
        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
          push(result, AllSymbols[key]);
        }
      });
      return result;
    };
    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol2() {
        if (isPrototypeOf(SymbolPrototype, this))
          throw TypeError2("Symbol is not a constructor");
        var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
        var tag = uid(description);
        var setter = function(value) {
          if (this === ObjectPrototype)
            call(setter, ObjectPrototypeSymbols, value);
          if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
            this[HIDDEN][tag] = false;
          setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };
        if (DESCRIPTORS && USE_SETTER)
          setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
        return wrap2(tag, description);
      };
      SymbolPrototype = $Symbol[PROTOTYPE];
      defineBuiltIn(SymbolPrototype, "toString", function toString3() {
        return getInternalState(this).tag;
      });
      defineBuiltIn($Symbol, "withoutSetter", function(description) {
        return wrap2(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      definePropertiesModule.f = $defineProperties;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
      wrappedWellKnownSymbolModule.f = function(name) {
        return wrap2(wellKnownSymbol(name), name);
      };
      if (DESCRIPTORS) {
        nativeDefineProperty(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });
        if (!IS_PURE) {
          defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
        }
      }
    }
    $({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
      defineWellKnownSymbol(name);
    });
    $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
      useSetter: function() {
        USE_SETTER = true;
      },
      useSimple: function() {
        USE_SETTER = false;
      }
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
      // `Object.create` method
      // https://tc39.es/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.es/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.es/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.es/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames
    });
    defineSymbolToPrimitive();
    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
  }
});

// node_modules/core-js-pure/internals/symbol-registry-detection.js
var require_symbol_registry_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-registry-detection.js"(exports, module) {
    init_process();
    init_buffer();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
  }
});

// node_modules/core-js-pure/modules/es.symbol.for.js
var require_es_symbol_for = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.for.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var hasOwn = require_has_own_property();
    var toString3 = require_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var StringToSymbolRegistry = shared("string-to-symbol-registry");
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      "for": function(key) {
        var string = toString3(key);
        if (hasOwn(StringToSymbolRegistry, string))
          return StringToSymbolRegistry[string];
        var symbol = getBuiltIn("Symbol")(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.symbol.key-for.js
var require_es_symbol_key_for = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.key-for.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var hasOwn = require_has_own_property();
    var isSymbol = require_is_symbol();
    var tryToString = require_try_to_string();
    var shared = require_shared();
    var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
    var SymbolToStringRegistry = shared("symbol-to-string-registry");
    $({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym))
          throw TypeError(tryToString(sym) + " is not a symbol");
        if (hasOwn(SymbolToStringRegistry, sym))
          return SymbolToStringRegistry[sym];
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.json.stringify.js
var require_es_json_stringify = __commonJS({
  "node_modules/core-js-pure/modules/es.json.stringify.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var isArray3 = require_is_array();
    var isCallable = require_is_callable();
    var isObject2 = require_is_object();
    var isSymbol = require_is_symbol();
    var arraySlice = require_array_slice();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var $stringify = getBuiltIn("JSON", "stringify");
    var exec = uncurryThis(/./.exec);
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var replace = uncurryThis("".replace);
    var numberToString = uncurryThis(1 .toString);
    var tester = /[\uD800-\uDFFF]/g;
    var low = /^[\uD800-\uDBFF]$/;
    var hi = /^[\uDC00-\uDFFF]$/;
    var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
      var symbol = getBuiltIn("Symbol")();
      return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
    });
    var ILL_FORMED_UNICODE = fails(function() {
      return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
    });
    var stringifyWithSymbolsFix = function(it, replacer) {
      var args = arraySlice(arguments);
      var $replacer = replacer;
      if (!isObject2(replacer) && it === void 0 || isSymbol(it))
        return;
      if (!isArray3(replacer))
        replacer = function(key, value) {
          if (isCallable($replacer))
            value = call($replacer, this, key, value);
          if (!isSymbol(value))
            return value;
        };
      args[1] = replacer;
      return apply($stringify, null, args);
    };
    var fixIllFormed = function(match, offset, string) {
      var prev = charAt(string, offset - 1);
      var next = charAt(string, offset + 1);
      if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
        return "\\u" + numberToString(charCodeAt(match, 0), 16);
      }
      return match;
    };
    if ($stringify) {
      $({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        stringify: function stringify(it, replacer, space) {
          var args = arraySlice(arguments);
          var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
          return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
        }
      });
    }
  }
});

// node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js
var require_es_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var fails = require_fails();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var toObject = require_to_object();
    var FORCED = !NATIVE_SYMBOL || fails(function() {
      getOwnPropertySymbolsModule.f(1);
    });
    $({ target: "Object", stat: true, forced: FORCED }, {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
      }
    });
  }
});

// node_modules/core-js-pure/modules/es.symbol.js
var require_es_symbol = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.js"() {
    init_process();
    init_buffer();
    require_es_symbol_constructor();
    require_es_symbol_for();
    require_es_symbol_key_for();
    require_es_json_stringify();
    require_es_object_get_own_property_symbols();
  }
});

// node_modules/core-js-pure/modules/es.symbol.async-iterator.js
var require_es_symbol_async_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.async-iterator.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("asyncIterator");
  }
});

// node_modules/core-js-pure/modules/es.symbol.description.js
var require_es_symbol_description = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.description.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/core-js-pure/modules/es.symbol.has-instance.js
var require_es_symbol_has_instance = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.has-instance.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("hasInstance");
  }
});

// node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js
var require_es_symbol_is_concat_spreadable = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("isConcatSpreadable");
  }
});

// node_modules/core-js-pure/modules/es.symbol.iterator.js
var require_es_symbol_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.iterator.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("iterator");
  }
});

// node_modules/core-js-pure/modules/es.symbol.match.js
var require_es_symbol_match = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.match.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("match");
  }
});

// node_modules/core-js-pure/modules/es.symbol.match-all.js
var require_es_symbol_match_all = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.match-all.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("matchAll");
  }
});

// node_modules/core-js-pure/modules/es.symbol.replace.js
var require_es_symbol_replace = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.replace.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("replace");
  }
});

// node_modules/core-js-pure/modules/es.symbol.search.js
var require_es_symbol_search = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.search.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("search");
  }
});

// node_modules/core-js-pure/modules/es.symbol.species.js
var require_es_symbol_species = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.species.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("species");
  }
});

// node_modules/core-js-pure/modules/es.symbol.split.js
var require_es_symbol_split = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.split.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("split");
  }
});

// node_modules/core-js-pure/modules/es.symbol.to-primitive.js
var require_es_symbol_to_primitive = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.to-primitive.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var defineSymbolToPrimitive = require_symbol_define_to_primitive();
    defineWellKnownSymbol("toPrimitive");
    defineSymbolToPrimitive();
  }
});

// node_modules/core-js-pure/modules/es.symbol.to-string-tag.js
var require_es_symbol_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.to-string-tag.js"() {
    init_process();
    init_buffer();
    var getBuiltIn = require_get_built_in();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    var setToStringTag = require_set_to_string_tag();
    defineWellKnownSymbol("toStringTag");
    setToStringTag(getBuiltIn("Symbol"), "Symbol");
  }
});

// node_modules/core-js-pure/modules/es.symbol.unscopables.js
var require_es_symbol_unscopables = __commonJS({
  "node_modules/core-js-pure/modules/es.symbol.unscopables.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("unscopables");
  }
});

// node_modules/core-js-pure/modules/es.json.to-string-tag.js
var require_es_json_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.json.to-string-tag.js"() {
    init_process();
    init_buffer();
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js-pure/modules/es.math.to-string-tag.js
var require_es_math_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.math.to-string-tag.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/core-js-pure/modules/es.reflect.to-string-tag.js
var require_es_reflect_to_string_tag = __commonJS({
  "node_modules/core-js-pure/modules/es.reflect.to-string-tag.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/core-js-pure/es/symbol/index.js
var require_symbol = __commonJS({
  "node_modules/core-js-pure/es/symbol/index.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_concat();
    require_es_object_to_string();
    require_es_symbol();
    require_es_symbol_async_iterator();
    require_es_symbol_description();
    require_es_symbol_has_instance();
    require_es_symbol_is_concat_spreadable();
    require_es_symbol_iterator();
    require_es_symbol_match();
    require_es_symbol_match_all();
    require_es_symbol_replace();
    require_es_symbol_search();
    require_es_symbol_species();
    require_es_symbol_split();
    require_es_symbol_to_primitive();
    require_es_symbol_to_string_tag();
    require_es_symbol_unscopables();
    require_es_json_to_string_tag();
    require_es_math_to_string_tag();
    require_es_reflect_to_string_tag();
    var path = require_path();
    module.exports = path.Symbol;
  }
});

// node_modules/core-js-pure/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js-pure/internals/add-to-unscopables.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function() {
    };
  }
});

// node_modules/core-js-pure/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state = getInternalState(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind == "keys")
        return createIterResultObject(index, false);
      if (kind == "values")
        return createIterResultObject(target[index], false);
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values.name !== "values")
      try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
  }
});

// node_modules/core-js-pure/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js-pure/internals/dom-iterables.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js-pure/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js-pure/modules/web.dom-collections.iterator.js"() {
    init_process();
    init_buffer();
    require_es_array_iterator();
    var DOMIterables = require_dom_iterables();
    var global2 = require_global();
    var classof = require_classof();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    for (COLLECTION_NAME in DOMIterables) {
      Collection = global2[COLLECTION_NAME];
      CollectionPrototype = Collection && Collection.prototype;
      if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
      }
      Iterators[COLLECTION_NAME] = Iterators.Array;
    }
    var Collection;
    var CollectionPrototype;
    var COLLECTION_NAME;
  }
});

// node_modules/core-js-pure/stable/symbol/index.js
var require_symbol2 = __commonJS({
  "node_modules/core-js-pure/stable/symbol/index.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_symbol();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/symbol.js
var require_symbol3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/symbol.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_symbol2();
  }
});

// node_modules/core-js-pure/es/get-iterator-method.js
var require_get_iterator_method2 = __commonJS({
  "node_modules/core-js-pure/es/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_iterator();
    require_es_string_iterator();
    var getIteratorMethod = require_get_iterator_method();
    module.exports = getIteratorMethod;
  }
});

// node_modules/core-js-pure/stable/get-iterator-method.js
var require_get_iterator_method3 = __commonJS({
  "node_modules/core-js-pure/stable/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_get_iterator_method2();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/get-iterator-method.js
var require_get_iterator_method4 = __commonJS({
  "node_modules/core-js-pure/actual/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_get_iterator_method3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/get-iterator-method.js
var require_get_iterator_method5 = __commonJS({
  "node_modules/core-js-pure/full/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_get_iterator_method4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/get-iterator-method.js
var require_get_iterator_method6 = __commonJS({
  "node_modules/core-js-pure/features/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_get_iterator_method5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/get-iterator-method.js
var require_get_iterator_method7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/get-iterator-method.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_get_iterator_method6();
  }
});

// node_modules/core-js-pure/modules/es.array.is-array.js
var require_es_array_is_array = __commonJS({
  "node_modules/core-js-pure/modules/es.array.is-array.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var isArray3 = require_is_array();
    $({ target: "Array", stat: true }, {
      isArray: isArray3
    });
  }
});

// node_modules/core-js-pure/es/array/is-array.js
var require_is_array2 = __commonJS({
  "node_modules/core-js-pure/es/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_is_array();
    var path = require_path();
    module.exports = path.Array.isArray;
  }
});

// node_modules/core-js-pure/stable/array/is-array.js
var require_is_array3 = __commonJS({
  "node_modules/core-js-pure/stable/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_is_array2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/array/is-array.js
var require_is_array4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_is_array3();
  }
});

// node_modules/core-js-pure/actual/array/is-array.js
var require_is_array5 = __commonJS({
  "node_modules/core-js-pure/actual/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_is_array3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/array/is-array.js
var require_is_array6 = __commonJS({
  "node_modules/core-js-pure/full/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_is_array5();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/array/is-array.js
var require_is_array7 = __commonJS({
  "node_modules/core-js-pure/features/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_is_array6();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/array/is-array.js
var require_is_array8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/array/is-array.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_is_array7();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/arrayWithHoles.js
var require_arrayWithHoles = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/arrayWithHoles.js"(exports, module) {
    init_process();
    init_buffer();
    var _Array$isArray = require_is_array8();
    function _arrayWithHoles(arr) {
      if (_Array$isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.dispose.js
var require_esnext_symbol_dispose = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.dispose.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("dispose");
  }
});

// node_modules/core-js-pure/actual/symbol/index.js
var require_symbol4 = __commonJS({
  "node_modules/core-js-pure/actual/symbol/index.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_symbol2();
    require_esnext_symbol_dispose();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js
var require_esnext_symbol_async_dispose = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("asyncDispose");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.matcher.js
var require_esnext_symbol_matcher = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.matcher.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("matcher");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js
var require_esnext_symbol_metadata_key = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("metadataKey");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.observable.js
var require_esnext_symbol_observable = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.observable.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("observable");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.metadata.js
var require_esnext_symbol_metadata = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.metadata.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("metadata");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js
var require_esnext_symbol_pattern_match = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("patternMatch");
  }
});

// node_modules/core-js-pure/modules/esnext.symbol.replace-all.js
var require_esnext_symbol_replace_all = __commonJS({
  "node_modules/core-js-pure/modules/esnext.symbol.replace-all.js"() {
    init_process();
    init_buffer();
    var defineWellKnownSymbol = require_well_known_symbol_define();
    defineWellKnownSymbol("replaceAll");
  }
});

// node_modules/core-js-pure/full/symbol/index.js
var require_symbol5 = __commonJS({
  "node_modules/core-js-pure/full/symbol/index.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_symbol4();
    require_esnext_symbol_async_dispose();
    require_esnext_symbol_matcher();
    require_esnext_symbol_metadata_key();
    require_esnext_symbol_observable();
    require_esnext_symbol_metadata();
    require_esnext_symbol_pattern_match();
    require_esnext_symbol_replace_all();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/symbol/index.js
var require_symbol6 = __commonJS({
  "node_modules/core-js-pure/features/symbol/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_symbol5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/symbol.js
var require_symbol7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/symbol.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_symbol6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/iterableToArrayLimit.js
var require_iterableToArrayLimit = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/iterableToArrayLimit.js"(exports, module) {
    init_process();
    init_buffer();
    var _Symbol = require_symbol7();
    var _getIteratorMethod = require_get_iterator_method7();
    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof _Symbol && _getIteratorMethod(arr) || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/actual/instance/slice.js
var require_slice5 = __commonJS({
  "node_modules/core-js-pure/actual/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_slice3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/slice.js
var require_slice6 = __commonJS({
  "node_modules/core-js-pure/full/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_slice5();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/slice.js
var require_slice7 = __commonJS({
  "node_modules/core-js-pure/features/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_slice6();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/instance/slice.js
var require_slice8 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/instance/slice.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_slice7();
  }
});

// node_modules/core-js-pure/actual/array/from.js
var require_from4 = __commonJS({
  "node_modules/core-js-pure/actual/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_from2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/array/from.js
var require_from5 = __commonJS({
  "node_modules/core-js-pure/full/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_from4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/array/from.js
var require_from6 = __commonJS({
  "node_modules/core-js-pure/features/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_from5();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/array/from.js
var require_from7 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/array/from.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_from6();
  }
});

// node_modules/@babel/runtime-corejs3/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/arrayLikeToArray.js"(exports, module) {
    init_process();
    init_buffer();
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/unsupportedIterableToArray.js"(exports, module) {
    init_process();
    init_buffer();
    var _sliceInstanceProperty = require_slice8();
    var _Array$from = require_from7();
    var arrayLikeToArray = require_arrayLikeToArray();
    function _unsupportedIterableToArray(o, minLen) {
      var _context;
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray(o, minLen);
      var n = _sliceInstanceProperty(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return _Array$from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray(o, minLen);
    }
    module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/nonIterableRest.js
var require_nonIterableRest = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/nonIterableRest.js"(exports, module) {
    init_process();
    init_buffer();
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime-corejs3/helpers/slicedToArray.js
var require_slicedToArray = __commonJS({
  "node_modules/@babel/runtime-corejs3/helpers/slicedToArray.js"(exports, module) {
    init_process();
    init_buffer();
    var arrayWithHoles = require_arrayWithHoles();
    var iterableToArrayLimit = require_iterableToArrayLimit();
    var unsupportedIterableToArray = require_unsupportedIterableToArray();
    var nonIterableRest = require_nonIterableRest();
    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/core-js-pure/modules/es.regexp.flags.js
var require_es_regexp_flags = __commonJS({
  "node_modules/core-js-pure/modules/es.regexp.flags.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/core-js-pure/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "node_modules/core-js-pure/internals/regexp-flags.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "node_modules/core-js-pure/internals/regexp-get-flags.js"(exports, module) {
    init_process();
    init_buffer();
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(R) {
      var flags = R.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
    };
  }
});

// node_modules/core-js-pure/es/regexp/flags.js
var require_flags = __commonJS({
  "node_modules/core-js-pure/es/regexp/flags.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_regexp_flags();
    var getRegExpFlags = require_regexp_get_flags();
    module.exports = getRegExpFlags;
  }
});

// node_modules/core-js-pure/es/instance/flags.js
var require_flags2 = __commonJS({
  "node_modules/core-js-pure/es/instance/flags.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var flags = require_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(it) {
      return it === RegExpPrototype || isPrototypeOf(RegExpPrototype, it) ? flags(it) : it.flags;
    };
  }
});

// node_modules/core-js-pure/stable/instance/flags.js
var require_flags3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/flags.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_flags2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/flags.js
var require_flags4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/flags.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_flags3();
  }
});

// node_modules/core-js-pure/internals/delete-property-or-throw.js
var require_delete_property_or_throw = __commonJS({
  "node_modules/core-js-pure/internals/delete-property-or-throw.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(O, P) {
      if (!delete O[P])
        throw $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
    };
  }
});

// node_modules/core-js-pure/internals/array-sort.js
var require_array_sort = __commonJS({
  "node_modules/core-js-pure/internals/array-sort.js"(exports, module) {
    init_process();
    init_buffer();
    var arraySlice = require_array_slice_simple();
    var floor = Math.floor;
    var mergeSort = function(array, comparefn) {
      var length = array.length;
      var middle = floor(length / 2);
      return length < 8 ? insertionSort(array, comparefn) : merge(
        array,
        mergeSort(arraySlice(array, 0, middle), comparefn),
        mergeSort(arraySlice(array, middle), comparefn),
        comparefn
      );
    };
    var insertionSort = function(array, comparefn) {
      var length = array.length;
      var i = 1;
      var element, j;
      while (i < length) {
        j = i;
        element = array[i];
        while (j && comparefn(array[j - 1], element) > 0) {
          array[j] = array[--j];
        }
        if (j !== i++)
          array[j] = element;
      }
      return array;
    };
    var merge = function(array, left, right, comparefn) {
      var llength = left.length;
      var rlength = right.length;
      var lindex = 0;
      var rindex = 0;
      while (lindex < llength || rindex < rlength) {
        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
      }
      return array;
    };
    module.exports = mergeSort;
  }
});

// node_modules/core-js-pure/internals/array-method-is-strict.js
var require_array_method_is_strict = __commonJS({
  "node_modules/core-js-pure/internals/array-method-is-strict.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var fails = require_fails();
    module.exports = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
  }
});

// node_modules/core-js-pure/internals/engine-ff-version.js
var require_engine_ff_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-ff-version.js"(exports, module) {
    init_process();
    init_buffer();
    var userAgent = require_engine_user_agent();
    var firefox = userAgent.match(/firefox\/(\d+)/i);
    module.exports = !!firefox && +firefox[1];
  }
});

// node_modules/core-js-pure/internals/engine-is-ie-or-edge.js
var require_engine_is_ie_or_edge = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-ie-or-edge.js"(exports, module) {
    init_process();
    init_buffer();
    var UA = require_engine_user_agent();
    module.exports = /MSIE|Trident/.test(UA);
  }
});

// node_modules/core-js-pure/internals/engine-webkit-version.js
var require_engine_webkit_version = __commonJS({
  "node_modules/core-js-pure/internals/engine-webkit-version.js"(exports, module) {
    init_process();
    init_buffer();
    var userAgent = require_engine_user_agent();
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    module.exports = !!webkit && +webkit[1];
  }
});

// node_modules/core-js-pure/modules/es.array.sort.js
var require_es_array_sort = __commonJS({
  "node_modules/core-js-pure/modules/es.array.sort.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var deletePropertyOrThrow = require_delete_property_or_throw();
    var toString3 = require_to_string();
    var fails = require_fails();
    var internalSort = require_array_sort();
    var arrayMethodIsStrict = require_array_method_is_strict();
    var FF = require_engine_ff_version();
    var IE_OR_EDGE = require_engine_is_ie_or_edge();
    var V8 = require_engine_v8_version();
    var WEBKIT = require_engine_webkit_version();
    var test = [];
    var nativeSort = uncurryThis(test.sort);
    var push = uncurryThis(test.push);
    var FAILS_ON_UNDEFINED = fails(function() {
      test.sort(void 0);
    });
    var FAILS_ON_NULL = fails(function() {
      test.sort(null);
    });
    var STRICT_METHOD = arrayMethodIsStrict("sort");
    var STABLE_SORT = !fails(function() {
      if (V8)
        return V8 < 70;
      if (FF && FF > 3)
        return;
      if (IE_OR_EDGE)
        return true;
      if (WEBKIT)
        return WEBKIT < 603;
      var result = "";
      var code, chr, value, index;
      for (code = 65; code < 76; code++) {
        chr = String.fromCharCode(code);
        switch (code) {
          case 66:
          case 69:
          case 70:
          case 72:
            value = 3;
            break;
          case 68:
          case 71:
            value = 4;
            break;
          default:
            value = 2;
        }
        for (index = 0; index < 47; index++) {
          test.push({ k: chr + index, v: value });
        }
      }
      test.sort(function(a, b) {
        return b.v - a.v;
      });
      for (index = 0; index < test.length; index++) {
        chr = test[index].k.charAt(0);
        if (result.charAt(result.length - 1) !== chr)
          result += chr;
      }
      return result !== "DGBEFHACIJK";
    });
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
    var getSortCompare = function(comparefn) {
      return function(x, y) {
        if (y === void 0)
          return -1;
        if (x === void 0)
          return 1;
        if (comparefn !== void 0)
          return +comparefn(x, y) || 0;
        return toString3(x) > toString3(y) ? 1 : -1;
      };
    };
    $({ target: "Array", proto: true, forced: FORCED }, {
      sort: function sort(comparefn) {
        if (comparefn !== void 0)
          aCallable(comparefn);
        var array = toObject(this);
        if (STABLE_SORT)
          return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
        var items = [];
        var arrayLength = lengthOfArrayLike(array);
        var itemsLength, index;
        for (index = 0; index < arrayLength; index++) {
          if (index in array)
            push(items, array[index]);
        }
        internalSort(items, getSortCompare(comparefn));
        itemsLength = lengthOfArrayLike(items);
        index = 0;
        while (index < itemsLength)
          array[index] = items[index++];
        while (index < arrayLength)
          deletePropertyOrThrow(array, index++);
        return array;
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/sort.js
var require_sort = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/sort.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_sort();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").sort;
  }
});

// node_modules/core-js-pure/es/instance/sort.js
var require_sort2 = __commonJS({
  "node_modules/core-js-pure/es/instance/sort.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_sort();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.sort;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.sort ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/sort.js
var require_sort3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/sort.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_sort2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/sort.js
var require_sort4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/sort.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_sort3();
  }
});

// node_modules/core-js-pure/internals/whitespaces.js
var require_whitespaces = __commonJS({
  "node_modules/core-js-pure/internals/whitespaces.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = "	\n\v\f\r                　\u2028\u2029\uFEFF";
  }
});

// node_modules/core-js-pure/internals/string-trim.js
var require_string_trim = __commonJS({
  "node_modules/core-js-pure/internals/string-trim.js"(exports, module) {
    init_process();
    init_buffer();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var toString3 = require_to_string();
    var whitespaces = require_whitespaces();
    var replace = uncurryThis("".replace);
    var whitespace = "[" + whitespaces + "]";
    var ltrim = RegExp("^" + whitespace + whitespace + "*");
    var rtrim = RegExp(whitespace + whitespace + "*$");
    var createMethod = function(TYPE) {
      return function($this) {
        var string = toString3(requireObjectCoercible($this));
        if (TYPE & 1)
          string = replace(string, ltrim, "");
        if (TYPE & 2)
          string = replace(string, rtrim, "");
        return string;
      };
    };
    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.es/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.es/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
  }
});

// node_modules/core-js-pure/internals/number-parse-int.js
var require_number_parse_int = __commonJS({
  "node_modules/core-js-pure/internals/number-parse-int.js"(exports, module) {
    init_process();
    init_buffer();
    var global2 = require_global();
    var fails = require_fails();
    var uncurryThis = require_function_uncurry_this();
    var toString3 = require_to_string();
    var trim = require_string_trim().trim;
    var whitespaces = require_whitespaces();
    var $parseInt = global2.parseInt;
    var Symbol2 = global2.Symbol;
    var ITERATOR = Symbol2 && Symbol2.iterator;
    var hex = /^[+-]?0x/i;
    var exec = uncurryThis(hex.exec);
    var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
      $parseInt(Object(ITERATOR));
    });
    module.exports = FORCED ? function parseInt2(string, radix) {
      var S = trim(toString3(string));
      return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
    } : $parseInt;
  }
});

// node_modules/core-js-pure/modules/es.parse-int.js
var require_es_parse_int = __commonJS({
  "node_modules/core-js-pure/modules/es.parse-int.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var $parseInt = require_number_parse_int();
    $({ global: true, forced: parseInt != $parseInt }, {
      parseInt: $parseInt
    });
  }
});

// node_modules/core-js-pure/es/parse-int.js
var require_parse_int = __commonJS({
  "node_modules/core-js-pure/es/parse-int.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_parse_int();
    var path = require_path();
    module.exports = path.parseInt;
  }
});

// node_modules/core-js-pure/stable/parse-int.js
var require_parse_int2 = __commonJS({
  "node_modules/core-js-pure/stable/parse-int.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_parse_int();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js
var require_parse_int3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/parse-int.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_parse_int2();
  }
});

// node_modules/core-js-pure/modules/es.array.index-of.js
var require_es_array_index_of = __commonJS({
  "node_modules/core-js-pure/modules/es.array.index-of.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this_clause();
    var $indexOf = require_array_includes().indexOf;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var nativeIndexOf = uncurryThis([].indexOf);
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
    var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
    $({ target: "Array", proto: true, forced: FORCED }, {
      indexOf: function indexOf3(searchElement) {
        var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
        return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/index-of.js
var require_index_of = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/index-of.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_index_of();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").indexOf;
  }
});

// node_modules/core-js-pure/es/instance/index-of.js
var require_index_of2 = __commonJS({
  "node_modules/core-js-pure/es/instance/index-of.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_index_of();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.indexOf;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.indexOf ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/index-of.js
var require_index_of3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/index-of.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_index_of2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js
var require_index_of4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/index-of.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_index_of3();
  }
});

// node_modules/core-js-pure/internals/array-for-each.js
var require_array_for_each = __commonJS({
  "node_modules/core-js-pure/internals/array-for-each.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var $forEach = require_array_iteration().forEach;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var STRICT_METHOD = arrayMethodIsStrict("forEach");
    module.exports = !STRICT_METHOD ? function forEach2(callbackfn) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    } : [].forEach;
  }
});

// node_modules/core-js-pure/modules/es.array.for-each.js
var require_es_array_for_each = __commonJS({
  "node_modules/core-js-pure/modules/es.array.for-each.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var forEach2 = require_array_for_each();
    $({ target: "Array", proto: true, forced: [].forEach != forEach2 }, {
      forEach: forEach2
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/for-each.js
var require_for_each = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/for-each.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_for_each();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").forEach;
  }
});

// node_modules/core-js-pure/stable/array/virtual/for-each.js
var require_for_each2 = __commonJS({
  "node_modules/core-js-pure/stable/array/virtual/for-each.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_for_each();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/stable/instance/for-each.js
var require_for_each3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/for-each.js"(exports, module) {
    init_process();
    init_buffer();
    require_web_dom_collections_iterator();
    var classof = require_classof();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_for_each2();
    var ArrayPrototype = Array.prototype;
    var DOMIterables = {
      DOMTokenList: true,
      NodeList: true
    };
    module.exports = function(it) {
      var own = it.forEach;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.forEach || hasOwn(DOMIterables, classof(it)) ? method : own;
    };
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js
var require_for_each4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_for_each3();
  }
});

// node_modules/core-js-pure/modules/es.object.create.js
var require_es_object_create = __commonJS({
  "node_modules/core-js-pure/modules/es.object.create.js"() {
    init_process();
    init_buffer();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var create = require_object_create();
    $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
      create
    });
  }
});

// node_modules/core-js-pure/es/object/create.js
var require_create = __commonJS({
  "node_modules/core-js-pure/es/object/create.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_object_create();
    var path = require_path();
    var Object2 = path.Object;
    module.exports = function create(P, D) {
      return Object2.create(P, D);
    };
  }
});

// node_modules/core-js-pure/stable/object/create.js
var require_create2 = __commonJS({
  "node_modules/core-js-pure/stable/object/create.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_create();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/object/create.js
var require_create3 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/object/create.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_create2();
  }
});

// node_modules/core-js-pure/es/array/virtual/concat.js
var require_concat = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/concat.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_concat();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").concat;
  }
});

// node_modules/core-js-pure/es/instance/concat.js
var require_concat2 = __commonJS({
  "node_modules/core-js-pure/es/instance/concat.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_concat();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.concat;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.concat ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/concat.js
var require_concat3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/concat.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_concat2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/concat.js
var require_concat4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/concat.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_concat3();
  }
});

// node_modules/xregexp/lib/xregexp.js
var require_xregexp = __commonJS({
  "node_modules/xregexp/lib/xregexp.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _sliceInstanceProperty2 = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol3();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray = require_is_array4();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _flags = _interopRequireDefault(require_flags4());
    var _sort = _interopRequireDefault(require_sort4());
    var _slice = _interopRequireDefault(require_slice4());
    var _parseInt2 = _interopRequireDefault(require_parse_int3());
    var _indexOf = _interopRequireDefault(require_index_of4());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _create = _interopRequireDefault(require_create3());
    var _concat = _interopRequireDefault(require_concat4());
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
      if (!it) {
        if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      var _context9;
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = _sliceInstanceProperty2(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return _Array$from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var REGEX_DATA = "xregexp";
    var features = {
      astral: false,
      namespacing: true
    };
    var fixed = {};
    var regexCache = {};
    var patternCache = {};
    var tokens = [];
    var defaultScope = "default";
    var classScope = "class";
    var nativeTokens = {
      // Any native multicharacter token in default scope, or any single character
      "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
      // Any native multicharacter token in character class scope, or any single character
      "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
    };
    var replacementToken = /\$(?:\{([^\}]+)\}|<([^>]+)>|(\d\d?|[\s\S]?))/g;
    var correctExecNpcg = /()??/.exec("")[1] === void 0;
    var hasFlagsProp = (0, _flags["default"])(/x/) !== void 0;
    function hasNativeFlag(flag) {
      var isSupported = true;
      try {
        new RegExp("", flag);
        if (flag === "y") {
          var gy = function() {
            return "gy";
          }();
          var incompleteY = ".a".replace(new RegExp("a", gy), ".") === "..";
          if (incompleteY) {
            isSupported = false;
          }
        }
      } catch (exception) {
        isSupported = false;
      }
      return isSupported;
    }
    var hasNativeD = hasNativeFlag("d");
    var hasNativeS = hasNativeFlag("s");
    var hasNativeU = hasNativeFlag("u");
    var hasNativeY = hasNativeFlag("y");
    var registeredFlags = {
      d: hasNativeD,
      g: true,
      i: true,
      m: true,
      s: hasNativeS,
      u: hasNativeU,
      y: hasNativeY
    };
    var nonnativeFlags = hasNativeS ? /[^dgimsuy]+/g : /[^dgimuy]+/g;
    function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
      var _context;
      regex[REGEX_DATA] = {
        captureNames
      };
      if (isInternalOnly) {
        return regex;
      }
      if (regex.__proto__) {
        regex.__proto__ = XRegExp.prototype;
      } else {
        for (var p in XRegExp.prototype) {
          regex[p] = XRegExp.prototype[p];
        }
      }
      regex[REGEX_DATA].source = xSource;
      regex[REGEX_DATA].flags = xFlags ? (0, _sort["default"])(_context = xFlags.split("")).call(_context).join("") : xFlags;
      return regex;
    }
    function clipDuplicates(str) {
      return str.replace(/([\s\S])(?=[\s\S]*\1)/g, "");
    }
    function copyRegex(regex, options) {
      var _context2;
      if (!XRegExp.isRegExp(regex)) {
        throw new TypeError("Type RegExp expected");
      }
      var xData = regex[REGEX_DATA] || {};
      var flags = getNativeFlags(regex);
      var flagsToAdd = "";
      var flagsToRemove = "";
      var xregexpSource = null;
      var xregexpFlags = null;
      options = options || {};
      if (options.removeG) {
        flagsToRemove += "g";
      }
      if (options.removeY) {
        flagsToRemove += "y";
      }
      if (flagsToRemove) {
        flags = flags.replace(new RegExp("[".concat(flagsToRemove, "]+"), "g"), "");
      }
      if (options.addG) {
        flagsToAdd += "g";
      }
      if (options.addY) {
        flagsToAdd += "y";
      }
      if (flagsToAdd) {
        flags = clipDuplicates(flags + flagsToAdd);
      }
      if (!options.isInternalOnly) {
        if (xData.source !== void 0) {
          xregexpSource = xData.source;
        }
        if ((0, _flags["default"])(xData) != null) {
          xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags["default"])(xData) + flagsToAdd) : (0, _flags["default"])(xData);
        }
      }
      regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice["default"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
      return regex;
    }
    function dec(hex2) {
      return (0, _parseInt2["default"])(hex2, 16);
    }
    function getContextualTokenSeparator(match, scope, flags) {
      var matchEndPos = match.index + match[0].length;
      var precedingChar = match.input[match.index - 1];
      var followingChar = match.input[matchEndPos];
      if (
        // No need to separate tokens if at the beginning or end of a group, before or after a
        // group, or before or after a `|`
        /^[()|]$/.test(precedingChar) || /^[()|]$/.test(followingChar) || // No need to separate tokens if at the beginning or end of the pattern
        match.index === 0 || matchEndPos === match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookaround.
        // Looks only at the last 4 chars (at most) for perf when constructing long regexes.
        /\(\?(?:[:=!]|<[=!])$/.test(match.input.substring(match.index - 4, match.index)) || // Avoid separating tokens when the following token is a quantifier
        isQuantifierNext(match.input, matchEndPos, flags)
      ) {
        return "";
      }
      return "(?:)";
    }
    function getNativeFlags(regex) {
      return hasFlagsProp ? (0, _flags["default"])(regex) : (
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overridden
        /\/([a-z]*)$/i.exec(RegExp.prototype.toString.call(regex))[1]
      );
    }
    function hasNamedCapture(regex) {
      return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
    }
    function hex(dec2) {
      return (0, _parseInt2["default"])(dec2, 10).toString(16);
    }
    function isQuantifierNext(pattern, pos, flags) {
      var inlineCommentPattern = "\\(\\?#[^)]*\\)";
      var lineCommentPattern = "#[^#\\n]*";
      var quantifierPattern = "[?*+]|{\\d+(?:,\\d*)?}";
      var regex = (0, _indexOf["default"])(flags).call(flags, "x") !== -1 ? (
        // Ignore any leading whitespace, line comments, and inline comments
        /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      ) : (
        // Ignore any leading inline comments
        /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      );
      return regex.test((0, _slice["default"])(pattern).call(pattern, pos));
    }
    function isType2(value, type) {
      return Object.prototype.toString.call(value) === "[object ".concat(type, "]");
    }
    function nullThrows(value) {
      if (value == null) {
        throw new TypeError("Cannot convert null or undefined to object");
      }
      return value;
    }
    function pad4(str) {
      while (str.length < 4) {
        str = "0".concat(str);
      }
      return str;
    }
    function prepareFlags(pattern, flags) {
      if (clipDuplicates(flags) !== flags) {
        throw new SyntaxError("Invalid duplicate regex flag ".concat(flags));
      }
      pattern = pattern.replace(/^\(\?([\w$]+)\)/, function($0, $1) {
        if (/[dgy]/.test($1)) {
          throw new SyntaxError("Cannot use flags dgy in mode modifier ".concat($0));
        }
        flags = clipDuplicates(flags + $1);
        return "";
      });
      var _iterator = _createForOfIteratorHelper(flags), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var flag = _step.value;
          if (!registeredFlags[flag]) {
            throw new SyntaxError("Unknown regex flag ".concat(flag));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        pattern,
        flags
      };
    }
    function prepareOptions(value) {
      var options = {};
      if (isType2(value, "String")) {
        (0, _forEach["default"])(XRegExp).call(XRegExp, value, /[^\s,]+/, function(match) {
          options[match] = true;
        });
        return options;
      }
      return value;
    }
    function registerFlag(flag) {
      if (!/^[\w$]$/.test(flag)) {
        throw new Error("Flag must be a single character A-Za-z0-9_$");
      }
      registeredFlags[flag] = true;
    }
    function runTokens(pattern, flags, pos, scope, context) {
      var i = tokens.length;
      var leadChar = pattern[pos];
      var result = null;
      var match;
      var t;
      while (i--) {
        t = tokens[i];
        if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && !((0, _indexOf["default"])(flags).call(flags, t.flag) !== -1)) {
          continue;
        }
        match = XRegExp.exec(pattern, t.regex, pos, "sticky");
        if (match) {
          result = {
            matchLength: match[0].length,
            output: t.handler.call(context, match, scope, flags),
            reparse: t.reparse
          };
          break;
        }
      }
      return result;
    }
    function setAstral(on2) {
      features.astral = on2;
    }
    function setNamespacing(on2) {
      features.namespacing = on2;
    }
    function XRegExp(pattern, flags) {
      if (XRegExp.isRegExp(pattern)) {
        if (flags !== void 0) {
          throw new TypeError("Cannot supply flags when copying a RegExp");
        }
        return copyRegex(pattern);
      }
      pattern = pattern === void 0 ? "" : String(pattern);
      flags = flags === void 0 ? "" : String(flags);
      if (XRegExp.isInstalled("astral") && !((0, _indexOf["default"])(flags).call(flags, "A") !== -1)) {
        flags += "A";
      }
      if (!patternCache[pattern]) {
        patternCache[pattern] = {};
      }
      if (!patternCache[pattern][flags]) {
        var context = {
          hasNamedCapture: false,
          captureNames: []
        };
        var scope = defaultScope;
        var output = "";
        var pos = 0;
        var result;
        var applied = prepareFlags(pattern, flags);
        var appliedPattern = applied.pattern;
        var appliedFlags = (0, _flags["default"])(applied);
        while (pos < appliedPattern.length) {
          do {
            result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
            if (result && result.reparse) {
              appliedPattern = (0, _slice["default"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice["default"])(appliedPattern).call(appliedPattern, pos + result.matchLength);
            }
          } while (result && result.reparse);
          if (result) {
            output += result.output;
            pos += result.matchLength || 1;
          } else {
            var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky"), _XRegExp$exec2 = (0, _slicedToArray2["default"])(_XRegExp$exec, 1), token = _XRegExp$exec2[0];
            output += token;
            pos += token.length;
            if (token === "[" && scope === defaultScope) {
              scope = classScope;
            } else if (token === "]" && scope === classScope) {
              scope = defaultScope;
            }
          }
        }
        patternCache[pattern][flags] = {
          // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
          // groups are sometimes inserted during regex transpilation in order to keep tokens
          // separated. However, more than one empty group in a row is never needed.
          pattern: output.replace(/(?:\(\?:\))+/g, "(?:)"),
          // Strip all but native flags
          flags: appliedFlags.replace(nonnativeFlags, ""),
          // `context.captureNames` has an item for each capturing group, even if unnamed
          captures: context.hasNamedCapture ? context.captureNames : null
        };
      }
      var generated = patternCache[pattern][flags];
      return augment(new RegExp(generated.pattern, (0, _flags["default"])(generated)), generated.captures, pattern, flags);
    }
    XRegExp.prototype = /(?:)/;
    XRegExp.version = "5.1.1";
    XRegExp._clipDuplicates = clipDuplicates;
    XRegExp._hasNativeFlag = hasNativeFlag;
    XRegExp._dec = dec;
    XRegExp._hex = hex;
    XRegExp._pad4 = pad4;
    XRegExp.addToken = function(regex, handler, options) {
      options = options || {};
      var _options = options, optionalFlags = _options.optionalFlags;
      if (options.flag) {
        registerFlag(options.flag);
      }
      if (optionalFlags) {
        optionalFlags = optionalFlags.split("");
        var _iterator2 = _createForOfIteratorHelper(optionalFlags), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var flag = _step2.value;
            registerFlag(flag);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      tokens.push({
        regex: copyRegex(regex, {
          addG: true,
          addY: hasNativeY,
          isInternalOnly: true
        }),
        handler,
        scope: options.scope || defaultScope,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
      });
      XRegExp.cache.flush("patterns");
    };
    XRegExp.cache = function(pattern, flags) {
      if (!regexCache[pattern]) {
        regexCache[pattern] = {};
      }
      return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
    };
    XRegExp.cache.flush = function(cacheName) {
      if (cacheName === "patterns") {
        patternCache = {};
      } else {
        regexCache = {};
      }
    };
    XRegExp.escape = function(str) {
      return String(nullThrows(str)).replace(/[\\\[\]{}()*+?.^$|]/g, "\\$&").replace(/[\s#\-,]/g, function(match) {
        return "\\u".concat(pad4(hex(match.charCodeAt(0))));
      });
    };
    XRegExp.exec = function(str, regex, pos, sticky) {
      var cacheKey = "g";
      var addY = false;
      var fakeY = false;
      var match;
      addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
      if (addY) {
        cacheKey += "y";
      } else if (sticky) {
        fakeY = true;
        cacheKey += "FakeY";
      }
      regex[REGEX_DATA] = regex[REGEX_DATA] || {};
      var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: true,
        addY,
        source: fakeY ? "".concat(regex.source, "|()") : void 0,
        removeY: sticky === false,
        isInternalOnly: true
      }));
      pos = pos || 0;
      r2.lastIndex = pos;
      match = fixed.exec.call(r2, str);
      if (fakeY && match && match.pop() === "") {
        match = null;
      }
      if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
      }
      return match;
    };
    XRegExp.forEach = function(str, regex, callback) {
      var pos = 0;
      var i = -1;
      var match;
      while (match = XRegExp.exec(str, regex, pos)) {
        callback(match, ++i, str, regex);
        pos = match.index + (match[0].length || 1);
      }
    };
    XRegExp.globalize = function(regex) {
      return copyRegex(regex, {
        addG: true
      });
    };
    XRegExp.install = function(options) {
      options = prepareOptions(options);
      if (!features.astral && options.astral) {
        setAstral(true);
      }
      if (!features.namespacing && options.namespacing) {
        setNamespacing(true);
      }
    };
    XRegExp.isInstalled = function(feature) {
      return !!features[feature];
    };
    XRegExp.isRegExp = function(value) {
      return Object.prototype.toString.call(value) === "[object RegExp]";
    };
    XRegExp.match = function(str, regex, scope) {
      var global2 = regex.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (regex.sticky ? "y" : "") || "noGY";
      regex[REGEX_DATA] = regex[REGEX_DATA] || {};
      var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
        addG: !!global2,
        removeG: scope === "one",
        isInternalOnly: true
      }));
      var result = String(nullThrows(str)).match(r2);
      if (regex.global) {
        regex.lastIndex = scope === "one" && result ? (
          // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
          result.index + result[0].length
        ) : 0;
      }
      return global2 ? result || [] : result && result[0];
    };
    XRegExp.matchChain = function(str, chain) {
      return function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {
          regex: chain[level]
        };
        var matches = [];
        function addMatch(match) {
          if (item.backref) {
            var ERR_UNDEFINED_GROUP = "Backreference to undefined group: ".concat(item.backref);
            var isNamedBackref = isNaN(item.backref);
            if (isNamedBackref && XRegExp.isInstalled("namespacing")) {
              if (!(match.groups && item.backref in match.groups)) {
                throw new ReferenceError(ERR_UNDEFINED_GROUP);
              }
            } else if (!match.hasOwnProperty(item.backref)) {
              throw new ReferenceError(ERR_UNDEFINED_GROUP);
            }
            var backrefValue = isNamedBackref && XRegExp.isInstalled("namespacing") ? match.groups[item.backref] : match[item.backref];
            matches.push(backrefValue || "");
          } else {
            matches.push(match[0]);
          }
        }
        var _iterator3 = _createForOfIteratorHelper(values), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var value = _step3.value;
            (0, _forEach["default"])(XRegExp).call(XRegExp, value, item.regex, addMatch);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
      }([str], 0);
    };
    XRegExp.replace = function(str, search, replacement, scope) {
      var isRegex = XRegExp.isRegExp(search);
      var global2 = search.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (search.sticky ? "y" : "") || "noGY";
      var s2 = search;
      if (isRegex) {
        search[REGEX_DATA] = search[REGEX_DATA] || {};
        s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
          addG: !!global2,
          removeG: scope === "one",
          isInternalOnly: true
        }));
      } else if (global2) {
        s2 = new RegExp(XRegExp.escape(String(search)), "g");
      }
      var result = fixed.replace.call(nullThrows(str), s2, replacement);
      if (isRegex && search.global) {
        search.lastIndex = 0;
      }
      return result;
    };
    XRegExp.replaceEach = function(str, replacements) {
      var _iterator4 = _createForOfIteratorHelper(replacements), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var r = _step4.value;
          str = XRegExp.replace(str, r[0], r[1], r[2]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return str;
    };
    XRegExp.split = function(str, separator, limit) {
      return fixed.split.call(nullThrows(str), separator, limit);
    };
    XRegExp.test = function(str, regex, pos, sticky) {
      return !!XRegExp.exec(str, regex, pos, sticky);
    };
    XRegExp.uninstall = function(options) {
      options = prepareOptions(options);
      if (features.astral && options.astral) {
        setAstral(false);
      }
      if (features.namespacing && options.namespacing) {
        setNamespacing(false);
      }
    };
    XRegExp.union = function(patterns, flags, options) {
      options = options || {};
      var conjunction = options.conjunction || "or";
      var numCaptures = 0;
      var numPriorCaptures;
      var captureNames;
      function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];
        if (paren) {
          ++numCaptures;
          if (name) {
            return "(?<".concat(name, ">");
          }
        } else if (backref) {
          return "\\".concat(+backref + numPriorCaptures);
        }
        return match;
      }
      if (!(isType2(patterns, "Array") && patterns.length)) {
        throw new TypeError("Must provide a nonempty array of patterns to merge");
      }
      var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var output = [];
      var _iterator5 = _createForOfIteratorHelper(patterns), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var pattern = _step5.value;
          if (XRegExp.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];
            output.push(XRegExp(pattern.source).source.replace(parts, rewrite));
          } else {
            output.push(XRegExp.escape(pattern));
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      var separator = conjunction === "none" ? "" : "|";
      return XRegExp(output.join(separator), flags);
    };
    fixed.exec = function(str) {
      var origLastIndex = this.lastIndex;
      var match = RegExp.prototype.exec.apply(this, arguments);
      if (match) {
        if (!correctExecNpcg && match.length > 1 && (0, _indexOf["default"])(match).call(match, "") !== -1) {
          var _context3;
          var r2 = copyRegex(this, {
            removeG: true,
            isInternalOnly: true
          });
          (0, _slice["default"])(_context3 = String(str)).call(_context3, match.index).replace(r2, function() {
            var len = arguments.length;
            for (var i2 = 1; i2 < len - 2; ++i2) {
              if ((i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]) === void 0) {
                match[i2] = void 0;
              }
            }
          });
        }
        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
          var groupsObject = match;
          if (XRegExp.isInstalled("namespacing")) {
            match.groups = (0, _create["default"])(null);
            groupsObject = match.groups;
          }
          for (var i = 1; i < match.length; ++i) {
            var name = this[REGEX_DATA].captureNames[i - 1];
            if (name) {
              groupsObject[name] = match[i];
            }
          }
        } else if (!match.groups && XRegExp.isInstalled("namespacing")) {
          match.groups = void 0;
        }
        if (this.global && !match[0].length && this.lastIndex > match.index) {
          this.lastIndex = match.index;
        }
      }
      if (!this.global) {
        this.lastIndex = origLastIndex;
      }
      return match;
    };
    fixed.test = function(str) {
      return !!fixed.exec.call(this, str);
    };
    fixed.match = function(regex) {
      if (!XRegExp.isRegExp(regex)) {
        regex = new RegExp(regex);
      } else if (regex.global) {
        var result = String.prototype.match.apply(this, arguments);
        regex.lastIndex = 0;
        return result;
      }
      return fixed.exec.call(regex, nullThrows(this));
    };
    fixed.replace = function(search, replacement) {
      var isRegex = XRegExp.isRegExp(search);
      var origLastIndex;
      var captureNames;
      var result;
      if (isRegex) {
        if (search[REGEX_DATA]) {
          captureNames = search[REGEX_DATA].captureNames;
        }
        origLastIndex = search.lastIndex;
      } else {
        search += "";
      }
      if (isType2(replacement, "Function")) {
        result = String(this).replace(search, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (captureNames) {
            var groupsObject;
            if (XRegExp.isInstalled("namespacing")) {
              groupsObject = (0, _create["default"])(null);
              args.push(groupsObject);
            } else {
              args[0] = new String(args[0]);
              groupsObject = args[0];
            }
            for (var i = 0; i < captureNames.length; ++i) {
              if (captureNames[i]) {
                groupsObject[captureNames[i]] = args[i + 1];
              }
            }
          }
          return replacement.apply(void 0, args);
        });
      } else {
        result = String(nullThrows(this)).replace(search, function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return String(replacement).replace(replacementToken, replacer);
          function replacer($0, bracketed, angled, dollarToken) {
            bracketed = bracketed || angled;
            var numNonCaptureArgs = isType2(args[args.length - 1], "Object") ? 4 : 3;
            var numCaptures = args.length - numNonCaptureArgs;
            if (bracketed) {
              if (/^\d+$/.test(bracketed)) {
                var _n = +bracketed;
                if (_n <= numCaptures) {
                  return args[_n] || "";
                }
              }
              var n = captureNames ? (0, _indexOf["default"])(captureNames).call(captureNames, bracketed) : -1;
              if (n < 0) {
                throw new SyntaxError("Backreference to undefined group ".concat($0));
              }
              return args[n + 1] || "";
            }
            if (dollarToken === "" || dollarToken === " ") {
              throw new SyntaxError("Invalid token ".concat($0));
            }
            if (dollarToken === "&" || +dollarToken === 0) {
              return args[0];
            }
            if (dollarToken === "$") {
              return "$";
            }
            if (dollarToken === "`") {
              var _context4;
              return (0, _slice["default"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);
            }
            if (dollarToken === "'") {
              var _context5;
              return (0, _slice["default"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);
            }
            dollarToken = +dollarToken;
            if (!isNaN(dollarToken)) {
              if (dollarToken > numCaptures) {
                throw new SyntaxError("Backreference to undefined group ".concat($0));
              }
              return args[dollarToken] || "";
            }
            throw new SyntaxError("Invalid token ".concat($0));
          }
        });
      }
      if (isRegex) {
        if (search.global) {
          search.lastIndex = 0;
        } else {
          search.lastIndex = origLastIndex;
        }
      }
      return result;
    };
    fixed.split = function(separator, limit) {
      if (!XRegExp.isRegExp(separator)) {
        return String.prototype.split.apply(this, arguments);
      }
      var str = String(this);
      var output = [];
      var origLastIndex = separator.lastIndex;
      var lastLastIndex = 0;
      var lastLength;
      limit = (limit === void 0 ? -1 : limit) >>> 0;
      (0, _forEach["default"])(XRegExp).call(XRegExp, str, separator, function(match) {
        if (match.index + match[0].length > lastLastIndex) {
          output.push((0, _slice["default"])(str).call(str, lastLastIndex, match.index));
          if (match.length > 1 && match.index < str.length) {
            Array.prototype.push.apply(output, (0, _slice["default"])(match).call(match, 1));
          }
          lastLength = match[0].length;
          lastLastIndex = match.index + lastLength;
        }
      });
      if (lastLastIndex === str.length) {
        if (!separator.test("") || lastLength) {
          output.push("");
        }
      } else {
        output.push((0, _slice["default"])(str).call(str, lastLastIndex));
      }
      separator.lastIndex = origLastIndex;
      return output.length > limit ? (0, _slice["default"])(output).call(output, 0, limit) : output;
    };
    XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
      if (match[1] === "B" && scope === defaultScope) {
        return match[0];
      }
      throw new SyntaxError("Invalid escape ".concat(match[0]));
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags) {
      var code = dec(match[1]);
      if (code > 1114111) {
        throw new SyntaxError("Invalid Unicode code point ".concat(match[0]));
      }
      if (code <= 65535) {
        return "\\u".concat(pad4(hex(code)));
      }
      if (hasNativeU && (0, _indexOf["default"])(flags).call(flags, "u") !== -1) {
        return match[0];
      }
      throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, {
      leadChar: "("
    });
    XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, {
      flag: "x"
    });
    if (!hasNativeS) {
      XRegExp.addToken(/\./, function() {
        return "[\\s\\S]";
      }, {
        flag: "s",
        leadChar: "."
      });
    }
    XRegExp.addToken(/\\k<([^>]+)>/, function(match) {
      var _context6, _context7;
      var index = isNaN(match[1]) ? (0, _indexOf["default"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];
      var endIndex = match.index + match[0].length;
      if (!index || index > this.captureNames.length) {
        throw new SyntaxError("Backreference to undefined group ".concat(match[0]));
      }
      return (0, _concat["default"])(_context7 = "\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? "" : "(?:)");
    }, {
      leadChar: "\\"
    });
    XRegExp.addToken(/\\(\d+)/, function(match, scope) {
      if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") {
        throw new SyntaxError("Cannot use octal escape or backreference to undefined group ".concat(match[0]));
      }
      return match[0];
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp.addToken(/\(\?P?<((?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0898-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]|\uDB40[\uDD00-\uDDEF])*)>/, function(match) {
      var _context8;
      if (!XRegExp.isInstalled("namespacing") && (match[1] === "length" || match[1] === "__proto__")) {
        throw new SyntaxError("Cannot use reserved word as capture name ".concat(match[0]));
      }
      if ((0, _indexOf["default"])(_context8 = this.captureNames).call(_context8, match[1]) !== -1) {
        throw new SyntaxError("Cannot use same name for multiple groups ".concat(match[0]));
      }
      this.captureNames.push(match[1]);
      this.hasNamedCapture = true;
      return "(";
    }, {
      leadChar: "("
    });
    XRegExp.addToken(/\((?!\?)/, function(match, scope, flags) {
      if ((0, _indexOf["default"])(flags).call(flags, "n") !== -1) {
        return "(?:";
      }
      this.captureNames.push(null);
      return "(";
    }, {
      optionalFlags: "n",
      leadChar: "("
    });
    var _default = XRegExp;
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/core-js-pure/internals/array-reduce.js
var require_array_reduce = __commonJS({
  "node_modules/core-js-pure/internals/array-reduce.js"(exports, module) {
    init_process();
    init_buffer();
    var aCallable = require_a_callable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var lengthOfArrayLike = require_length_of_array_like();
    var $TypeError = TypeError;
    var createMethod = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        aCallable(callbackfn);
        var O = toObject(that);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index in self2) {
              memo = self2[index];
              index += i;
              break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw $TypeError("Reduce of empty array with no initial value");
            }
          }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i)
          if (index in self2) {
            memo = callbackfn(memo, self2[index], index, O);
          }
        return memo;
      };
    };
    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.es/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js-pure/internals/engine-is-node.js"(exports, module) {
    init_process();
    init_buffer();
    var classof = require_classof_raw();
    module.exports = typeof process != "undefined" && classof(process) == "process";
  }
});

// node_modules/core-js-pure/modules/es.array.reduce.js
var require_es_array_reduce = __commonJS({
  "node_modules/core-js-pure/modules/es.array.reduce.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var $reduce = require_array_reduce().left;
    var arrayMethodIsStrict = require_array_method_is_strict();
    var CHROME_VERSION = require_engine_v8_version();
    var IS_NODE = require_engine_is_node();
    var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/reduce.js
var require_reduce = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/reduce.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_reduce();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").reduce;
  }
});

// node_modules/core-js-pure/es/instance/reduce.js
var require_reduce2 = __commonJS({
  "node_modules/core-js-pure/es/instance/reduce.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_reduce();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.reduce;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.reduce ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/reduce.js
var require_reduce3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/reduce.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_reduce2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/reduce.js
var require_reduce4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/reduce.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_reduce3();
  }
});

// node_modules/core-js-pure/modules/es.array.map.js
var require_es_array_map = __commonJS({
  "node_modules/core-js-pure/modules/es.array.map.js"() {
    "use strict";
    init_process();
    init_buffer();
    var $ = require_export();
    var $map = require_array_iteration().map;
    var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
    $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
      map: function map(callbackfn) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
  }
});

// node_modules/core-js-pure/es/array/virtual/map.js
var require_map = __commonJS({
  "node_modules/core-js-pure/es/array/virtual/map.js"(exports, module) {
    init_process();
    init_buffer();
    require_es_array_map();
    var entryVirtual = require_entry_virtual();
    module.exports = entryVirtual("Array").map;
  }
});

// node_modules/core-js-pure/es/instance/map.js
var require_map2 = __commonJS({
  "node_modules/core-js-pure/es/instance/map.js"(exports, module) {
    init_process();
    init_buffer();
    var isPrototypeOf = require_object_is_prototype_of();
    var method = require_map();
    var ArrayPrototype = Array.prototype;
    module.exports = function(it) {
      var own = it.map;
      return it === ArrayPrototype || isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.map ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/map.js
var require_map3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/map.js"(exports, module) {
    init_process();
    init_buffer();
    var parent = require_map2();
    module.exports = parent;
  }
});

// node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js
var require_map4 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js-stable/instance/map.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = require_map3();
  }
});

// node_modules/xregexp/lib/addons/build.js
var require_build = __commonJS({
  "node_modules/xregexp/lib/addons/build.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _reduce = _interopRequireDefault(require_reduce4());
    var _map = _interopRequireDefault(require_map4());
    var _indexOf = _interopRequireDefault(require_index_of4());
    var _concat = _interopRequireDefault(require_concat4());
    var _default = function _default2(XRegExp) {
      var REGEX_DATA = "xregexp";
      var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], "g", {
        conjunction: "or"
      });
      function deanchor(pattern) {
        var leadingAnchor = /^(?:\(\?:\))*\^/;
        var trailingAnchor = /\$(?:\(\?:\))*$/;
        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped
        trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) {
          return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
        }
        return pattern;
      }
      function asXRegExp(value, addFlagX) {
        var flags = addFlagX ? "x" : "";
        return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? (
          // Don't recompile, to preserve capture names
          value
        ) : (
          // Recompile as XRegExp
          XRegExp(value.source, flags)
        ) : (
          // Compile string as XRegExp
          XRegExp(value, flags)
        );
      }
      function interpolate(substitution) {
        return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);
      }
      function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
        subpatterns["subpattern".concat(subpatternIndex)] = interpolated;
        return subpatterns;
      }
      function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
        var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
        return raw + (hasSubpattern ? "{{subpattern".concat(subpatternIndex, "}}") : "");
      }
      XRegExp.tag = function(flags) {
        return function(literals) {
          var _context, _context2;
          for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            substitutions[_key - 1] = arguments[_key];
          }
          var subpatterns = (0, _reduce["default"])(_context = (0, _map["default"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});
          var pattern = (0, _map["default"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join("");
          return XRegExp.build(pattern, subpatterns, flags);
        };
      };
      XRegExp.build = function(pattern, subs, flags) {
        flags = flags || "";
        var addFlagX = (0, _indexOf["default"])(flags).call(flags, "x") !== -1;
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
        if (inlineFlags) {
          flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
        }
        var data = {};
        for (var p in subs) {
          if (subs.hasOwnProperty(p)) {
            var sub = asXRegExp(subs[p], addFlagX);
            data[p] = {
              // Deanchoring allows embedding independently useful anchored regexes. If you
              // really need to keep your anchors, double them (i.e., `^^...$$`).
              pattern: deanchor(sub.source),
              names: sub[REGEX_DATA].captureNames || []
            };
          }
        }
        var patternAsRegex = asXRegExp(pattern, addFlagX);
        var numCaps = 0;
        var numPriorCaps;
        var numOuterCaps = 0;
        var outerCapsMap = [0];
        var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
        var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
          var subName = $1 || $2;
          var capName;
          var intro;
          var localCapIndex;
          if (subName) {
            var _context3;
            if (!data.hasOwnProperty(subName)) {
              throw new ReferenceError("Undefined property ".concat($0));
            }
            if ($1) {
              capName = outerCapNames[numOuterCaps];
              outerCapsMap[++numOuterCaps] = ++numCaps;
              intro = "(?<".concat(capName || subName, ">");
            } else {
              intro = "(?:";
            }
            numPriorCaps = numCaps;
            var rewrittenSubpattern = data[subName].pattern.replace(subParts, function(match, paren, backref) {
              if (paren) {
                capName = data[subName].names[numCaps - numPriorCaps];
                ++numCaps;
                if (capName) {
                  return "(?<".concat(capName, ">");
                }
              } else if (backref) {
                localCapIndex = +backref - 1;
                return data[subName].names[localCapIndex] ? (
                  // Need to preserve the backreference name in case using flag `n`
                  "\\k<".concat(data[subName].names[localCapIndex], ">")
                ) : "\\".concat(+backref + numPriorCaps);
              }
              return match;
            });
            return (0, _concat["default"])(_context3 = "".concat(intro)).call(_context3, rewrittenSubpattern, ")");
          }
          if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            if (capName) {
              return "(?<".concat(capName, ">");
            }
          } else if ($4) {
            localCapIndex = +$4 - 1;
            return outerCapNames[localCapIndex] ? (
              // Need to preserve the backreference name in case using flag `n`
              "\\k<".concat(outerCapNames[localCapIndex], ">")
            ) : "\\".concat(outerCapsMap[+$4]);
          }
          return $0;
        });
        return XRegExp(output, flags);
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/lib/addons/matchrecursive.js
var require_matchrecursive = __commonJS({
  "node_modules/xregexp/lib/addons/matchrecursive.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _indexOf = _interopRequireDefault(require_index_of4());
    var _concat = _interopRequireDefault(require_concat4());
    var _slice = _interopRequireDefault(require_slice4());
    var _default = function _default2(XRegExp) {
      function row(name, value, start, end) {
        return {
          name,
          value,
          start,
          end
        };
      }
      XRegExp.matchRecursive = function(str, left, right, flags, options) {
        flags = flags || "";
        options = options || {};
        var global2 = (0, _indexOf["default"])(flags).call(flags, "g") !== -1;
        var sticky = (0, _indexOf["default"])(flags).call(flags, "y") !== -1;
        var basicFlags = flags.replace(/y/g, "");
        left = XRegExp(left, basicFlags);
        right = XRegExp(right, basicFlags);
        var esc;
        var _options = options, escapeChar = _options.escapeChar;
        if (escapeChar) {
          var _context, _context2;
          if (escapeChar.length > 1) {
            throw new Error("Cannot use more than one escape character");
          }
          escapeChar = XRegExp.escape(escapeChar);
          esc = new RegExp(
            (0, _concat["default"])(_context = (0, _concat["default"])(_context2 = "(?:".concat(escapeChar, "[\\S\\s]|(?:(?!")).call(
              _context2,
              // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
              // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
              // transformation resulting from those flags was already applied to `left` and
              // `right` when they were passed through the XRegExp constructor above.
              XRegExp.union([left, right], "", {
                conjunction: "or"
              }).source,
              ")[^"
            )).call(_context, escapeChar, "])+)+"),
            // Flags `dgy` not needed here
            flags.replace(XRegExp._hasNativeFlag("s") ? /[^imsu]/g : /[^imu]/g, "")
          );
        }
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart;
        var innerStart;
        var leftMatch;
        var rightMatch;
        var vN = options.valueNames;
        var output = [];
        while (true) {
          if (escapeChar) {
            delimEnd += (XRegExp.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
          }
          leftMatch = XRegExp.exec(str, left, delimEnd);
          rightMatch = XRegExp.exec(str, right, delimEnd);
          if (leftMatch && rightMatch) {
            if (leftMatch.index <= rightMatch.index) {
              rightMatch = null;
            } else {
              leftMatch = null;
            }
          }
          if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
          } else if (!openTokens) {
            break;
          }
          if (sticky && !openTokens && delimStart > lastOuterEnd) {
            break;
          }
          if (leftMatch) {
            if (!openTokens) {
              outerStart = delimStart;
              innerStart = delimEnd;
            }
            openTokens += 1;
          } else if (rightMatch && openTokens) {
            openTokens -= 1;
            if (!openTokens) {
              if (vN) {
                if (vN[0] && outerStart > lastOuterEnd) {
                  output.push(row(vN[0], (0, _slice["default"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                }
                if (vN[1]) {
                  output.push(row(vN[1], (0, _slice["default"])(str).call(str, outerStart, innerStart), outerStart, innerStart));
                }
                if (vN[2]) {
                  output.push(row(vN[2], (0, _slice["default"])(str).call(str, innerStart, delimStart), innerStart, delimStart));
                }
                if (vN[3]) {
                  output.push(row(vN[3], (0, _slice["default"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));
                }
              } else {
                output.push((0, _slice["default"])(str).call(str, innerStart, delimStart));
              }
              lastOuterEnd = delimEnd;
              if (!global2) {
                break;
              }
            }
          } else {
            var unbalanced = options.unbalanced || "error";
            if (unbalanced === "skip" || unbalanced === "skip-lazy") {
              if (rightMatch) {
                rightMatch = null;
              } else {
                if (unbalanced === "skip") {
                  var outerStartDelimLength = XRegExp.exec(str, left, outerStart, "sticky")[0].length;
                  delimEnd = outerStart + (outerStartDelimLength || 1);
                } else {
                  delimEnd = outerStart + 1;
                }
                openTokens = 0;
              }
            } else if (unbalanced === "error") {
              var _context3;
              var delimSide = rightMatch ? "right" : "left";
              var errorPos = rightMatch ? delimStart : outerStart;
              throw new Error((0, _concat["default"])(_context3 = "Unbalanced ".concat(delimSide, " delimiter found in string at position ")).call(_context3, errorPos));
            } else {
              throw new Error("Unsupported value for unbalanced: ".concat(unbalanced));
            }
          }
          if (delimStart === delimEnd) {
            delimEnd += 1;
          }
        }
        if (global2 && output.length > 0 && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
          output.push(row(vN[0], (0, _slice["default"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));
        }
        return output;
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/lib/addons/unicode-base.js
var require_unicode_base = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-base.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _sliceInstanceProperty = require_slice4();
    var _Array$from = require_from3();
    var _Symbol = require_symbol3();
    var _getIteratorMethod = require_get_iterator_method7();
    var _Array$isArray = require_is_array4();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _slicedToArray2 = _interopRequireDefault(require_slicedToArray());
    var _forEach = _interopRequireDefault(require_for_each4());
    var _concat = _interopRequireDefault(require_concat4());
    var _indexOf = _interopRequireDefault(require_index_of4());
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof _Symbol !== "undefined" && _getIteratorMethod(o) || o["@@iterator"];
      if (!it) {
        if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = it.call(o);
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it["return"] != null)
            it["return"]();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray(o, minLen) {
      var _context4;
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return _Array$from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    var _default = function _default2(XRegExp) {
      var unicode = {};
      var unicodeTypes = {};
      var dec = XRegExp._dec;
      var hex = XRegExp._hex;
      var pad4 = XRegExp._pad4;
      function normalize(name) {
        return name.replace(/[- _]+/g, "").toLowerCase();
      }
      function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === "\\" ? 1 : 0);
      }
      function invertBmp(range) {
        var output = "";
        var lastEnd = -1;
        (0, _forEach["default"])(XRegExp).call(XRegExp, range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
          var start = charCode(m[1]);
          if (start > lastEnd + 1) {
            output += "\\u".concat(pad4(hex(lastEnd + 1)));
            if (start > lastEnd + 2) {
              output += "-\\u".concat(pad4(hex(start - 1)));
            }
          }
          lastEnd = charCode(m[2] || m[1]);
        });
        if (lastEnd < 65535) {
          output += "\\u".concat(pad4(hex(lastEnd + 1)));
          if (lastEnd < 65534) {
            output += "-\\uFFFF";
          }
        }
        return output;
      }
      function cacheInvertedBmp(slug) {
        var prop = "b!";
        return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
      }
      function buildAstral(slug, isNegated) {
        var item = unicode[slug];
        var combined = "";
        if (item.bmp && !item.isBmpLast) {
          var _context;
          combined = (0, _concat["default"])(_context = "[".concat(item.bmp, "]")).call(_context, item.astral ? "|" : "");
        }
        if (item.astral) {
          combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
          var _context2;
          combined += (0, _concat["default"])(_context2 = "".concat(item.astral ? "|" : "", "[")).call(_context2, item.bmp, "]");
        }
        return isNegated ? "(?:(?!".concat(combined, ")(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-￿]))") : "(?:".concat(combined, ")");
      }
      function cacheAstral(slug, isNegated) {
        var prop = isNegated ? "a!" : "a=";
        return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
      }
      XRegExp.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)(?:(\w+)=)?([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags) {
          var ERR_DOUBLE_NEG = "Invalid double negation ";
          var ERR_UNKNOWN_NAME = "Unknown Unicode token ";
          var ERR_UNKNOWN_REF = "Unicode token missing data ";
          var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ";
          var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes";
          var _match = (0, _slicedToArray2["default"])(match, 6), fullToken = _match[0], pPrefix = _match[1], caretNegation = _match[2], typePrefix = _match[3], tokenName = _match[4], tokenSingleCharName = _match[5];
          var isNegated = pPrefix === "P" || !!caretNegation;
          var isAstralMode = (0, _indexOf["default"])(flags).call(flags, "A") !== -1;
          var slug = normalize(tokenSingleCharName || tokenName);
          var item = unicode[slug];
          if (pPrefix === "P" && caretNegation) {
            throw new SyntaxError(ERR_DOUBLE_NEG + fullToken);
          }
          if (!unicode.hasOwnProperty(slug)) {
            throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
          }
          if (typePrefix) {
            if (!(unicodeTypes[typePrefix] && unicodeTypes[typePrefix][slug])) {
              throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
            }
          }
          if (item.inverseOf) {
            slug = normalize(item.inverseOf);
            if (!unicode.hasOwnProperty(slug)) {
              var _context3;
              throw new ReferenceError((0, _concat["default"])(_context3 = "".concat(ERR_UNKNOWN_REF + fullToken, " -> ")).call(_context3, item.inverseOf));
            }
            item = unicode[slug];
            isNegated = !isNegated;
          }
          if (!(item.bmp || isAstralMode)) {
            throw new SyntaxError(ERR_ASTRAL_ONLY + fullToken);
          }
          if (isAstralMode) {
            if (scope === "class") {
              throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
            }
            return cacheAstral(slug, isNegated);
          }
          return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : "".concat((isNegated ? "[^" : "[") + item.bmp, "]");
        },
        {
          scope: "all",
          optionalFlags: "A",
          leadChar: "\\"
        }
      );
      XRegExp.addUnicodeData = function(data, typePrefix) {
        var ERR_NO_NAME = "Unicode token requires name";
        var ERR_NO_DATA = "Unicode token has no character data ";
        if (typePrefix) {
          unicodeTypes[typePrefix] = {};
        }
        var _iterator = _createForOfIteratorHelper(data), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            if (!item.name) {
              throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
              throw new Error(ERR_NO_DATA + item.name);
            }
            var normalizedName = normalize(item.name);
            unicode[normalizedName] = item;
            if (typePrefix) {
              unicodeTypes[typePrefix][normalizedName] = true;
            }
            if (item.alias) {
              var normalizedAlias = normalize(item.alias);
              unicode[normalizedAlias] = item;
              if (typePrefix) {
                unicodeTypes[typePrefix][normalizedAlias] = true;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        XRegExp.cache.flush("patterns");
      };
      XRegExp._getUnicodeProperty = function(name) {
        var slug = normalize(name);
        return unicode[slug];
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/tools/output/categories.js
var require_categories = __commonJS({
  "node_modules/xregexp/tools/output/categories.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = [
      {
        "name": "C",
        "alias": "Other",
        "isBmpLast": true,
        "bmp": "\0--­͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-؅؜۝܎܏݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏-ࢗ࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠎᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿​-‏‪-‮⁠-⁯⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽-＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￻￾￿",
        "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCBD\uDCC3-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
      },
      {
        "name": "Cc",
        "alias": "Control",
        "bmp": "\0--"
      },
      {
        "name": "Cf",
        "alias": "Format",
        "bmp": "­؀-؅؜۝܏࢐࢑࣢᠎​-‏‪-‮⁠-⁤⁦-⁯\uFEFF￹-￻",
        "astral": "\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC38]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
      },
      {
        "name": "Cn",
        "alias": "Unassigned",
        "bmp": "͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-׿܎݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏࢒-ࢗ঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿⁥⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-퟿﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽﻾＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￸￾￿",
        "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCC3-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F\uDC39-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
      },
      {
        "name": "Co",
        "alias": "Private_Use",
        "bmp": "-",
        "astral": "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
      },
      {
        "name": "Cs",
        "alias": "Surrogate",
        "bmp": "\uD800-\uDFFF"
      },
      {
        "name": "L",
        "alias": "Letter",
        "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "LC",
        "alias": "Cased_Letter",
        "bmp": "A-Za-zµÀ-ÖØ-öø-ƺƼ-ƿǄ-ʓʕ-ʯͰ-ͳͶͷͻ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՠ-ֈႠ-ჅჇჍა-ჺჽ-ჿᎠ-Ᏽᏸ-ᏽᲀ-ᲈᲐ-ᲺᲽ-Ჿᴀ-ᴫᵫ-ᵷᵹ-ᶚḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℴℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⱻⱾ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭꙀ-ꙭꚀ-ꚛꜢ-ꝯꝱ-ꞇꞋ-ꞎꞐ-ꟊꟐꟑꟓꟕ-ꟙꟵꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗＡ-Ｚａ-ｚ",
        "astral": "\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD00-\uDD43]"
      },
      {
        "name": "Ll",
        "alias": "Lowercase_Letter",
        "bmp": "a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎↄⰰ-ⱟⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟁꟃꟈꟊꟑꟓꟕꟗꟙꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
        "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
      },
      {
        "name": "Lm",
        "alias": "Modifier_Letter",
        "bmp": "ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥۦߴߵߺࠚࠤࠨࣉॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼⱽⵯⸯ々〱-〵〻ゝゞー-ヾꀕꓸ-ꓽꘌꙿꚜꚝꜗ-ꜟꝰꞈꟲ-ꟴꟸꟹꧏꧦꩰꫝꫳꫴꭜ-ꭟꭩｰﾞﾟ",
        "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD838[\uDD37-\uDD3D]|𞥋"
      },
      {
        "name": "Lo",
        "alias": "Other_Letter",
        "bmp": "ªºƻǀ-ǃʔא-תׯ-ײؠ-ؿف-يٮٯٱ-ۓەۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣈऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๅກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳳᳵᳶᳺℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF4A\uDF50]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|𝼊|\uD838[\uDD00-\uDD2C\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "Lt",
        "alias": "Titlecase_Letter",
        "bmp": "ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ"
      },
      {
        "name": "Lu",
        "alias": "Uppercase_Letter",
        "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅↃⰀ-ⰯⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟀꟂꟄ-ꟇꟉꟐꟖꟘꟵＡ-Ｚ",
        "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
      },
      {
        "name": "M",
        "alias": "Mark",
        "bmp": "̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣඁ-ඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-ᫎᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯",
        "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      },
      {
        "name": "Mc",
        "alias": "Spacing_Mark",
        "bmp": "ःऻा-ीॉ-ौॎॏংঃা-ীেৈোৌৗਃਾ-ੀઃા-ીૉોૌଂଃାୀେୈୋୌୗாிுூெ-ைொ-ௌௗఁ-ఃు-ౄಂಃಾೀ-ೄೇೈೊೋೕೖംഃാ-ീെ-ൈൊ-ൌൗංඃා-ෑෘ-ෟෲෳ༾༿ཿါာေးျြၖၗၢ-ၤၧ-ၭႃႄႇ-ႌႏႚ-ႜ᜕᜴ាើ-ៅះៈᤣ-ᤦᤩ-ᤫᤰᤱᤳ-ᤸᨙᨚᩕᩗᩡᩣᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ᭄ᮂᮡᮦᮧ᮪ᯧᯪ-ᯬᯮ᯲᯳ᰤ-ᰫᰴᰵ᳡᳷〮〯ꠣꠤꠧꢀꢁꢴ-ꣃꥒ꥓ꦃꦴꦵꦺꦻꦾ-꧀ꨯꨰꨳꨴꩍꩻꩽꫫꫮꫯꫵꯣꯤꯦꯧꯩꯪ꯬",
        "astral": "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD30-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
      },
      {
        "name": "Me",
        "alias": "Enclosing_Mark",
        "bmp": "҈҉᪾⃝-⃠⃢-⃤꙰-꙲"
      },
      {
        "name": "Mn",
        "alias": "Nonspacing_Mark",
        "bmp": "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣ৾ਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣૺ-૿ଁ଼ିୁ-ୄ୍୕ୖୢୣஂீ்ఀఄ఼ా-ీె-ైొ-్ౕౖౢౣಁ಼ಿೆೌ್ೢೣഀഁ഻഼ു-ൄ്ൢൣඁ්ි-ුූัิ-ฺ็-๎ັິ-ຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲᜳᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᪿ-ᫎᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᮫-ᮭ᯦ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꠬꣄ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꦽꧥꨩ-ꨮꨱꨲꨵꨶꩃꩌꩼꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯",
        "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
      },
      {
        "name": "N",
        "alias": "Number",
        "bmp": "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൘-൞൦-൸෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
        "astral": "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]"
      },
      {
        "name": "Nd",
        "alias": "Decimal_Number",
        "bmp": "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
        "astral": "\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]"
      },
      {
        "name": "Nl",
        "alias": "Letter_Number",
        "bmp": "ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ",
        "astral": "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
      },
      {
        "name": "No",
        "alias": "Other_Number",
        "bmp": "²³¹¼-¾৴-৹୲-୷௰-௲౸-౾൘-൞൰-൸༪-༳፩-፼៰-៹᧚⁰⁴-⁹₀-₉⅐-⅟↉①-⒛⓪-⓿❶-➓⳽㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꠰-꠵",
        "astral": "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C\uDFC0-\uDFD4]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]"
      },
      {
        "name": "P",
        "alias": "Punctuation",
        "bmp": "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}¡§«¶·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔༺-༽྅࿐-࿔࿙࿚၊-၏჻፠-፨᐀᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎⌈-⌋〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰-⹏⹒-⹝、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･",
        "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      },
      {
        "name": "Pc",
        "alias": "Connector_Punctuation",
        "bmp": "_‿⁀⁔︳︴﹍-﹏＿"
      },
      {
        "name": "Pd",
        "alias": "Dash_Punctuation",
        "bmp": "\\-֊־᐀᠆‐-―⸗⸚⸺⸻⹀⹝〜〰゠︱︲﹘﹣－",
        "astral": "𐺭"
      },
      {
        "name": "Pe",
        "alias": "Close_Punctuation",
        "bmp": "\\)\\]\\}༻༽᚜⁆⁾₎⌉⌋〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩⹖⹘⹚⹜〉》」』】〕〗〙〛〞〟﴾︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣"
      },
      {
        "name": "Pf",
        "alias": "Final_Punctuation",
        "bmp": "»’”›⸃⸅⸊⸍⸝⸡"
      },
      {
        "name": "Pi",
        "alias": "Initial_Punctuation",
        "bmp": "«‘‛“‟‹⸂⸄⸉⸌⸜⸠"
      },
      {
        "name": "Po",
        "alias": "Other_Punctuation",
        "bmp": "!-#%-'\\*,\\.\\/:;\\?@\\¡§¶·¿;·՚-՟։׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔྅࿐-࿔࿙࿚၊-၏჻፠-፨᙮᛫-᛭᜵᜶។-៖៘-៚᠀-᠅᠇-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‖‗†-‧‰-‸※-‾⁁-⁃⁇-⁑⁓⁕-⁞⳹-⳼⳾⳿⵰⸀⸁⸆-⸈⸋⸎-⸖⸘⸙⸛⸞⸟⸪-⸮⸰-⸹⸼-⸿⹁⹃-⹏⹒-⹔、-〃〽・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫︐-︖︙︰﹅﹆﹉-﹌﹐-﹒﹔-﹗﹟-﹡﹨﹪﹫！-＃％-＇＊，．／：；？＠＼｡､･",
        "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
      },
      {
        "name": "Ps",
        "alias": "Open_Punctuation",
        "bmp": "\\(\\[\\{༺༼᚛‚„⁅⁽₍⌈⌊〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨⹂⹕⹗⹙⹛〈《「『【〔〖〘〚〝﴿︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢"
      },
      {
        "name": "S",
        "alias": "Symbol",
        "bmp": "\\$\\+<->\\^`\\|~¢-¦¨©¬®-±´¸×÷˂-˅˒-˟˥-˫˭˯-˿͵΄΅϶҂֍-֏؆-؈؋؎؏۞۩۽۾߶߾߿࢈৲৳৺৻૱୰௳-௺౿൏൹฿༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭៛᥀᧞-᧿᭡-᭪᭴-᭼᾽᾿-῁῍-῏῝-῟῭-`´῾⁄⁒⁺-⁼₊-₌₠-⃀℀℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊↋←-⌇⌌-⌨⌫-␦⑀-⑊⒜-ⓩ─-❧➔-⟄⟇-⟥⟰-⦂⦙-⧗⧜-⧻⧾-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿゛゜㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꜀-꜖꜠꜡꞉꞊꠨-꠫꠶-꠹꩷-꩹꭛꭪꭫﬩﮲-﯂﵀-﵏﷏﷼-﷿﹢﹤-﹦﹩＄＋＜-＞＾｀｜～￠-￦￨-￮￼�",
        "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
      },
      {
        "name": "Sc",
        "alias": "Currency_Symbol",
        "bmp": "\\$¢-¥֏؋߾߿৲৳৻૱௹฿៛₠-⃀꠸﷼﹩＄￠￡￥￦",
        "astral": "\uD807[\uDFDD-\uDFE0]|𞋿|𞲰"
      },
      {
        "name": "Sk",
        "alias": "Modifier_Symbol",
        "bmp": "\\^`¨¯´¸˂-˅˒-˟˥-˫˭˯-˿͵΄΅࢈᾽᾿-῁῍-῏῝-῟῭-`´῾゛゜꜀-꜖꜠꜡꞉꞊꭛꭪꭫﮲-﯂＾｀￣",
        "astral": "\uD83C[\uDFFB-\uDFFF]"
      },
      {
        "name": "Sm",
        "alias": "Math_Symbol",
        "bmp": "\\+<->\\|~¬±×÷϶؆-؈⁄⁒⁺-⁼₊-₌℘⅀-⅄⅋←-↔↚↛↠↣↦↮⇎⇏⇒⇔⇴-⋿⌠⌡⍼⎛-⎳⏜-⏡▷◁◸-◿♯⟀-⟄⟇-⟥⟰-⟿⤀-⦂⦙-⧗⧜-⧻⧾-⫿⬰-⭄⭇-⭌﬩﹢﹤-﹦＋＜-＞｜～￢￩-￬",
        "astral": "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
      },
      {
        "name": "So",
        "alias": "Other_Symbol",
        "bmp": "¦©®°҂֍֎؎؏۞۩۽۾߶৺୰௳-௸௺౿൏൹༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭᥀᧞-᧿᭡-᭪᭴-᭼℀℁℃-℆℈℉℔№℗℞-℣℥℧℩℮℺℻⅊⅌⅍⅏↊↋↕-↙↜-↟↡↢↤↥↧-↭↯-⇍⇐⇑⇓⇕-⇳⌀-⌇⌌-⌟⌢-⌨⌫-⍻⍽-⎚⎴-⏛⏢-␦⑀-⑊⒜-ⓩ─-▶▸-◀◂-◷☀-♮♰-❧➔-➿⠀-⣿⬀-⬯⭅⭆⭍-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꠨-꠫꠶꠷꠹꩷-꩹﵀-﵏﷏﷽-﷿￤￨￭￮￼�",
        "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFDC\uDFE1-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|𞅏|\uD83B[\uDCAC\uDD2E]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
      },
      {
        "name": "Z",
        "alias": "Separator",
        "bmp": "    - \u2028\u2029  　"
      },
      {
        "name": "Zl",
        "alias": "Line_Separator",
        "bmp": "\u2028"
      },
      {
        "name": "Zp",
        "alias": "Paragraph_Separator",
        "bmp": "\u2029"
      },
      {
        "name": "Zs",
        "alias": "Space_Separator",
        "bmp": "    -   　"
      }
    ];
  }
});

// node_modules/xregexp/lib/addons/unicode-categories.js
var require_unicode_categories = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-categories.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _categories = _interopRequireDefault(require_categories());
    var _default = function _default2(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
      }
      XRegExp.addUnicodeData(_categories["default"]);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/tools/output/properties.js
var require_properties = __commonJS({
  "node_modules/xregexp/tools/output/properties.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = [
      {
        "name": "ASCII",
        "bmp": "\0-"
      },
      {
        "name": "Alphabetic",
        "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈְ-ׇֽֿׁׂׅׄא-תׯ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉࣔ-ࣣࣟ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱৼਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹ-ૼଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౝౠ-ౣಀ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೝೞೠ-ೣೱೲഀ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൔ-ൗൟ-ൣൺ-ൿඁ-ඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄຆ-ຊຌ-ຣລວ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ႏႚ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜓᜟ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡸᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᪿᫀᫌ-ᫎᬀ-ᬳᬵ-ᭃᭅ-ᭌᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰶᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠅꠇ-ꠧꡀ-ꡳꢀ-ꣃꣅꣲ-ꣷꣻꣽ-ꣿꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC45\uDC71-\uDC75\uDC82-\uDCB8\uDCC2\uDCD0-\uDCE8\uDD00-\uDD32\uDD44-\uDD47\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDCE\uDDCF\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDEB8\uDF00-\uDF1A\uDF1D-\uDF2A\uDF40-\uDF46]|\uD806[\uDC00-\uDC38\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B\uDD3C\uDD3F-\uDD42\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDDF\uDDE1\uDDE3\uDDE4\uDE00-\uDE32\uDE35-\uDE3E\uDE50-\uDE97\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD41\uDD43\uDD46\uDD47\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD96\uDD98\uDEE0-\uDEF6\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "Any",
        "isBmpLast": true,
        "bmp": "\0-￿",
        "astral": "[\uD800-\uDBFF][\uDC00-\uDFFF]"
      },
      {
        "name": "Default_Ignorable_Code_Point",
        "bmp": "­͏؜ᅟᅠ឴឵᠋-᠏​-‏‪-‮⁠-⁯ㅤ︀-️\uFEFFﾠ￰-￸",
        "astral": "\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]"
      },
      {
        "name": "Lowercase",
        "bmp": "a-zªµºß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʸˀˁˠ-ˤͅͱͳͷͺ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᶿḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷⁱⁿₐ-ₜℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎⅰ-ⅿↄⓐ-ⓩⰰ-ⱟⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱽⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛ-ꚝꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟁꟃꟈꟊꟑꟓꟕꟗꟙꟶꟸ-ꟺꬰ-ꭚꭜ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
        "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDF80\uDF83-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
      },
      {
        "name": "Noncharacter_Code_Point",
        "bmp": "﷐-﷯￾￿",
        "astral": "[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]"
      },
      {
        "name": "Uppercase",
        "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅⅠ-ⅯↃⒶ-ⓏⰀ-ⰯⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟀꟂꟄ-ꟇꟉꟐꟖꟘꟵＡ-Ｚ",
        "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]"
      },
      {
        "name": "White_Space",
        "bmp": "	-\r    - \u2028\u2029  　"
      }
    ];
  }
});

// node_modules/xregexp/lib/addons/unicode-properties.js
var require_unicode_properties = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-properties.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _properties = _interopRequireDefault(require_properties());
    var _default = function _default2(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
      }
      var unicodeData = _properties["default"];
      unicodeData.push({
        name: "Assigned",
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: "Cn"
      });
      XRegExp.addUnicodeData(unicodeData);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/tools/output/scripts.js
var require_scripts = __commonJS({
  "node_modules/xregexp/tools/output/scripts.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = [
      {
        "name": "Adlam",
        "astral": "\uD83A[\uDD00-\uDD4B\uDD50-\uDD59\uDD5E\uDD5F]"
      },
      {
        "name": "Ahom",
        "astral": "\uD805[\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF46]"
      },
      {
        "name": "Anatolian_Hieroglyphs",
        "astral": "\uD811[\uDC00-\uDE46]"
      },
      {
        "name": "Arabic",
        "bmp": "؀-؄؆-؋؍-ؚ؜-؞ؠ-ؿف-يٖ-ٯٱ-ۜ۞-ۿݐ-ݿࡰ-ࢎ࢐࢑࢘-ࣣ࣡-ࣿﭐ-﯂ﯓ-ﴽ﵀-ﶏﶒ-ﷇ﷏ﷰ-﷿ﹰ-ﹴﹶ-ﻼ",
        "astral": "\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]"
      },
      {
        "name": "Armenian",
        "bmp": "Ա-Ֆՙ-֊֍-֏ﬓ-ﬗ"
      },
      {
        "name": "Avestan",
        "astral": "\uD802[\uDF00-\uDF35\uDF39-\uDF3F]"
      },
      {
        "name": "Balinese",
        "bmp": "ᬀ-ᭌ᭐-᭾"
      },
      {
        "name": "Bamum",
        "bmp": "ꚠ-꛷",
        "astral": "\uD81A[\uDC00-\uDE38]"
      },
      {
        "name": "Bassa_Vah",
        "astral": "\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]"
      },
      {
        "name": "Batak",
        "bmp": "ᯀ-᯳᯼-᯿"
      },
      {
        "name": "Bengali",
        "bmp": "ঀ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-৾"
      },
      {
        "name": "Bhaiksuki",
        "astral": "\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]"
      },
      {
        "name": "Bopomofo",
        "bmp": "˪˫ㄅ-ㄯㆠ-ㆿ"
      },
      {
        "name": "Brahmi",
        "astral": "\uD804[\uDC00-\uDC4D\uDC52-\uDC75\uDC7F]"
      },
      {
        "name": "Braille",
        "bmp": "⠀-⣿"
      },
      {
        "name": "Buginese",
        "bmp": "ᨀ-ᨛ᨞᨟"
      },
      {
        "name": "Buhid",
        "bmp": "ᝀ-ᝓ"
      },
      {
        "name": "Canadian_Aboriginal",
        "bmp": "᐀-ᙿᢰ-ᣵ",
        "astral": "\uD806[\uDEB0-\uDEBF]"
      },
      {
        "name": "Carian",
        "astral": "\uD800[\uDEA0-\uDED0]"
      },
      {
        "name": "Caucasian_Albanian",
        "astral": "\uD801[\uDD30-\uDD63\uDD6F]"
      },
      {
        "name": "Chakma",
        "astral": "\uD804[\uDD00-\uDD34\uDD36-\uDD47]"
      },
      {
        "name": "Cham",
        "bmp": "ꨀ-ꨶꩀ-ꩍ꩐-꩙꩜-꩟"
      },
      {
        "name": "Cherokee",
        "bmp": "Ꭰ-Ᏽᏸ-ᏽꭰ-ꮿ"
      },
      {
        "name": "Chorasmian",
        "astral": "\uD803[\uDFB0-\uDFCB]"
      },
      {
        "name": "Common",
        "bmp": "\0-@\\[-`\\{-©«-¹»-¿×÷ʹ-˟˥-˩ˬ-˿ʹ;΅·؅،؛؟ـ۝࣢।॥฿࿕-࿘჻᛫-᛭᜵᜶᠂᠃᠅᳓᳡ᳩ-ᳬᳮ-ᳳᳵ-᳷ᳺ -​‎-⁤⁦-⁰⁴-⁾₀-₎₠-⃀℀-℥℧-℩ℬ-ℱℳ-⅍⅏-⅟↉-↋←-␦⑀-⑊①-⟿⤀-⭳⭶-⮕⮗-⯿⸀-⹝⿰-⿻　-〄〆〈-〠〰-〷〼-〿゛゜゠・ー㆐-㆟㇀-㇣㈠-㉟㉿-㋏㋿㍘-㏿䷀-䷿꜀-꜡ꞈ-꞊꠰-꠹꤮ꧏ꭛꭪꭫﴾﴿︐-︙︰-﹒﹔-﹦﹨-﹫\uFEFF！-＠［-｀｛-･ｰﾞﾟ￠-￦￨-￮￹-�",
        "astral": "\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9C\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDEE0-\uDEF3\uDF00-\uDF56\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83B[\uDC71-\uDCB4\uDD01-\uDD3D]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDDAD\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA\uDFF0-\uDFF9]|\uDB40[\uDC01\uDC20-\uDC7F]"
      },
      {
        "name": "Coptic",
        "bmp": "Ϣ-ϯⲀ-ⳳ⳹-⳿"
      },
      {
        "name": "Cuneiform",
        "astral": "\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]"
      },
      {
        "name": "Cypriot",
        "astral": "\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]"
      },
      {
        "name": "Cypro_Minoan",
        "astral": "\uD80B[\uDF90-\uDFF2]"
      },
      {
        "name": "Cyrillic",
        "bmp": "Ѐ-҄҇-ԯᲀ-ᲈᴫᵸⷠ-ⷿꙀ-ꚟ︮︯"
      },
      {
        "name": "Deseret",
        "astral": "\uD801[\uDC00-\uDC4F]"
      },
      {
        "name": "Devanagari",
        "bmp": "ऀ-ॐॕ-ॣ०-ॿ꣠-ꣿ"
      },
      {
        "name": "Dives_Akuru",
        "astral": "\uD806[\uDD00-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD46\uDD50-\uDD59]"
      },
      {
        "name": "Dogra",
        "astral": "\uD806[\uDC00-\uDC3B]"
      },
      {
        "name": "Duployan",
        "astral": "\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]"
      },
      {
        "name": "Egyptian_Hieroglyphs",
        "astral": "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E\uDC30-\uDC38]"
      },
      {
        "name": "Elbasan",
        "astral": "\uD801[\uDD00-\uDD27]"
      },
      {
        "name": "Elymaic",
        "astral": "\uD803[\uDFE0-\uDFF6]"
      },
      {
        "name": "Ethiopic",
        "bmp": "ሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፼ᎀ-᎙ⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮ",
        "astral": "\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]"
      },
      {
        "name": "Georgian",
        "bmp": "Ⴀ-ჅჇჍა-ჺჼ-ჿᲐ-ᲺᲽ-Ჿⴀ-ⴥⴧⴭ"
      },
      {
        "name": "Glagolitic",
        "bmp": "Ⰰ-ⱟ",
        "astral": "\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]"
      },
      {
        "name": "Gothic",
        "astral": "\uD800[\uDF30-\uDF4A]"
      },
      {
        "name": "Grantha",
        "astral": "\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]"
      },
      {
        "name": "Greek",
        "bmp": "Ͱ-ͳ͵-ͷͺ-ͽͿ΄ΆΈ-ΊΌΎ-ΡΣ-ϡϰ-Ͽᴦ-ᴪᵝ-ᵡᵦ-ᵪᶿἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ῄῆ-ΐῖ-Ί῝-`ῲ-ῴῶ-῾Ωꭥ",
        "astral": "\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]"
      },
      {
        "name": "Gujarati",
        "bmp": "ઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૱ૹ-૿"
      },
      {
        "name": "Gunjala_Gondi",
        "astral": "\uD807[\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9]"
      },
      {
        "name": "Gurmukhi",
        "bmp": "ਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-੶"
      },
      {
        "name": "Han",
        "bmp": "⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〻㐀-䶿一-鿿豈-舘並-龎",
        "astral": "\uD81B[\uDFE2\uDFE3\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
      },
      {
        "name": "Hangul",
        "bmp": "ᄀ-ᇿ〮〯ㄱ-ㆎ㈀-㈞㉠-㉾ꥠ-ꥼ가-힣ힰ-ퟆퟋ-ퟻﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
      },
      {
        "name": "Hanifi_Rohingya",
        "astral": "\uD803[\uDD00-\uDD27\uDD30-\uDD39]"
      },
      {
        "name": "Hanunoo",
        "bmp": "ᜠ-᜴"
      },
      {
        "name": "Hatran",
        "astral": "\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]"
      },
      {
        "name": "Hebrew",
        "bmp": "֑-ׇא-תׯ-״יִ-זּטּ-לּמּנּסּףּפּצּ-ﭏ"
      },
      {
        "name": "Hiragana",
        "bmp": "ぁ-ゖゝ-ゟ",
        "astral": "\uD82C[\uDC01-\uDD1F\uDD50-\uDD52]|🈀"
      },
      {
        "name": "Imperial_Aramaic",
        "astral": "\uD802[\uDC40-\uDC55\uDC57-\uDC5F]"
      },
      {
        "name": "Inherited",
        "bmp": "̀-ًͯ҅҆-ٰٕ॑-॔᪰-ᫎ᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷿‌‍⃐-〪⃰-゙゚〭︀-️︠-︭",
        "astral": "\uD800[\uDDFD\uDEE0]|𑌻|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]"
      },
      {
        "name": "Inscriptional_Pahlavi",
        "astral": "\uD802[\uDF60-\uDF72\uDF78-\uDF7F]"
      },
      {
        "name": "Inscriptional_Parthian",
        "astral": "\uD802[\uDF40-\uDF55\uDF58-\uDF5F]"
      },
      {
        "name": "Javanese",
        "bmp": "ꦀ-꧍꧐-꧙꧞꧟"
      },
      {
        "name": "Kaithi",
        "astral": "\uD804[\uDC80-\uDCC2\uDCCD]"
      },
      {
        "name": "Kannada",
        "bmp": "ಀ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೝೞೠ-ೣ೦-೯ೱೲ"
      },
      {
        "name": "Katakana",
        "bmp": "ァ-ヺヽ-ヿㇰ-ㇿ㋐-㋾㌀-㍗ｦ-ｯｱ-ﾝ",
        "astral": "\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00\uDD20-\uDD22\uDD64-\uDD67]"
      },
      {
        "name": "Kayah_Li",
        "bmp": "꤀-꤭꤯"
      },
      {
        "name": "Kharoshthi",
        "astral": "\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE50-\uDE58]"
      },
      {
        "name": "Khitan_Small_Script",
        "astral": "𖿤|\uD822[\uDF00-\uDFFF]|\uD823[\uDC00-\uDCD5]"
      },
      {
        "name": "Khmer",
        "bmp": "ក-៝០-៩៰-៹᧠-᧿"
      },
      {
        "name": "Khojki",
        "astral": "\uD804[\uDE00-\uDE11\uDE13-\uDE3E]"
      },
      {
        "name": "Khudawadi",
        "astral": "\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]"
      },
      {
        "name": "Lao",
        "bmp": "ກຂຄຆ-ຊຌ-ຣລວ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟ"
      },
      {
        "name": "Latin",
        "bmp": "A-Za-zªºÀ-ÖØ-öø-ʸˠ-ˤᴀ-ᴥᴬ-ᵜᵢ-ᵥᵫ-ᵷᵹ-ᶾḀ-ỿⁱⁿₐ-ₜKÅℲⅎⅠ-ↈⱠ-ⱿꜢ-ꞇꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꟿꬰ-ꭚꭜ-ꭤꭦ-ꭩﬀ-ﬆＡ-Ｚａ-ｚ",
        "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD837[\uDF00-\uDF1E]"
      },
      {
        "name": "Lepcha",
        "bmp": "ᰀ-᰷᰻-᱉ᱍ-ᱏ"
      },
      {
        "name": "Limbu",
        "bmp": "ᤀ-ᤞᤠ-ᤫᤰ-᤻᥀᥄-᥏"
      },
      {
        "name": "Linear_A",
        "astral": "\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]"
      },
      {
        "name": "Linear_B",
        "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]"
      },
      {
        "name": "Lisu",
        "bmp": "ꓐ-꓿",
        "astral": "𑾰"
      },
      {
        "name": "Lycian",
        "astral": "\uD800[\uDE80-\uDE9C]"
      },
      {
        "name": "Lydian",
        "astral": "\uD802[\uDD20-\uDD39\uDD3F]"
      },
      {
        "name": "Mahajani",
        "astral": "\uD804[\uDD50-\uDD76]"
      },
      {
        "name": "Makasar",
        "astral": "\uD807[\uDEE0-\uDEF8]"
      },
      {
        "name": "Malayalam",
        "bmp": "ഀ-ഌഎ-ഐഒ-ൄെ-ൈൊ-൏ൔ-ൣ൦-ൿ"
      },
      {
        "name": "Mandaic",
        "bmp": "ࡀ-࡛࡞"
      },
      {
        "name": "Manichaean",
        "astral": "\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]"
      },
      {
        "name": "Marchen",
        "astral": "\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]"
      },
      {
        "name": "Masaram_Gondi",
        "astral": "\uD807[\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]"
      },
      {
        "name": "Medefaidrin",
        "astral": "\uD81B[\uDE40-\uDE9A]"
      },
      {
        "name": "Meetei_Mayek",
        "bmp": "ꫠ-꫶ꯀ-꯭꯰-꯹"
      },
      {
        "name": "Mende_Kikakui",
        "astral": "\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]"
      },
      {
        "name": "Meroitic_Cursive",
        "astral": "\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]"
      },
      {
        "name": "Meroitic_Hieroglyphs",
        "astral": "\uD802[\uDD80-\uDD9F]"
      },
      {
        "name": "Miao",
        "astral": "\uD81B[\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F]"
      },
      {
        "name": "Modi",
        "astral": "\uD805[\uDE00-\uDE44\uDE50-\uDE59]"
      },
      {
        "name": "Mongolian",
        "bmp": "᠀᠁᠄᠆-᠙ᠠ-ᡸᢀ-ᢪ",
        "astral": "\uD805[\uDE60-\uDE6C]"
      },
      {
        "name": "Mro",
        "astral": "\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]"
      },
      {
        "name": "Multani",
        "astral": "\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]"
      },
      {
        "name": "Myanmar",
        "bmp": "က-႟ꧠ-ꧾꩠ-ꩿ"
      },
      {
        "name": "Nabataean",
        "astral": "\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]"
      },
      {
        "name": "Nandinagari",
        "astral": "\uD806[\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE4]"
      },
      {
        "name": "New_Tai_Lue",
        "bmp": "ᦀ-ᦫᦰ-ᧉ᧐-᧚᧞᧟"
      },
      {
        "name": "Newa",
        "astral": "\uD805[\uDC00-\uDC5B\uDC5D-\uDC61]"
      },
      {
        "name": "Nko",
        "bmp": "߀-ߺ߽-߿"
      },
      {
        "name": "Nushu",
        "astral": "𖿡|\uD82C[\uDD70-\uDEFB]"
      },
      {
        "name": "Nyiakeng_Puachue_Hmong",
        "astral": "\uD838[\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDD4F]"
      },
      {
        "name": "Ogham",
        "bmp": " -᚜"
      },
      {
        "name": "Ol_Chiki",
        "bmp": "᱐-᱿"
      },
      {
        "name": "Old_Hungarian",
        "astral": "\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]"
      },
      {
        "name": "Old_Italic",
        "astral": "\uD800[\uDF00-\uDF23\uDF2D-\uDF2F]"
      },
      {
        "name": "Old_North_Arabian",
        "astral": "\uD802[\uDE80-\uDE9F]"
      },
      {
        "name": "Old_Permic",
        "astral": "\uD800[\uDF50-\uDF7A]"
      },
      {
        "name": "Old_Persian",
        "astral": "\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]"
      },
      {
        "name": "Old_Sogdian",
        "astral": "\uD803[\uDF00-\uDF27]"
      },
      {
        "name": "Old_South_Arabian",
        "astral": "\uD802[\uDE60-\uDE7F]"
      },
      {
        "name": "Old_Turkic",
        "astral": "\uD803[\uDC00-\uDC48]"
      },
      {
        "name": "Old_Uyghur",
        "astral": "\uD803[\uDF70-\uDF89]"
      },
      {
        "name": "Oriya",
        "bmp": "ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍୕-ୗଡ଼ଢ଼ୟ-ୣ୦-୷"
      },
      {
        "name": "Osage",
        "astral": "\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]"
      },
      {
        "name": "Osmanya",
        "astral": "\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]"
      },
      {
        "name": "Pahawh_Hmong",
        "astral": "\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]"
      },
      {
        "name": "Palmyrene",
        "astral": "\uD802[\uDC60-\uDC7F]"
      },
      {
        "name": "Pau_Cin_Hau",
        "astral": "\uD806[\uDEC0-\uDEF8]"
      },
      {
        "name": "Phags_Pa",
        "bmp": "ꡀ-꡷"
      },
      {
        "name": "Phoenician",
        "astral": "\uD802[\uDD00-\uDD1B\uDD1F]"
      },
      {
        "name": "Psalter_Pahlavi",
        "astral": "\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]"
      },
      {
        "name": "Rejang",
        "bmp": "ꤰ-꥓꥟"
      },
      {
        "name": "Runic",
        "bmp": "ᚠ-ᛪᛮ-ᛸ"
      },
      {
        "name": "Samaritan",
        "bmp": "ࠀ-࠭࠰-࠾"
      },
      {
        "name": "Saurashtra",
        "bmp": "ꢀ-ꣅ꣎-꣙"
      },
      {
        "name": "Sharada",
        "astral": "\uD804[\uDD80-\uDDDF]"
      },
      {
        "name": "Shavian",
        "astral": "\uD801[\uDC50-\uDC7F]"
      },
      {
        "name": "Siddham",
        "astral": "\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]"
      },
      {
        "name": "SignWriting",
        "astral": "\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]"
      },
      {
        "name": "Sinhala",
        "bmp": "ඁ-ඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟ෦-෯ෲ-෴",
        "astral": "\uD804[\uDDE1-\uDDF4]"
      },
      {
        "name": "Sogdian",
        "astral": "\uD803[\uDF30-\uDF59]"
      },
      {
        "name": "Sora_Sompeng",
        "astral": "\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]"
      },
      {
        "name": "Soyombo",
        "astral": "\uD806[\uDE50-\uDEA2]"
      },
      {
        "name": "Sundanese",
        "bmp": "ᮀ-ᮿ᳀-᳇"
      },
      {
        "name": "Syloti_Nagri",
        "bmp": "ꠀ-꠬"
      },
      {
        "name": "Syriac",
        "bmp": "܀-܍܏-݊ݍ-ݏࡠ-ࡪ"
      },
      {
        "name": "Tagalog",
        "bmp": "ᜀ-᜕ᜟ"
      },
      {
        "name": "Tagbanwa",
        "bmp": "ᝠ-ᝬᝮ-ᝰᝲᝳ"
      },
      {
        "name": "Tai_Le",
        "bmp": "ᥐ-ᥭᥰ-ᥴ"
      },
      {
        "name": "Tai_Tham",
        "bmp": "ᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪠-᪭"
      },
      {
        "name": "Tai_Viet",
        "bmp": "ꪀ-ꫂꫛ-꫟"
      },
      {
        "name": "Takri",
        "astral": "\uD805[\uDE80-\uDEB9\uDEC0-\uDEC9]"
      },
      {
        "name": "Tamil",
        "bmp": "ஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௺",
        "astral": "\uD807[\uDFC0-\uDFF1\uDFFF]"
      },
      {
        "name": "Tangsa",
        "astral": "\uD81A[\uDE70-\uDEBE\uDEC0-\uDEC9]"
      },
      {
        "name": "Tangut",
        "astral": "𖿠|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEFF]|\uD823[\uDD00-\uDD08]"
      },
      {
        "name": "Telugu",
        "bmp": "ఀ-ఌఎ-ఐఒ-నప-హ఼-ౄె-ైొ-్ౕౖౘ-ౚౝౠ-ౣ౦-౯౷-౿"
      },
      {
        "name": "Thaana",
        "bmp": "ހ-ޱ"
      },
      {
        "name": "Thai",
        "bmp": "ก-ฺเ-๛"
      },
      {
        "name": "Tibetan",
        "bmp": "ༀ-ཇཉ-ཬཱ-ྗྙ-ྼ྾-࿌࿎-࿔࿙࿚"
      },
      {
        "name": "Tifinagh",
        "bmp": "ⴰ-ⵧⵯ⵰⵿"
      },
      {
        "name": "Tirhuta",
        "astral": "\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]"
      },
      {
        "name": "Toto",
        "astral": "\uD838[\uDE90-\uDEAE]"
      },
      {
        "name": "Ugaritic",
        "astral": "\uD800[\uDF80-\uDF9D\uDF9F]"
      },
      {
        "name": "Vai",
        "bmp": "ꔀ-ꘫ"
      },
      {
        "name": "Vithkuqi",
        "astral": "\uD801[\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]"
      },
      {
        "name": "Wancho",
        "astral": "\uD838[\uDEC0-\uDEF9\uDEFF]"
      },
      {
        "name": "Warang_Citi",
        "astral": "\uD806[\uDCA0-\uDCF2\uDCFF]"
      },
      {
        "name": "Yezidi",
        "astral": "\uD803[\uDE80-\uDEA9\uDEAB-\uDEAD\uDEB0\uDEB1]"
      },
      {
        "name": "Yi",
        "bmp": "ꀀ-ꒌ꒐-꓆"
      },
      {
        "name": "Zanabazar_Square",
        "astral": "\uD806[\uDE00-\uDE47]"
      }
    ];
  }
});

// node_modules/xregexp/lib/addons/unicode-scripts.js
var require_unicode_scripts = __commonJS({
  "node_modules/xregexp/lib/addons/unicode-scripts.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _scripts = _interopRequireDefault(require_scripts());
    var _default = function _default2(XRegExp) {
      if (!XRegExp.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
      }
      XRegExp.addUnicodeData(_scripts["default"], "Script");
    };
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/xregexp/lib/index.js
var require_lib = __commonJS({
  "node_modules/xregexp/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _Object$defineProperty = require_define_property3();
    var _interopRequireDefault = require_interopRequireDefault();
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _xregexp = _interopRequireDefault(require_xregexp());
    var _build = _interopRequireDefault(require_build());
    var _matchrecursive = _interopRequireDefault(require_matchrecursive());
    var _unicodeBase = _interopRequireDefault(require_unicode_base());
    var _unicodeCategories = _interopRequireDefault(require_unicode_categories());
    var _unicodeProperties = _interopRequireDefault(require_unicode_properties());
    var _unicodeScripts = _interopRequireDefault(require_unicode_scripts());
    (0, _build["default"])(_xregexp["default"]);
    (0, _matchrecursive["default"])(_xregexp["default"]);
    (0, _unicodeBase["default"])(_xregexp["default"]);
    (0, _unicodeCategories["default"])(_xregexp["default"]);
    (0, _unicodeProperties["default"])(_xregexp["default"]);
    (0, _unicodeScripts["default"])(_xregexp["default"]);
    var _default = _xregexp["default"];
    exports["default"] = _default;
    module.exports = exports.default;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module) {
    init_process();
    init_buffer();
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected");
          return f;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done2 = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
          var context = {};
          for (var p in contextIn)
            context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
            context.access[p] = contextIn.access[p];
          context.addInitializer = function(f) {
            if (done2)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_ = accept(result.get))
              descriptor.get = _;
            if (_ = accept(result.set))
              descriptor.set = _;
            if (_ = accept(result.init))
              initializers.push(_);
          } else if (_ = accept(result)) {
            if (kind === "field")
              initializers.push(_);
            else
              descriptor[key] = _;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done2 = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
          value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x) {
        return typeof x === "symbol" ? x : "".concat(x);
      };
      __setFunctionName = function(f, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from2, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from2.length, ar; i < l; i++) {
            if (ar || !(i in from2)) {
              if (!ar)
                ar = Array.prototype.slice.call(from2, 0, i);
              ar[i] = from2[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from2));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume2(n, v);
              });
            };
        }
        function resume2(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume2("next", value);
        }
        function reject(value) {
          resume2("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume2(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// node_modules/graphql/version.mjs
var version, versionInfo;
var init_version = __esm({
  "node_modules/graphql/version.mjs"() {
    init_process();
    init_buffer();
    version = "16.6.0";
    versionInfo = Object.freeze({
      major: 16,
      minor: 6,
      patch: 0,
      preReleaseTag: null
    });
  }
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var init_devAssert = __esm({
  "node_modules/graphql/jsutils/devAssert.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
var init_isPromise = __esm({
  "node_modules/graphql/jsutils/isPromise.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
var init_isObjectLike = __esm({
  "node_modules/graphql/jsutils/isObjectLike.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
var init_invariant = __esm({
  "node_modules/graphql/jsutils/invariant.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp;
var init_location = __esm({
  "node_modules/graphql/language/location.mjs"() {
    init_process();
    init_buffer();
    init_invariant();
    LineRegExp = /\r\n|[\n\r]/g;
  }
});

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
var init_printLocation = __esm({
  "node_modules/graphql/language/printLocation.mjs"() {
    init_process();
    init_buffer();
    init_location();
  }
});

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  return error.toString();
}
function formatError(error) {
  return error.toJSON();
}
var GraphQLError;
var init_GraphQLError = __esm({
  "node_modules/graphql/error/GraphQLError.mjs"() {
    init_process();
    init_buffer();
    init_isObjectLike();
    init_location();
    init_printLocation();
    GraphQLError = class extends Error {
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
        const originalExtensions = isObjectLike(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + printSourceLocation(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
  }
});

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
var init_syntaxError = __esm({
  "node_modules/graphql/error/syntaxError.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
var init_ast = __esm({
  "node_modules/graphql/language/ast.mjs"() {
    init_process();
    init_buffer();
    Location = class {
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    Token = class {
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    kindValues = new Set(Object.keys(QueryDocumentKeys));
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (OperationTypeNode = {}));
  }
});

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
var init_directiveLocation = __esm({
  "node_modules/graphql/language/directiveLocation.mjs"() {
    init_process();
    init_buffer();
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (DirectiveLocation = {}));
  }
});

// node_modules/graphql/language/kinds.mjs
var Kind;
var init_kinds = __esm({
  "node_modules/graphql/language/kinds.mjs"() {
    init_process();
    init_buffer();
    (function(Kind2) {
      Kind2["NAME"] = "Name";
      Kind2["DOCUMENT"] = "Document";
      Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind2["SELECTION_SET"] = "SelectionSet";
      Kind2["FIELD"] = "Field";
      Kind2["ARGUMENT"] = "Argument";
      Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind2["INLINE_FRAGMENT"] = "InlineFragment";
      Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind2["VARIABLE"] = "Variable";
      Kind2["INT"] = "IntValue";
      Kind2["FLOAT"] = "FloatValue";
      Kind2["STRING"] = "StringValue";
      Kind2["BOOLEAN"] = "BooleanValue";
      Kind2["NULL"] = "NullValue";
      Kind2["ENUM"] = "EnumValue";
      Kind2["LIST"] = "ListValue";
      Kind2["OBJECT"] = "ObjectValue";
      Kind2["OBJECT_FIELD"] = "ObjectField";
      Kind2["DIRECTIVE"] = "Directive";
      Kind2["NAMED_TYPE"] = "NamedType";
      Kind2["LIST_TYPE"] = "ListType";
      Kind2["NON_NULL_TYPE"] = "NonNullType";
      Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind2["FIELD_DEFINITION"] = "FieldDefinition";
      Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind || (Kind = {}));
  }
});

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
var init_characterClasses = __esm({
  "node_modules/graphql/language/characterClasses.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var init_blockString = __esm({
  "node_modules/graphql/language/blockString.mjs"() {
    init_process();
    init_buffer();
    init_characterClasses();
  }
});

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
var init_tokenKind = __esm({
  "node_modules/graphql/language/tokenKind.mjs"() {
    init_process();
    init_buffer();
    (function(TokenKind2) {
      TokenKind2["SOF"] = "<SOF>";
      TokenKind2["EOF"] = "<EOF>";
      TokenKind2["BANG"] = "!";
      TokenKind2["DOLLAR"] = "$";
      TokenKind2["AMP"] = "&";
      TokenKind2["PAREN_L"] = "(";
      TokenKind2["PAREN_R"] = ")";
      TokenKind2["SPREAD"] = "...";
      TokenKind2["COLON"] = ":";
      TokenKind2["EQUALS"] = "=";
      TokenKind2["AT"] = "@";
      TokenKind2["BRACKET_L"] = "[";
      TokenKind2["BRACKET_R"] = "]";
      TokenKind2["BRACE_L"] = "{";
      TokenKind2["PIPE"] = "|";
      TokenKind2["BRACE_R"] = "}";
      TokenKind2["NAME"] = "Name";
      TokenKind2["INT"] = "Int";
      TokenKind2["FLOAT"] = "Float";
      TokenKind2["STRING"] = "String";
      TokenKind2["BLOCK_STRING"] = "BlockString";
      TokenKind2["COMMENT"] = "Comment";
    })(TokenKind || (TokenKind = {}));
  }
});

// node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
var Lexer;
var init_lexer = __esm({
  "node_modules/graphql/language/lexer.mjs"() {
    init_process();
    init_buffer();
    init_syntaxError();
    init_ast();
    init_blockString();
    init_characterClasses();
    init_tokenKind();
    Lexer = class {
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      }
    };
  }
});

// node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "node_modules/graphql/jsutils/inspect.mjs"() {
    init_process();
    init_buffer();
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});

// node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf;
var init_instanceOf = __esm({
  "node_modules/graphql/jsutils/instanceOf.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    instanceOf = /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    // eslint-disable-next-line no-undef
    false ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    };
  }
});

// node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}
var Source;
var init_source = __esm({
  "node_modules/graphql/language/source.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_instanceOf();
    Source = class {
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || devAssert(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
  }
});

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseConstValueLiteral();
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const type = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type;
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
var Parser;
var init_parser = __esm({
  "node_modules/graphql/language/parser.mjs"() {
    init_process();
    init_buffer();
    init_syntaxError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_lexer();
    init_source();
    init_tokenKind();
    Parser = class {
      constructor(source, options = {}) {
        const sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(TokenKind.NAME);
        return this.node(token, {
          kind: Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: Kind.DOCUMENT,
          definitions: this.many(
            TokenKind.SOF,
            this.parseDefinition,
            TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation: OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return OperationTypeNode.QUERY;
          case "mutation":
            return OperationTypeNode.MUTATION;
          case "subscription":
            return OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseVariableDefinition,
          TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return this.node(start, {
          kind: Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: Kind.SELECTION_SET,
          selections: this.many(
            TokenKind.BRACE_L,
            this.parseSelection,
            TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return this.node(start, {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.INT,
              value: token.value
            });
          case TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: Kind.FLOAT,
              value: token.value
            });
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: Kind.ENUM,
                  value: token.value
                });
            }
          case TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(TokenKind.DOLLAR);
              if (this._lexer.token.kind === TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = () => this.parseValueLiteral(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = () => this.parseObjectField(isConst);
        return this.node(this._lexer.token, {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        return this.node(start, {
          kind: Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return this.node(start, {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type = this.node(start, {
            kind: Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return this.node(start, {
            kind: Kind.NON_NULL_TYPE,
            type
          });
        }
        return type;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        const type = this.parseNamedType();
        return this.node(start, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseFieldDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          TokenKind.PAREN_L,
          this.parseInputValueDef,
          TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(TokenKind.COLON);
        const type = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          TokenKind.BRACE_L,
          this.parseInputValueDef,
          TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > maxTokens) {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
  }
});

// node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS;
var init_didYouMean = __esm({
  "node_modules/graphql/jsutils/didYouMean.mjs"() {
    init_process();
    init_buffer();
    MAX_SUGGESTIONS = 5;
  }
});

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}
var init_identityFunc = __esm({
  "node_modules/graphql/jsutils/identityFunc.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}
var init_keyMap = __esm({
  "node_modules/graphql/jsutils/keyMap.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
var init_keyValMap = __esm({
  "node_modules/graphql/jsutils/keyValMap.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}
var init_mapValue = __esm({
  "node_modules/graphql/jsutils/mapValue.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
var DIGIT_0, DIGIT_9;
var init_naturalCompare = __esm({
  "node_modules/graphql/jsutils/naturalCompare.mjs"() {
    init_process();
    init_buffer();
    DIGIT_0 = 48;
    DIGIT_9 = 57;
  }
});

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
var LexicalDistance;
var init_suggestionList = __esm({
  "node_modules/graphql/jsutils/suggestionList.mjs"() {
    init_process();
    init_buffer();
    init_naturalCompare();
    LexicalDistance = class {
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
  }
});

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
var init_toObjMap = __esm({
  "node_modules/graphql/jsutils/toObjMap.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapedRegExp, escapeSequences;
var init_printString = __esm({
  "node_modules/graphql/language/printString.mjs"() {
    init_process();
    init_buffer();
    escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys2 = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys2.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys2[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys2 = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor, kind);
  return isLeaving ? leave : enter;
}
var BREAK;
var init_visitor = __esm({
  "node_modules/graphql/language/visitor.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_ast();
    init_kinds();
    BREAK = Object.freeze({});
  }
});

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "node_modules/graphql/language/printer.mjs"() {
    init_process();
    init_buffer();
    init_blockString();
    init_printString();
    init_visitor();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: {
        leave: (node) => node.value
      },
      Variable: {
        leave: (node) => "$" + node.name
      },
      // Document
      Document: {
        leave: (node) => join(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
          const prefix = join(
            [
              node.operation,
              join([node.name, varDefs]),
              join(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
      },
      SelectionSet: {
        leave: ({ selections }) => block(selections)
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap("", alias, ": ") + name;
          let argsLine = prefix + wrap("(", join(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH) {
            argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
          }
          return join([argsLine, join(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join(
          [
            "...",
            wrap("on ", typeCondition),
            join(directives, " "),
            selectionSet
          ],
          " "
        )
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: {
        leave: ({ value }) => value
      },
      FloatValue: {
        leave: ({ value }) => value
      },
      StringValue: {
        leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
      },
      BooleanValue: {
        leave: ({ value }) => value ? "true" : "false"
      },
      NullValue: {
        leave: () => "null"
      },
      EnumValue: {
        leave: ({ value }) => value
      },
      ListValue: {
        leave: ({ values }) => "[" + join(values, ", ") + "]"
      },
      ObjectValue: {
        leave: ({ fields }) => "{" + join(fields, ", ") + "}"
      },
      ObjectField: {
        leave: ({ name, value }) => name + ": " + value
      },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
      },
      // Type
      NamedType: {
        leave: ({ name }) => name
      },
      ListType: {
        leave: ({ type }) => "[" + type + "]"
      },
      NonNullType: {
        leave: ({ type }) => type + "!"
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      FieldDefinition: {
        leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
          [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
          " "
        )
      },
      InterfaceTypeDefinition: {
        leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
          [
            "interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeDefinition: {
        leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
          ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
          " "
        )
      },
      EnumTypeDefinition: {
        leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join(
          ["extend schema", join(directives, " "), block(operationTypes)],
          " "
        )
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend type",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join(
          [
            "extend interface",
            name,
            wrap("implements ", join(interfaces, " & ")),
            join(directives, " "),
            block(fields)
          ],
          " "
        )
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join(
          [
            "extend union",
            name,
            join(directives, " "),
            wrap("= ", join(types, " | "))
          ],
          " "
        )
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
      }
    };
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
var init_valueFromASTUntyped = __esm({
  "node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
    init_process();
    init_buffer();
    init_keyValMap();
    init_kinds();
  }
});

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}
var init_assertName = __esm({
  "node_modules/graphql/type/assertName.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_GraphQLError();
    init_characterClasses();
  }
});

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
  }
  return type;
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
  }
  return type;
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
  }
  return type;
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Interface type.`
    );
  }
  return type;
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
  }
  return type;
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
  }
  return type;
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL Input Object type.`
    );
  }
  return type;
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
  }
  return type;
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
  }
  return type;
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
  }
  return type;
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
  }
  return type;
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
  }
  return type;
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error(
      `Expected ${inspect(type)} to be a GraphQL composite type.`
    );
  }
  return type;
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
  }
  return type;
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
  }
  return type;
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
  }
  return type;
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
  }
  return type;
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function defineInterfaces(config2) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config2.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config2) {
  return Object.entries(config2).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
function defineTypes(config2) {
  const types = resolveReadonlyArrayThunk(config2.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
  );
  return types;
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
function defineInputFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
var GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
var init_definition = __esm({
  "node_modules/graphql/type/definition.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_didYouMean();
    init_identityFunc();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_keyMap();
    init_keyValMap();
    init_mapValue();
    init_suggestionList();
    init_toObjMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_valueFromASTUntyped();
    init_assertName();
    GraphQLList = class {
      constructor(ofType) {
        isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLNonNull = class {
      constructor(ofType) {
        isNullableType(ofType) || devAssert(
          false,
          `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLScalarType = class {
      constructor(config2) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.specifiedByURL = config2.specifiedByURL;
        this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || devAssert(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config2.specifiedByURL)}.`
        );
        config2.serialize == null || typeof config2.serialize === "function" || devAssert(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config2.parseLiteral) {
          typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLObjectType = class {
      constructor(config2) {
        var _config$extensionASTN2;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.isTypeOf = config2.isTypeOf;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config2);
        this._interfaces = () => defineInterfaces(config2);
        config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config2.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInterfaceType = class {
      constructor(config2) {
        var _config$extensionASTN3;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config2);
        this._interfaces = defineInterfaces.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLUnionType = class {
      constructor(config2) {
        var _config$extensionASTN4;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLEnumType = class {
      /* <T> */
      constructor(config2) {
        var _config$extensionASTN5;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = defineEnumValues(this.name, config2.values);
        this._valueLookup = new Map(
          this._values.map((enumValue) => [enumValue.value, enumValue])
        );
        this._nameLookup = keyMap(this._values, (value) => value.name);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        return this._values;
      }
      getValue(name) {
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = inspect(inputValue);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== Kind.ENUM) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = print(valueNode);
          throw new GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = keyValMap(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLInputObjectType = class {
      constructor(config2) {
        var _config$extensionASTN6;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this._fields = defineInputFieldMap.bind(void 0, config2);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = mapValue(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
  }
});

// node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
var init_typeComparators = __esm({
  "node_modules/graphql/utilities/typeComparators.mjs"() {
    init_process();
    init_buffer();
    init_definition();
  }
});

// node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
var GRAPHQL_MAX_INT, GRAPHQL_MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
var init_scalars = __esm({
  "node_modules/graphql/type/scalars.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_isObjectLike();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    GRAPHQL_MAX_INT = 2147483647;
    GRAPHQL_MIN_INT = -2147483648;
    GraphQLInt = new GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(coercedValue)}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${inspect(inputValue)}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Int cannot represent non-integer value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    GraphQLFloat = new GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(coercedValue)}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            `Float cannot represent non numeric value: ${print(valueNode)}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    GraphQLString = new GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new GraphQLError(
          `String cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new GraphQLError(
            `String cannot represent a non string value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING) {
          throw new GraphQLError(
            `String cannot represent a non string value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLBoolean = new GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new GraphQLError(
          `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.BOOLEAN) {
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    GraphQLID = new GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new GraphQLError(
          `ID cannot represent value: ${inspect(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
          throw new GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + print(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    specifiedScalarTypes = Object.freeze([
      GraphQLString,
      GraphQLInt,
      GraphQLFloat,
      GraphQLBoolean,
      GraphQLID
    ]);
  }
});

// node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(
      `Expected ${inspect(directive)} to be a GraphQL directive.`
    );
  }
  return directive;
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}
var GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, specifiedDirectives;
var init_directives = __esm({
  "node_modules/graphql/type/directives.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_directiveLocation();
    init_assertName();
    init_definition();
    init_scalars();
    GraphQLDirective = class {
      constructor(config2) {
        var _config$isRepeatable, _config$args;
        this.name = assertName(config2.name);
        this.description = config2.description;
        this.locations = config2.locations;
        this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        Array.isArray(config2.locations) || devAssert(false, `@${config2.name} locations must be an Array.`);
        const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
        isObjectLike(args) && !Array.isArray(args) || devAssert(
          false,
          `@${config2.name} args must be an object with argument names as keys.`
        );
        this.args = defineArguments(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: argsToArgsConfig(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        DirectiveLocation.FIELD,
        DirectiveLocation.FRAGMENT_SPREAD,
        DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    DEFAULT_DEPRECATION_REASON = "No longer supported";
    GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        DirectiveLocation.FIELD_DEFINITION,
        DirectiveLocation.ARGUMENT_DEFINITION,
        DirectiveLocation.INPUT_FIELD_DEFINITION,
        DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new GraphQLNonNull(GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective,
      GraphQLSpecifiedByDirective
    ]);
  }
});

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
var init_isIterableObject = __esm({
  "node_modules/graphql/jsutils/isIterableObject.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp;
var init_astFromValue = __esm({
  "node_modules/graphql/utilities/astFromValue.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_kinds();
    init_definition();
    init_scalars();
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
var init_introspection = __esm({
  "node_modules/graphql/type/introspection.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_directiveLocation();
    init_printer();
    init_astFromValue();
    init_definition();
    init_scalars();
    __Schema = new GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: {
          type: GraphQLString,
          resolve: (schema) => schema.description
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new GraphQLNonNull(__Type),
          resolve: (schema) => schema.getQueryType()
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getMutationType()
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: (schema) => schema.getSubscriptionType()
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__Directive))
          ),
          resolve: (schema) => schema.getDirectives()
        }
      })
    });
    __Directive = new GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (directive) => directive.name
        },
        description: {
          type: GraphQLString,
          resolve: (directive) => directive.description
        },
        isRepeatable: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (directive) => directive.isRepeatable
        },
        locations: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
          ),
          resolve: (directive) => directive.locations
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      })
    });
    __DirectiveLocation = new GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    __Type = new GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new GraphQLNonNull(__TypeKind),
          resolve(type) {
            if (isScalarType(type)) {
              return TypeKind.SCALAR;
            }
            if (isObjectType(type)) {
              return TypeKind.OBJECT;
            }
            if (isInterfaceType(type)) {
              return TypeKind.INTERFACE;
            }
            if (isUnionType(type)) {
              return TypeKind.UNION;
            }
            if (isEnumType(type)) {
              return TypeKind.ENUM;
            }
            if (isInputObjectType(type)) {
              return TypeKind.INPUT_OBJECT;
            }
            if (isListType(type)) {
              return TypeKind.LIST;
            }
            if (isNonNullType(type)) {
              return TypeKind.NON_NULL;
            }
            invariant(false, `Unexpected type: "${inspect(type)}".`);
          }
        },
        name: {
          type: GraphQLString,
          resolve: (type) => "name" in type ? type.name : void 0
        },
        description: {
          type: GraphQLString,
          resolve: (type) => (
            /* c8 ignore next */
            "description" in type ? type.description : void 0
          )
        },
        specifiedByURL: {
          type: GraphQLString,
          resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
        },
        fields: {
          type: new GraphQLList(new GraphQLNonNull(__Field)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isObjectType(type) || isInterfaceType(type)) {
              const fields = Object.values(type.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type) {
            if (isObjectType(type) || isInterfaceType(type)) {
              return type.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new GraphQLList(new GraphQLNonNull(__Type)),
          resolve(type, _args, _context, { schema }) {
            if (isAbstractType(type)) {
              return schema.getPossibleTypes(type);
            }
          }
        },
        enumValues: {
          type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isEnumType(type)) {
              const values = type.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new GraphQLList(new GraphQLNonNull(__InputValue)),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type, { includeDeprecated }) {
            if (isInputObjectType(type)) {
              const values = Object.values(type.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: (type) => "ofType" in type ? type.ofType : void 0
        }
      })
    });
    __Field = new GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (field) => field.name
        },
        description: {
          type: GraphQLString,
          resolve: (field) => field.description
        },
        args: {
          type: new GraphQLNonNull(
            new GraphQLList(new GraphQLNonNull(__InputValue))
          ),
          args: {
            includeDeprecated: {
              type: GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (field) => field.type
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (field) => field.deprecationReason
        }
      })
    });
    __InputValue = new GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (inputValue) => inputValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (inputValue) => inputValue.description
        },
        type: {
          type: new GraphQLNonNull(__Type),
          resolve: (inputValue) => inputValue.type
        },
        defaultValue: {
          type: GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type, defaultValue } = inputValue;
            const valueAST = astFromValue(defaultValue, type);
            return valueAST ? print(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (field) => field.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (obj) => obj.deprecationReason
        }
      })
    });
    __EnumValue = new GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: {
          type: new GraphQLNonNull(GraphQLString),
          resolve: (enumValue) => enumValue.name
        },
        description: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.description
        },
        isDeprecated: {
          type: new GraphQLNonNull(GraphQLBoolean),
          resolve: (enumValue) => enumValue.deprecationReason != null
        },
        deprecationReason: {
          type: GraphQLString,
          resolve: (enumValue) => enumValue.deprecationReason
        }
      })
    });
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (TypeKind = {}));
    __TypeKind = new GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    SchemaMetaFieldDef = {
      name: "__schema",
      type: new GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (_source, _args, _context, { schema }) => schema,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new GraphQLNonNull(GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    TypeNameMetaFieldDef = {
      name: "__typename",
      type: new GraphQLNonNull(GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (_source, _args, _context, { parentType }) => parentType.name,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
  }
});

// node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
var GraphQLSchema;
var init_schema = __esm({
  "node_modules/graphql/type/schema.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_instanceOf();
    init_isObjectLike();
    init_toObjMap();
    init_ast();
    init_definition();
    init_directives();
    init_introspection();
    GraphQLSchema = class {
      // Used as a cache for validateSchema().
      constructor(config2) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config2.assumeValid === true ? [] : void 0;
        isObjectLike(config2) || devAssert(false, "Must provide configuration object.");
        !config2.types || Array.isArray(config2.types) || devAssert(
          false,
          `"types" must be Array if provided but got: ${inspect(config2.types)}.`
        );
        !config2.directives || Array.isArray(config2.directives) || devAssert(
          false,
          `"directives" must be Array if provided but got: ${inspect(config2.directives)}.`
        );
        this.description = config2.description;
        this.extensions = toObjMap(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config2.query;
        this._mutationType = config2.mutation;
        this._subscriptionType = config2.subscription;
        this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
        const allReferencedTypes = new Set(config2.types);
        if (config2.types != null) {
          for (const type of config2.types) {
            allReferencedTypes.delete(type);
            collectReferencedTypes(type, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if (isDirective(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || devAssert(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if (isInterfaceType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if (isObjectType(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if (isInterfaceType(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case OperationTypeNode.QUERY:
            return this.getQueryType();
          case OperationTypeNode.MUTATION:
            return this.getMutationType();
          case OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if (isUnionType(abstractType)) {
            for (const type of abstractType.getTypes()) {
              map[type.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type of implementations.objects) {
              map[type.name] = true;
            }
            for (const type of implementations.interfaces) {
              map[type.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
  }
});

// node_modules/graphql/type/validate.mjs
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema) {
  const errors = validateSchema(schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(
      `Query root type must be Object type, it cannot be ${inspect(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(
        `Expected directive but got: ${inspect(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(
        `Expected GraphQL named type but got: ${inspect(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(
        `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
}
function validateTypeImplementsInterface(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
var SchemaValidationContext;
var init_validate = __esm({
  "node_modules/graphql/type/validate.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_GraphQLError();
    init_ast();
    init_typeComparators();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
    SchemaValidationContext = class {
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
  }
});

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
var init_typeFromAST = __esm({
  "node_modules/graphql/utilities/typeFromAST.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
    init_definition();
  }
});

// node_modules/graphql/utilities/TypeInfo.mjs
function getFieldDef(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
var TypeInfo;
var init_TypeInfo = __esm({
  "node_modules/graphql/utilities/TypeInfo.mjs"() {
    init_process();
    init_buffer();
    init_ast();
    init_kinds();
    init_visitor();
    init_definition();
    init_introspection();
    init_typeFromAST();
    TypeInfo = class {
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if (isInputType(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if (isCompositeType(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if (isOutputType(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case Kind.SELECTION_SET: {
            const namedType = getNamedType(this.getType());
            this._parentTypeStack.push(
              isCompositeType(namedType) ? namedType : void 0
            );
            break;
          }
          case Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
            break;
          }
          case Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
            break;
          }
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
            this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
            break;
          }
          case Kind.VARIABLE_DEFINITION: {
            const inputType = typeFromAST(schema, node.type);
            this._inputTypeStack.push(
              isInputType(inputType) ? inputType : void 0
            );
            break;
          }
          case Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
            break;
          }
          case Kind.LIST: {
            const listType = getNullableType(this.getInputType());
            const itemType = isListType(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
            break;
          }
          case Kind.OBJECT_FIELD: {
            const objectType = getNamedType(this.getInputType());
            let inputFieldType;
            let inputField;
            if (isInputObjectType(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              isInputType(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case Kind.ENUM: {
            const enumType = getNamedType(this.getInputType());
            let enumValue;
            if (isEnumType(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case Kind.DIRECTIVE:
            this._directive = null;
            break;
          case Kind.OPERATION_DEFINITION:
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.LIST:
          case Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
  }
});

// node_modules/graphql/language/predicates.mjs
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
var init_predicates = __esm({
  "node_modules/graphql/language/predicates.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
var init_ExecutableDefinitionsRule = __esm({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_kinds();
    init_predicates();
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
var init_FieldsOnCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_naturalCompare();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
var init_FragmentsOnCompositeTypesRule = __esm({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
var init_KnownArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
var init_KnownDirectivesRule = __esm({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_GraphQLError();
    init_ast();
    init_directiveLocation();
    init_kinds();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
var init_KnownFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
var standardTypeNames;
var init_KnownTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_predicates();
    init_introspection();
    init_scalars();
    standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
      (type) => type.name
    );
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_LoneAnonymousOperationRule = __esm({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_kinds();
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
var init_LoneSchemaDefinitionRule = __esm({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
var init_NoFragmentCyclesRule = __esm({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
var init_NoUndefinedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
var init_NoUnusedFragmentsRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
var init_NoUnusedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
var init_sortValueNode = __esm({
  "node_modules/graphql/utilities/sortValueNode.mjs"() {
    init_process();
    init_buffer();
    init_naturalCompare();
    init_kinds();
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function stringifyArguments(fieldNode) {
  var _fieldNode$arguments;
  const args = (
    /* c8 ignore next */
    (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
  );
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet;
var init_OverlappingFieldsCanBeMergedRule = __esm({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_sortValueNode();
    init_typeFromAST();
    PairSet = class {
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, areMutuallyExclusive) {
        var _this$_data$get;
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
        if (result === void 0) {
          return false;
        }
        return areMutuallyExclusive ? true : areMutuallyExclusive === result;
      }
      add(a, b, areMutuallyExclusive) {
        const [key1, key2] = a < b ? [a, b] : [b, a];
        const map = this._data.get(key1);
        if (map === void 0) {
          this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
        } else {
          map.set(key2, areMutuallyExclusive);
        }
      }
    };
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}
var init_PossibleFragmentSpreadsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_GraphQLError();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}
var defKindToExtKind;
var init_PossibleTypeExtensionsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_definition();
    defKindToExtKind = {
      [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
      [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
      [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
      [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
      [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
      [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
var init_ProvidedRequiredArgumentsRule = __esm({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_keyMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
var init_ScalarLeafsRule = __esm({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}
var init_printPathArray = __esm({
  "node_modules/graphql/jsutils/printPathArray.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
var init_Path = __esm({
  "node_modules/graphql/jsutils/Path.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var init_coerceInputValue = __esm({
  "node_modules/graphql/utilities/coerceInputValue.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_Path();
    init_printPathArray();
    init_suggestionList();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
var init_valueFromAST = __esm({
  "node_modules/graphql/utilities/valueFromAST.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_keyMap();
    init_kinds();
    init_definition();
  }
});

// node_modules/graphql/execution/values.mjs
function getVariableValues(schema, varDefNodes, inputs, options) {
  const errors = [];
  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    const coerced = coerceVariableValues(
      schema,
      varDefNodes,
      inputs,
      (error) => {
        if (maxErrors != null && errors.length >= maxErrors) {
          throw new GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        }
        errors.push(error);
      }
    );
    if (errors.length === 0) {
      return {
        coerced
      };
    }
  } catch (error) {
    errors.push(error);
  }
  return {
    errors
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(
        new GraphQLError(
          `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
          {
            nodes: varDefNode.type
          }
        )
      );
      continue;
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
            {
              nodes: varDefNode
            }
          )
        );
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect(varType);
      onError(
        new GraphQLError(
          `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
          {
            nodes: varDefNode
          }
        )
      );
      continue;
    }
    coercedValues[varName] = coerceInputValue(
      value,
      varType,
      (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${printPathArray(path)}"`;
        }
        onError(
          new GraphQLError(prefix + "; " + error.message, {
            nodes: varDefNode,
            originalError: error.originalError
          })
        );
      }
    );
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull2 = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull2 = variableValues[variableName] == null;
    }
    if (isNull2 && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var init_values = __esm({
  "node_modules/graphql/execution/values.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_keyMap();
    init_printPathArray();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_coerceInputValue();
    init_typeFromAST();
    init_valueFromAST();
  }
});

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
var init_collectFields = __esm({
  "node_modules/graphql/execution/collectFields.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
    init_definition();
    init_directives();
    init_typeFromAST();
    init_values();
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
var init_SingleFieldSubscriptionsRule = __esm({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_kinds();
    init_collectFields();
  }
});

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}
var init_groupBy = __esm({
  "node_modules/graphql/jsutils/groupBy.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
var init_UniqueArgumentDefinitionNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_groupBy();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
var init_UniqueArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_groupBy();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueDirectiveNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
var init_UniqueDirectivesPerLocationRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
var init_UniqueEnumValueNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}
var init_UniqueFieldDefinitionNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
var init_UniqueInputFieldNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_invariant();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
var init_UniqueOperationNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
var init_UniqueOperationTypesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
var init_UniqueTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
var init_UniqueVariableNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
    init_process();
    init_buffer();
    init_groupBy();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
var init_ValuesOfCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
    init_process();
    init_buffer();
    init_didYouMean();
    init_inspect();
    init_keyMap();
    init_suggestionList();
    init_GraphQLError();
    init_printer();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
var init_VariablesAreInputTypesRule = __esm({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
var init_VariablesInAllowedPositionRule = __esm({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_definition();
    init_typeComparators();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules, specifiedSDLRules;
var init_specifiedRules = __esm({
  "node_modules/graphql/validation/specifiedRules.mjs"() {
    init_process();
    init_buffer();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_LoneSchemaDefinitionRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_PossibleTypeExtensionsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectiveNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    specifiedRules = Object.freeze([
      ExecutableDefinitionsRule,
      UniqueOperationNamesRule,
      LoneAnonymousOperationRule,
      SingleFieldSubscriptionsRule,
      KnownTypeNamesRule,
      FragmentsOnCompositeTypesRule,
      VariablesAreInputTypesRule,
      ScalarLeafsRule,
      FieldsOnCorrectTypeRule,
      UniqueFragmentNamesRule,
      KnownFragmentNamesRule,
      NoUnusedFragmentsRule,
      PossibleFragmentSpreadsRule,
      NoFragmentCyclesRule,
      UniqueVariableNamesRule,
      NoUndefinedVariablesRule,
      NoUnusedVariablesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      KnownArgumentNamesRule,
      UniqueArgumentNamesRule,
      ValuesOfCorrectTypeRule,
      ProvidedRequiredArgumentsRule,
      VariablesInAllowedPositionRule,
      OverlappingFieldsCanBeMergedRule,
      UniqueInputFieldNamesRule
    ]);
    specifiedSDLRules = Object.freeze([
      LoneSchemaDefinitionRule,
      UniqueOperationTypesRule,
      UniqueTypeNamesRule,
      UniqueEnumValueNamesRule,
      UniqueFieldDefinitionNamesRule,
      UniqueArgumentDefinitionNamesRule,
      UniqueDirectiveNamesRule,
      KnownTypeNamesRule,
      KnownDirectivesRule,
      UniqueDirectivesPerLocationRule,
      PossibleTypeExtensionsRule,
      KnownArgumentNamesOnDirectivesRule,
      UniqueArgumentNamesRule,
      UniqueInputFieldNamesRule,
      ProvidedRequiredArgumentsOnDirectivesRule
    ]);
  }
});

// node_modules/graphql/validation/ValidationContext.mjs
var ASTValidationContext, SDLValidationContext, ValidationContext;
var init_ValidationContext = __esm({
  "node_modules/graphql/validation/ValidationContext.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
    init_visitor();
    init_TypeInfo();
    ASTValidationContext = class {
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error) {
        this._onError(error);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    SDLValidationContext = class extends ASTValidationContext {
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    ValidationContext = class extends ASTValidationContext {
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new TypeInfo(this._schema);
          visit(
            node,
            visitWithTypeInfo(typeInfo, {
              VariableDefinition: () => false,
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
  }
});

// node_modules/graphql/validation/validate.mjs
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors.length >= maxErrors) {
        errors.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors.push(error);
    }
  );
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors = validateSDL(documentAST, schema);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var init_validate2 = __esm({
  "node_modules/graphql/validation/validate.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_GraphQLError();
    init_visitor();
    init_validate();
    init_TypeInfo();
    init_specifiedRules();
    init_ValidationContext();
  }
});

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
var init_memoize3 = __esm({
  "node_modules/graphql/jsutils/memoize3.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/promiseForObject.mjs
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i];
    }
    return resolvedObject;
  });
}
var init_promiseForObject = __esm({
  "node_modules/graphql/jsutils/promiseForObject.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/jsutils/promiseReduce.mjs
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
var init_promiseReduce = __esm({
  "node_modules/graphql/jsutils/promiseReduce.mjs"() {
    init_process();
    init_buffer();
    init_isPromise();
  }
});

// node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
var NonErrorThrown;
var init_toError = __esm({
  "node_modules/graphql/jsutils/toError.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    NonErrorThrown = class extends Error {
      constructor(thrownValue) {
        super("Unexpected error value: " + inspect(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}
var init_locatedError = __esm({
  "node_modules/graphql/error/locatedError.mjs"() {
    init_process();
    init_buffer();
    init_toError();
    init_GraphQLError();
  }
});

// node_modules/graphql/execution/execute.mjs
function execute(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema, document: document2, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result = executeOperation(exeContext, operation, rootValue);
    if (isPromise(result)) {
      return result.then(
        (data) => buildResponse(data, exeContext.errors),
        (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      );
    }
    return buildResponse(result, exeContext.errors);
  } catch (error) {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result = execute(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function buildResponse(data, errors) {
  return errors.length === 0 ? {
    data
  } : {
    errors,
    data
  };
}
function assertValidExecutionArguments(schema, document2, rawVariableValues) {
  document2 || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(
    false,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
      default:
    }
  }
  if (!operation) {
    if (operationName != null) {
      return [new GraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(
    schema,
    variableDefinitions,
    rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
    {
      maxErrors: 50
    }
  );
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(
      `Schema is not configured to execute ${operation.operation} operation.`,
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    rootType,
    operation.selectionSet
  );
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.MUTATION:
      return executeFieldsSerially(
        exeContext,
        rootType,
        rootValue,
        path,
        rootFields
      );
    case OperationTypeNode.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(
    fields.entries(),
    (results, [responseName, fieldNodes]) => {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result === void 0) {
        return results;
      }
      if (isPromise(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  for (const [responseName, fieldNodes] of fields.entries()) {
    const fieldPath = addPath(path, responseName, parentType.name);
    const result = executeField(
      exeContext,
      parentType,
      sourceValue,
      fieldNodes,
      fieldPath
    );
    if (result !== void 0) {
      results[responseName] = result;
      if (isPromise(result)) {
        containsPromise = true;
      }
    }
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    parentType,
    path
  );
  try {
    const args = getArgumentValues(
      fieldDef,
      fieldNodes[0],
      exeContext.variableValues
    );
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then(
        (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
      );
    } else {
      completed = completeValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  exeContext.errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(
      exeContext,
      returnType.ofType,
      fieldNodes,
      info,
      path,
      result
    );
    if (completed === null) {
      throw new Error(
        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
      );
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  invariant(
    false,
    "Cannot complete value of unexpected output type: " + inspect(returnType)
  );
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (!isIterableObject(result)) {
    throw new GraphQLError(
      `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
    );
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result, (item, index) => {
    const itemPath = addPath(path, index, void 0);
    try {
      let completedItem;
      if (isPromise(item)) {
        completedItem = item.then(
          (resolved) => completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            resolved
          )
        );
      } else {
        completedItem = completeValue(
          exeContext,
          itemType,
          fieldNodes,
          info,
          itemPath,
          item
        );
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error = locatedError(
            rawError,
            fieldNodes,
            pathToArray(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
  const serializedResult = returnType.serialize(result);
  if (serializedResult == null) {
    throw new Error(
      `Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`
    );
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(
      (resolvedRuntimeType) => completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          resolvedRuntimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      )
    );
  }
  return completeObjectValue(
    exeContext,
    ensureValidRuntimeType(
      runtimeType,
      exeContext,
      returnType,
      fieldNodes,
      info,
      result
    ),
    fieldNodes,
    info,
    path,
    result
  );
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      fieldNodes
    );
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`
    );
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(
      `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  const subFieldNodes = collectSubfields2(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return executeFields(
          exeContext,
          returnType,
          result,
          path,
          subFieldNodes
        );
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError(
    `Expected value of type "${returnType.name}" but got: ${inspect(result)}.`,
    {
      nodes: fieldNodes
    }
  );
}
function getFieldDef2(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields2, defaultTypeResolver, defaultFieldResolver;
var init_execute = __esm({
  "node_modules/graphql/execution/execute.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_invariant();
    init_isIterableObject();
    init_isObjectLike();
    init_isPromise();
    init_memoize3();
    init_Path();
    init_promiseForObject();
    init_promiseReduce();
    init_GraphQLError();
    init_locatedError();
    init_ast();
    init_kinds();
    init_definition();
    init_introspection();
    init_validate();
    init_collectFields();
    init_values();
    collectSubfields2 = memoize3(
      (exeContext, returnType, fieldNodes) => collectSubfields(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    defaultTypeResolver = function(value, contextValue, info, abstractType) {
      if (isObjectLike(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
          const isTypeOfResult = type.isTypeOf(value, contextValue, info);
          if (isPromise(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    };
    defaultFieldResolver = function(source, args, contextValue, info) {
      if (isObjectLike(source) || typeof source === "function") {
        const property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
  }
});

// node_modules/graphql/graphql.mjs
function graphql(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result = graphqlImpl(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document2;
  try {
    document2 = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document2);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
var init_graphql = __esm({
  "node_modules/graphql/graphql.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_isPromise();
    init_parser();
    init_validate();
    init_validate2();
    init_execute();
  }
});

// node_modules/graphql/type/index.mjs
var init_type = __esm({
  "node_modules/graphql/type/index.mjs"() {
    init_process();
    init_buffer();
    init_schema();
    init_definition();
    init_directives();
    init_scalars();
    init_introspection();
    init_validate();
    init_assertName();
  }
});

// node_modules/graphql/language/index.mjs
var init_language = __esm({
  "node_modules/graphql/language/index.mjs"() {
    init_process();
    init_buffer();
    init_source();
    init_location();
    init_printLocation();
    init_kinds();
    init_tokenKind();
    init_lexer();
    init_parser();
    init_printer();
    init_visitor();
    init_ast();
    init_predicates();
    init_directiveLocation();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.mjs
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
var init_isAsyncIterable = __esm({
  "node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/execution/mapAsyncIterator.mjs
function mapAsyncIterator(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return {
        value: await callback(result.value),
        done: false
      };
    } catch (error) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e) {
        }
      }
      throw error;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error));
      }
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var init_mapAsyncIterator = __esm({
  "node_modules/graphql/execution/mapAsyncIterator.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/execution/subscribe.mjs
async function subscribe(args) {
  arguments.length < 2 || devAssert(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const resultOrStream = await createSourceEventStream(args);
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute({ ...args, rootValue: payload });
  return mapAsyncIterator(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg && "document" in firstArg) {
    return firstArg;
  }
  return {
    schema: firstArg,
    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    subscribeFieldResolver: args[6]
  };
}
async function createSourceEventStream(...rawArgs) {
  const args = toNormalizedArgs(rawArgs);
  const { schema, document: document2, variableValues } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable(eventStream)) {
      throw new Error(
        `Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`
      );
    }
    return eventStream;
  } catch (error) {
    if (error instanceof GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError(
      "Schema is not configured to execute subscription operation.",
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    schema,
    fragments,
    variableValues,
    rootType,
    operation.selectionSet
  );
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef2(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(
      `The subscription field "${fieldName}" is not defined.`,
      {
        nodes: fieldNodes
      }
    );
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    rootType,
    path
  );
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray(path));
  }
}
var init_subscribe = __esm({
  "node_modules/graphql/execution/subscribe.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_isAsyncIterable();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_collectFields();
    init_execute();
    init_mapAsyncIterator();
    init_values();
  }
});

// node_modules/graphql/execution/index.mjs
var init_execution = __esm({
  "node_modules/graphql/execution/index.mjs"() {
    init_process();
    init_buffer();
    init_Path();
    init_execute();
    init_subscribe();
    init_values();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
function NoDeprecatedCustomRule(context) {
  return {
    Field(node) {
      const fieldDef = context.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context.getParentType();
        parentType != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    },
    Argument(node) {
      const argDef = context.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        } else {
          const parentType = context.getParentType();
          const fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(
            new GraphQLError(
              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant(false);
        context.reportError(
          new GraphQLError(
            `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoDeprecatedCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
    init_process();
    init_buffer();
    init_invariant();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field(node) {
      const type = getNamedType(context.getType());
      if (type && isIntrospectionType(type)) {
        context.reportError(
          new GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var init_NoSchemaIntrospectionCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_definition();
    init_introspection();
  }
});

// node_modules/graphql/validation/index.mjs
var init_validation = __esm({
  "node_modules/graphql/validation/index.mjs"() {
    init_process();
    init_buffer();
    init_validate2();
    init_ValidationContext();
    init_specifiedRules();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueArgumentDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    init_NoDeprecatedCustomRule();
    init_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/index.mjs
var init_error = __esm({
  "node_modules/graphql/error/index.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
    init_syntaxError();
    init_locatedError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.mjs
function getIntrospectionQuery(options) {
  const optionsWithDefault = {
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false,
    ...options
  };
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
var init_getIntrospectionQuery = __esm({
  "node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
    init_process();
    init_buffer();
  }
});

// node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}
var init_getOperationAST = __esm({
  "node_modules/graphql/utilities/getOperationAST.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
  }
});

// node_modules/graphql/utilities/getOperationRootType.mjs
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError(
        "Schema does not define the required query root type.",
        {
          nodes: operation
        }
      );
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", {
        nodes: operation
      });
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", {
        nodes: operation
      });
    }
    return subscriptionType;
  }
  throw new GraphQLError(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: operation
    }
  );
}
var init_getOperationRootType = __esm({
  "node_modules/graphql/utilities/getOperationRootType.mjs"() {
    init_process();
    init_buffer();
    init_GraphQLError();
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.mjs
function introspectionFromSchema(schema, options) {
  const optionsWithDefaults = {
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true,
    ...options
  };
  const document2 = parse(getIntrospectionQuery(optionsWithDefaults));
  const result = executeSync({
    schema,
    document: document2
  });
  !result.errors && result.data || invariant(false);
  return result.data;
}
var init_introspectionFromSchema = __esm({
  "node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
    init_process();
    init_buffer();
    init_invariant();
    init_parser();
    init_execute();
    init_getIntrospectionQuery();
  }
});

// node_modules/graphql/utilities/buildClientSchema.mjs
function buildClientSchema(introspection, options) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
    false,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
      introspection
    )}.`
  );
  const schemaIntrospection = introspection.__schema;
  const typeMap = keyValMap(
    schemaIntrospection.types,
    (typeIntrospection) => typeIntrospection.name,
    (typeIntrospection) => buildType(typeIntrospection)
  );
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
    }
    const type = typeMap[typeName];
    if (!type) {
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    }
    return type;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type) {
    if (type != null && type.name != null && type.kind != null) {
      switch (type.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type);
        case TypeKind.OBJECT:
          return buildObjectDef(type);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type);
        case TypeKind.UNION:
          return buildUnionDef(type);
        case TypeKind.ENUM:
          return buildEnumDef(type);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }
    const typeStr = inspect(type);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
    );
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect(implementingIntrospection);
      throw new Error(
        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
      );
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect(unionIntrospection);
      throw new Error(
        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
      );
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect(enumIntrospection);
      throw new Error(
        `Introspection result missing enumValues: ${enumIntrospectionStr}.`
      );
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(
        enumIntrospection.enumValues,
        (valueIntrospection) => valueIntrospection.name,
        (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        })
      )
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
      throw new Error(
        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
      );
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(
        `Introspection result missing fields: ${inspect(typeIntrospection)}.`
      );
    }
    return keyValMap(
      typeIntrospection.fields,
      (fieldIntrospection) => fieldIntrospection.name,
      buildField
    );
  }
  function buildField(fieldIntrospection) {
    const type = getType(fieldIntrospection.type);
    if (!isOutputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${typeStr}.`
      );
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect(fieldIntrospection);
      throw new Error(
        `Introspection result missing field args: ${fieldIntrospectionStr}.`
      );
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(
      inputValueIntrospections,
      (inputValue) => inputValue.name,
      buildInputValue
    );
  }
  function buildInputValue(inputValueIntrospection) {
    const type = getType(inputValueIntrospection.type);
    if (!isInputType(type)) {
      const typeStr = inspect(type);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${typeStr}.`
      );
    }
    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
    return {
      description: inputValueIntrospection.description,
      type,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive args: ${directiveIntrospectionStr}.`
      );
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
      );
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
var init_buildClientSchema = __esm({
  "node_modules/graphql/utilities/buildClientSchema.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_isObjectLike();
    init_keyValMap();
    init_parser();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_valueFromAST();
  }
});

// node_modules/graphql/utilities/extendSchema.mjs
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config2 = directive.toConfig();
    return new GraphQLDirective({
      ...config2,
      args: mapValue(config2.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config2,
      fields: () => ({
        ...mapValue(config2.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config2,
      values: { ...config2.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config2.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config2,
      specifiedByURL,
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config2,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config2.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config2,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config2.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config2 = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config2,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
    if (type === void 0) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
    }
  }
}
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
var stdTypeMap;
var init_extendSchema = __esm({
  "node_modules/graphql/utilities/extendSchema.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_inspect();
    init_invariant();
    init_keyMap();
    init_mapValue();
    init_kinds();
    init_predicates();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_schema();
    init_validate2();
    init_values();
    init_valueFromAST();
    stdTypeMap = keyMap(
      [...specifiedScalarTypes, ...introspectionTypes],
      (type) => type.name
    );
  }
});

// node_modules/graphql/utilities/buildASTSchema.mjs
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config2 = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config2.astNode == null) {
    for (const type of config2.types) {
      switch (type.name) {
        case "Query":
          config2.query = type;
          break;
        case "Mutation":
          config2.mutation = type;
          break;
        case "Subscription":
          config2.subscription = type;
          break;
      }
    }
  }
  const directives = [
    ...config2.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config2.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config2, directives });
}
function buildSchema(source, options) {
  const document2 = parse(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document2, {
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
var init_buildASTSchema = __esm({
  "node_modules/graphql/utilities/buildASTSchema.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_kinds();
    init_parser();
    init_directives();
    init_schema();
    init_validate2();
    init_extendSchema();
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config2 = directive.toConfig();
    return new GraphQLDirective({
      ...config2,
      locations: sortBy(config2.locations, (x) => x),
      args: sortArgs(config2.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config2 = type.toConfig();
      return new GraphQLObjectType({
        ...config2,
        interfaces: () => sortTypes(config2.interfaces),
        fields: () => sortFields2(config2.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config2 = type.toConfig();
      return new GraphQLInterfaceType({
        ...config2,
        interfaces: () => sortTypes(config2.interfaces),
        fields: () => sortFields2(config2.fields)
      });
    }
    if (isUnionType(type)) {
      const config2 = type.toConfig();
      return new GraphQLUnionType({
        ...config2,
        types: () => sortTypes(config2.types)
      });
    }
    if (isEnumType(type)) {
      const config2 = type.toConfig();
      return new GraphQLEnumType({
        ...config2,
        values: sortObjMap(config2.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config2 = type.toConfig();
      return new GraphQLInputObjectType({
        ...config2,
        fields: () => sortInputFields(config2.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
var init_lexicographicSortSchema = __esm({
  "node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_keyValMap();
    init_naturalCompare();
    init_definition();
    init_directives();
    init_introspection();
    init_schema();
  }
});

// node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema) {
  return printFilteredSchema(
    schema,
    (n) => !isSpecifiedDirective(n),
    isDefinedType
  );
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function printScalar(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
}
function printObject(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
  const values = type.getValues().map(
    (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
  );
  return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
  );
  return printDescription(type) + `input ${type.name}` + printBlock(fields);
}
function printFields(type) {
  const fields = Object.values(type.getFields()).map(
    (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
  );
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(
    (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
  ).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
var init_printSchema = __esm({
  "node_modules/graphql/utilities/printSchema.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_blockString();
    init_kinds();
    init_printer();
    init_definition();
    init_directives();
    init_introspection();
    init_scalars();
    init_astFromValue();
  }
});

// node_modules/graphql/utilities/concatAST.mjs
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
var init_concatAST = __esm({
  "node_modules/graphql/utilities/concatAST.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
  }
});

// node_modules/graphql/utilities/separateOperations.mjs
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet
        );
        break;
      default:
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
      )
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
var init_separateOperations = __esm({
  "node_modules/graphql/utilities/separateOperations.mjs"() {
    init_process();
    init_buffer();
    init_kinds();
    init_visitor();
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.mjs
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
var init_stripIgnoredCharacters = __esm({
  "node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
    init_process();
    init_buffer();
    init_blockString();
    init_lexer();
    init_source();
    init_tokenKind();
  }
});

// node_modules/graphql/utilities/assertValidName.mjs
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(
      `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
var init_assertValidName = __esm({
  "node_modules/graphql/utilities/assertValidName.mjs"() {
    init_process();
    init_buffer();
    init_devAssert();
    init_GraphQLError();
    init_assertName();
  }
});

// node_modules/graphql/utilities/findBreakingChanges.mjs
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in BreakingChangeType
  );
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in DangerousChangeType
  );
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(
    oldSchema.getDirectives(),
    newSchema.getDirectives()
  );
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location of oldDirective.locations) {
      if (!newDirective.locations.includes(location)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(
    Object.values(oldSchema.getTypeMap()),
    Object.values(newSchema.getTypeMap())
  );
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldArg.type,
      newArg.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return (
      // if they're both lists, make sure the underlying types are compatible
      isListType(newType) && isChangeSafeForObjectOrInterfaceField(
        oldType.ofType,
        newType.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return (
    // if they're both named types, see if their names are equivalent
    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return (
      // if they're both non-null, make sure the underlying types are
      // compatible
      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
        oldType.ofType,
        newType.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
  if (isScalarType(type)) {
    return "a Scalar type";
  }
  if (isObjectType(type)) {
    return "an Object type";
  }
  if (isInterfaceType(type)) {
    return "an Interface type";
  }
  if (isUnionType(type)) {
    return "a Union type";
  }
  if (isEnumType(type)) {
    return "an Enum type";
  }
  if (isInputObjectType(type)) {
    return "an Input type";
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function stringifyValue(value, type) {
  const ast = astFromValue(value, type);
  ast != null || invariant(false);
  return print(sortValueNode(ast));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name }) => name);
  const newMap = keyMap(newArray, ({ name }) => name);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var BreakingChangeType, DangerousChangeType;
var init_findBreakingChanges = __esm({
  "node_modules/graphql/utilities/findBreakingChanges.mjs"() {
    init_process();
    init_buffer();
    init_inspect();
    init_invariant();
    init_keyMap();
    init_printer();
    init_definition();
    init_scalars();
    init_astFromValue();
    init_sortValueNode();
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(BreakingChangeType || (BreakingChangeType = {}));
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(DangerousChangeType || (DangerousChangeType = {}));
  }
});

// node_modules/graphql/utilities/index.mjs
var init_utilities = __esm({
  "node_modules/graphql/utilities/index.mjs"() {
    init_process();
    init_buffer();
    init_getIntrospectionQuery();
    init_getOperationAST();
    init_getOperationRootType();
    init_introspectionFromSchema();
    init_buildClientSchema();
    init_buildASTSchema();
    init_extendSchema();
    init_lexicographicSortSchema();
    init_printSchema();
    init_typeFromAST();
    init_valueFromAST();
    init_valueFromASTUntyped();
    init_astFromValue();
    init_TypeInfo();
    init_coerceInputValue();
    init_concatAST();
    init_separateOperations();
    init_stripIgnoredCharacters();
    init_typeComparators();
    init_assertValidName();
    init_findBreakingChanges();
  }
});

// node_modules/graphql/index.mjs
var graphql_exports = {};
__export(graphql_exports, {
  BREAK: () => BREAK,
  BreakingChangeType: () => BreakingChangeType,
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  DangerousChangeType: () => DangerousChangeType,
  DirectiveLocation: () => DirectiveLocation,
  ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
  GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLError: () => GraphQLError,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  Kind: () => Kind,
  KnownArgumentNamesRule: () => KnownArgumentNamesRule,
  KnownDirectivesRule: () => KnownDirectivesRule,
  KnownFragmentNamesRule: () => KnownFragmentNamesRule,
  KnownTypeNamesRule: () => KnownTypeNamesRule,
  Lexer: () => Lexer,
  Location: () => Location,
  LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
  NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
  NoFragmentCyclesRule: () => NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
  NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
  NoUnusedVariablesRule: () => NoUnusedVariablesRule,
  OperationTypeNode: () => OperationTypeNode,
  OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
  ScalarLeafsRule: () => ScalarLeafsRule,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TypeInfo: () => TypeInfo,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  UniqueArgumentDefinitionNamesRule: () => UniqueArgumentDefinitionNamesRule,
  UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
  UniqueOperationNamesRule: () => UniqueOperationNamesRule,
  UniqueOperationTypesRule: () => UniqueOperationTypesRule,
  UniqueTypeNamesRule: () => UniqueTypeNamesRule,
  UniqueVariableNamesRule: () => UniqueVariableNamesRule,
  ValidationContext: () => ValidationContext,
  ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertEnumValueName: () => assertEnumValueName,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertName: () => assertName,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidName: () => assertValidName,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  doTypesOverlap: () => doTypesOverlap,
  execute: () => execute,
  executeSync: () => executeSync,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  formatError: () => formatError,
  getArgumentValues: () => getArgumentValues,
  getDirectiveValues: () => getDirectiveValues,
  getEnterLeaveForKind: () => getEnterLeaveForKind,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getLocation: () => getLocation,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  getVariableValues: () => getVariableValues,
  getVisitFn: () => getVisitFn,
  graphql: () => graphql,
  graphqlSync: () => graphqlSync,
  introspectionFromSchema: () => introspectionFromSchema,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isConstValueNode: () => isConstValueNode,
  isDefinitionNode: () => isDefinitionNode,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isEqualType: () => isEqualType,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSelectionNode: () => isSelectionNode,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isUnionType: () => isUnionType,
  isValidNameError: () => isValidNameError,
  isValueNode: () => isValueNode,
  isWrappingType: () => isWrappingType,
  lexicographicSortSchema: () => lexicographicSortSchema,
  locatedError: () => locatedError,
  parse: () => parse,
  parseConstValue: () => parseConstValue,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printError: () => printError,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printLocation: () => printLocation,
  printSchema: () => printSchema,
  printSourceLocation: () => printSourceLocation,
  printType: () => printType,
  resolveObjMapThunk: () => resolveObjMapThunk,
  resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
  responsePathAsArray: () => pathToArray,
  separateOperations: () => separateOperations,
  specifiedDirectives: () => specifiedDirectives,
  specifiedRules: () => specifiedRules,
  specifiedScalarTypes: () => specifiedScalarTypes,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  subscribe: () => subscribe,
  syntaxError: () => syntaxError,
  typeFromAST: () => typeFromAST,
  validate: () => validate,
  validateSchema: () => validateSchema,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  version: () => version,
  versionInfo: () => versionInfo,
  visit: () => visit,
  visitInParallel: () => visitInParallel,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var init_graphql2 = __esm({
  "node_modules/graphql/index.mjs"() {
    init_process();
    init_buffer();
    init_version();
    init_graphql();
    init_type();
    init_language();
    init_execution();
    init_validation();
    init_error();
    init_utilities();
  }
});

// node_modules/@graphql-tools/utils/cjs/loaders.js
var require_loaders = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/loaders.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/helpers.js
var require_helpers = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/helpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertSome = exports.isSome = exports.compareNodes = exports.nodeToString = exports.compareStrings = exports.isValidPath = exports.isDocumentString = exports.asArray = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
    exports.asArray = asArray;
    var invalidDocRegex = /\.[a-z0-9]+$/i;
    function isDocumentString(str) {
      if (typeof str !== "string") {
        return false;
      }
      if (invalidDocRegex.test(str)) {
        return false;
      }
      try {
        (0, graphql_1.parse)(str);
        return true;
      } catch (e) {
      }
      return false;
    }
    exports.isDocumentString = isDocumentString;
    var invalidPathRegex = /[‘“!%^<=>`]/;
    function isValidPath(str) {
      return typeof str === "string" && !invalidPathRegex.test(str);
    }
    exports.isValidPath = isValidPath;
    function compareStrings(a, b) {
      if (String(a) < String(b)) {
        return -1;
      }
      if (String(a) > String(b)) {
        return 1;
      }
      return 0;
    }
    exports.compareStrings = compareStrings;
    function nodeToString(a) {
      var _a, _b;
      let name;
      if ("alias" in a) {
        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
      }
      if (name == null && "name" in a) {
        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
      }
      if (name == null) {
        name = a.kind;
      }
      return name;
    }
    exports.nodeToString = nodeToString;
    function compareNodes(a, b, customFn) {
      const aStr = nodeToString(a);
      const bStr = nodeToString(b);
      if (typeof customFn === "function") {
        return customFn(aStr, bStr);
      }
      return compareStrings(aStr, bStr);
    }
    exports.compareNodes = compareNodes;
    function isSome(input) {
      return input != null;
    }
    exports.isSome = isSome;
    function assertSome(input, message = "Value should be something") {
      if (input == null) {
        throw new Error(message);
      }
    }
    exports.assertSome = assertSome;
  }
});

// node_modules/@graphql-tools/utils/cjs/jsutils.js
var require_jsutils = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/jsutils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasOwnProperty = exports.promiseReduce = exports.isPromise = exports.isObjectLike = exports.isIterableObject = void 0;
    function isIterableObject2(value) {
      return value != null && typeof value === "object" && Symbol.iterator in value;
    }
    exports.isIterableObject = isIterableObject2;
    function isObjectLike2(value) {
      return typeof value === "object" && value !== null;
    }
    exports.isObjectLike = isObjectLike2;
    function isPromise2(value) {
      return isObjectLike2(value) && typeof value["then"] === "function";
    }
    exports.isPromise = isPromise2;
    function promiseReduce2(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = isPromise2(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    exports.promiseReduce = promiseReduce2;
    function hasOwnProperty3(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    exports.hasOwnProperty = hasOwnProperty3;
  }
});

// node_modules/@graphql-tools/utils/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.relocatedError = exports.createGraphQLError = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createGraphQLError(message, options) {
      if (graphql_1.versionInfo.major >= 17) {
        return new graphql_1.GraphQLError(message, options);
      }
      return new graphql_1.GraphQLError(message, options === null || options === void 0 ? void 0 : options.nodes, options === null || options === void 0 ? void 0 : options.source, options === null || options === void 0 ? void 0 : options.positions, options === null || options === void 0 ? void 0 : options.path, options === null || options === void 0 ? void 0 : options.originalError, options === null || options === void 0 ? void 0 : options.extensions);
    }
    exports.createGraphQLError = createGraphQLError;
    function relocatedError(originalError, path) {
      return createGraphQLError(originalError.message, {
        nodes: originalError.nodes,
        source: originalError.source,
        positions: originalError.positions,
        path: path == null ? originalError.path : path,
        originalError,
        extensions: originalError.extensions
      });
    }
    exports.relocatedError = relocatedError;
  }
});

// node_modules/@graphql-tools/utils/cjs/AggregateError.js
var require_AggregateError = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AggregateError.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAggregateError = exports.AggregateError = void 0;
    var AggregateErrorImpl;
    exports.AggregateError = AggregateErrorImpl;
    if (typeof AggregateError === "undefined") {
      class AggregateErrorClass extends Error {
        constructor(errors, message = "") {
          super(message);
          this.errors = errors;
          this.name = "AggregateError";
          Error.captureStackTrace(this, AggregateErrorClass);
        }
      }
      exports.AggregateError = AggregateErrorImpl = function(errors, message) {
        return new AggregateErrorClass(errors, message);
      };
    } else {
      exports.AggregateError = AggregateErrorImpl = AggregateError;
    }
    function isAggregateError(error) {
      return "errors" in error && Array.isArray(error["errors"]);
    }
    exports.isAggregateError = isAggregateError;
  }
});

// node_modules/@graphql-tools/utils/cjs/inspect.js
var require_inspect = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/inspect.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inspect = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var AggregateError_js_1 = require_AggregateError();
    var MAX_RECURSIVE_DEPTH2 = 3;
    function inspect4(value) {
      return formatValue3(value, []);
    }
    exports.inspect = inspect4;
    function formatValue3(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatError3(value) {
      if (value instanceof graphql_1.GraphQLError) {
        return value.toString();
      }
      return `${value.name}: ${value.message};
 ${value.stack}`;
    }
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (value instanceof Error) {
        if ((0, AggregateError_js_1.isAggregateError)(value)) {
          return formatError3(value) + "\n" + formatArray3(value.errors, previouslySeenValues);
        }
        return formatError3(value);
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue3(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray3(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(([key, value]) => key + ": " + formatValue3(value, seenValues));
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray3(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = array.length;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue3(array[i], seenValues));
      }
      return "[" + items.join(", ") + "]";
    }
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
var require_getArgumentValues = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArgumentValues = void 0;
    var jsutils_js_1 = require_jsutils();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var errors_js_1 = require_errors();
    var inspect_js_1 = require_inspect();
    function getArgumentValues2(def, node, variableValues = {}) {
      var _a;
      const coercedValues = {};
      const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];
      const argNodeMap = argumentNodes.reduce((prev, arg) => ({
        ...prev,
        [arg.name.value]: arg
      }), {});
      for (const { name, type: argType, defaultValue } of def.args) {
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (defaultValue !== void 0) {
            coercedValues[name] = defaultValue;
          } else if ((0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
              nodes: [node]
            });
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === graphql_1.Kind.NULL;
        if (valueNode.kind === graphql_1.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
            if (defaultValue !== void 0) {
              coercedValues[name] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                nodes: [valueNode]
              });
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, graphql_1.isNonNullType)(argType)) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
            nodes: [valueNode]
          });
        }
        const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
        if (coercedValue === void 0) {
          throw (0, errors_js_1.createGraphQLError)(`Argument "${name}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
            nodes: [valueNode]
          });
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    exports.getArgumentValues = getArgumentValues2;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-directives.js
var require_get_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDirective = exports.getDirectives = exports.getDirectiveInExtensions = exports.getDirectivesInExtensions = void 0;
    var getArgumentValues_js_1 = require_getArgumentValues();
    function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
      return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
    }
    exports.getDirectivesInExtensions = getDirectivesInExtensions;
    function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
      const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
      if (!directiveInExtensions.length) {
        return void 0;
      }
      return directiveInExtensions.map((directive) => {
        var _a;
        return (_a = directive.args) !== null && _a !== void 0 ? _a : {};
      });
    }
    function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
      if (directivesInExtensions === void 0) {
        return void 0;
      }
      if (Array.isArray(directivesInExtensions)) {
        return _getDirectiveInExtensions(directivesInExtensions, directiveName);
      }
      const reformattedDirectivesInExtensions = [];
      for (const [name, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
        if (Array.isArray(argsOrArrayOfArgs)) {
          for (const args of argsOrArrayOfArgs) {
            reformattedDirectivesInExtensions.push({ name, args });
          }
        } else {
          reformattedDirectivesInExtensions.push({ name, args: argsOrArrayOfArgs });
        }
      }
      return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
    }
    exports.getDirectiveInExtensions = getDirectiveInExtensions;
    function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
      const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
      if (directivesInExtensions != null && directivesInExtensions.length > 0) {
        return directivesInExtensions;
      }
      const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
      const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
        schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
        return schemaDirectiveMap2;
      }, {});
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
            if (schemaDirective) {
              result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
            }
          }
        }
      }
      return result;
    }
    exports.getDirectives = getDirectives;
    function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
      const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
      if (directiveInExtensions != null) {
        return directiveInExtensions;
      }
      const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
      if (schemaDirective == null) {
        return void 0;
      }
      let astNodes = [];
      if (node.astNode) {
        astNodes.push(node.astNode);
      }
      if ("extensionASTNodes" in node && node.extensionASTNodes) {
        astNodes = [...astNodes, ...node.extensionASTNodes];
      }
      const result = [];
      for (const astNode of astNodes) {
        if (astNode.directives) {
          for (const directiveNode of astNode.directives) {
            if (directiveNode.name.value === directiveName) {
              result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
            }
          }
        }
      }
      if (!result.length) {
        return void 0;
      }
      return result;
    }
    exports.getDirective = getDirective;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
var require_get_fields_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFieldsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getFieldsWithDirectives(documentNode, options = {}) {
      const result = {};
      let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
      if (options.includeInputTypes) {
        selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
      }
      const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
      for (const type of allTypes) {
        const typeName = type.name.value;
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          if (field.directives && field.directives.length > 0) {
            const fieldName = field.name.value;
            const key = `${typeName}.${fieldName}`;
            const directives = field.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value) }), {})
            }));
            result[key] = directives;
          }
        }
      }
      return result;
    }
    exports.getFieldsWithDirectives = getFieldsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js
var require_get_arguments_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArgumentsWithDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isTypeWithFields(t) {
      return t.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
    }
    function getArgumentsWithDirectives(documentNode) {
      var _a;
      const result = {};
      const allTypes = documentNode.definitions.filter(isTypeWithFields);
      for (const type of allTypes) {
        if (type.fields == null) {
          continue;
        }
        for (const field of type.fields) {
          const argsWithDirectives = (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.filter((arg) => {
            var _a2;
            return (_a2 = arg.directives) === null || _a2 === void 0 ? void 0 : _a2.length;
          });
          if (!(argsWithDirectives === null || argsWithDirectives === void 0 ? void 0 : argsWithDirectives.length)) {
            continue;
          }
          const typeFieldResult = result[`${type.name.value}.${field.name.value}`] = {};
          for (const arg of argsWithDirectives) {
            const directives = arg.directives.map((d) => ({
              name: d.name.value,
              args: (d.arguments || []).reduce((prev, dArg) => ({ ...prev, [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value) }), {})
            }));
            typeFieldResult[arg.name.value] = directives;
          }
        }
      }
      return result;
    }
    exports.getArgumentsWithDirectives = getArgumentsWithDirectives;
  }
});

// node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
var require_get_implementing_types = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getImplementingTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getImplementingTypes(interfaceName, schema) {
      const allTypesMap = schema.getTypeMap();
      const result = [];
      for (const graphqlTypeName in allTypesMap) {
        const graphqlType = allTypesMap[graphqlTypeName];
        if ((0, graphql_1.isObjectType)(graphqlType)) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.find((int) => int.name === interfaceName)) {
            result.push(graphqlType.name);
          }
        }
      }
      return result;
    }
    exports.getImplementingTypes = getImplementingTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromType.js
var require_astFromType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.astFromType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var inspect_js_1 = require_inspect();
    function astFromType(type) {
      if ((0, graphql_1.isNonNullType)(type)) {
        const innerType = astFromType(type.ofType);
        if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
          throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
        }
        return {
          kind: graphql_1.Kind.NON_NULL_TYPE,
          type: innerType
        };
      } else if ((0, graphql_1.isListType)(type)) {
        return {
          kind: graphql_1.Kind.LIST_TYPE,
          type: astFromType(type.ofType)
        };
      }
      return {
        kind: graphql_1.Kind.NAMED_TYPE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        }
      };
    }
    exports.astFromType = astFromType;
  }
});

// node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
var require_astFromValueUntyped = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.astFromValueUntyped = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function astFromValueUntyped(value) {
      if (value === null) {
        return { kind: graphql_1.Kind.NULL };
      }
      if (value === void 0) {
        return null;
      }
      if (Array.isArray(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValueUntyped(item);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return { kind: graphql_1.Kind.LIST, values: valuesNodes };
      }
      if (typeof value === "object") {
        const fieldNodes = [];
        for (const fieldName in value) {
          const fieldValue = value[fieldName];
          const ast = astFromValueUntyped(fieldValue);
          if (ast) {
            fieldNodes.push({
              kind: graphql_1.Kind.OBJECT_FIELD,
              name: { kind: graphql_1.Kind.NAME, value: fieldName },
              value: ast
            });
          }
        }
        return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
      }
      if (typeof value === "boolean") {
        return { kind: graphql_1.Kind.BOOLEAN, value };
      }
      if (typeof value === "number" && isFinite(value)) {
        const stringNum = String(value);
        return integerStringRegExp2.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
      }
      if (typeof value === "string") {
        return { kind: graphql_1.Kind.STRING, value };
      }
      throw new TypeError(`Cannot convert value to AST: ${value}.`);
    }
    exports.astFromValueUntyped = astFromValueUntyped;
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/@graphql-tools/utils/cjs/memoize.js
var require_memoize = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/memoize.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.memoize2of5 = exports.memoize2of4 = exports.memoize5 = exports.memoize4 = exports.memoize3 = exports.memoize2 = exports.memoize1 = void 0;
    function memoize1(fn) {
      const memoize1cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1) {
        const cachedValue = memoize1cache.get(a1);
        if (cachedValue === void 0) {
          const newValue = fn(a1);
          memoize1cache.set(a1, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize1 = memoize1;
    function memoize2(fn) {
      const memoize2cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2) {
        let cache2 = memoize2cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2cache.set(a1, cache2);
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize2 = memoize2;
    function memoize32(fn) {
      const memoize3Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3) {
        let cache2 = memoize3Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize3Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const newValue = fn(a1, a2, a3);
          cache32.set(a3, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        const cachedValue = cache3.get(a3);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3);
          cache3.set(a3, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize3 = memoize32;
    function memoize4(fn) {
      const memoize4Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize4Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize4Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cache4 = cache3.get(a3);
        if (!cache4) {
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const newValue = fn(a1, a2, a3, a4);
          cache42.set(a4, newValue);
          return newValue;
        }
        const cachedValue = cache4.get(a4);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache4.set(a4, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize4 = memoize4;
    function memoize5(fn) {
      const memoize5Cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize5Cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize5Cache.set(a1, cache2);
          const cache32 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache32);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache32.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache3 = cache2.get(a2);
        if (!cache3) {
          cache3 = /* @__PURE__ */ new WeakMap();
          cache2.set(a2, cache3);
          const cache42 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache42);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache42.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache4 = cache3.get(a3);
        if (!cache4) {
          cache4 = /* @__PURE__ */ new WeakMap();
          cache3.set(a3, cache4);
          const cache52 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache52);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache52.set(a5, newValue);
          return newValue;
        }
        let cache5 = cache4.get(a4);
        if (!cache5) {
          cache5 = /* @__PURE__ */ new WeakMap();
          cache4.set(a4, cache5);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        const cachedValue = cache5.get(a5);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache5.set(a5, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize5 = memoize5;
    function memoize2of4(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize2of4 = memoize2of4;
    function memoize2of5(fn) {
      const memoize2of4cache = /* @__PURE__ */ new WeakMap();
      return function memoized(a1, a2, a3, a4, a5) {
        let cache2 = memoize2of4cache.get(a1);
        if (!cache2) {
          cache2 = /* @__PURE__ */ new WeakMap();
          memoize2of4cache.set(a1, cache2);
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        const cachedValue = cache2.get(a2);
        if (cachedValue === void 0) {
          const newValue = fn(a1, a2, a3, a4, a5);
          cache2.set(a2, newValue);
          return newValue;
        }
        return cachedValue;
      };
    }
    exports.memoize2of5 = memoize2of5;
  }
});

// node_modules/@graphql-tools/utils/cjs/rootTypes.js
var require_rootTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRootTypeMap = exports.getRootTypes = exports.getRootTypeNames = exports.getDefinedRootType = void 0;
    var errors_js_1 = require_errors();
    var memoize_js_1 = require_memoize();
    function getDefinedRootType(schema, operation, nodes) {
      const rootTypeMap = (0, exports.getRootTypeMap)(schema);
      const rootType = rootTypeMap.get(operation);
      if (rootType == null) {
        throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
          nodes
        });
      }
      return rootType;
    }
    exports.getDefinedRootType = getDefinedRootType;
    exports.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
      const rootTypes = (0, exports.getRootTypes)(schema);
      return new Set([...rootTypes].map((type) => type.name));
    });
    exports.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
      const rootTypeMap = (0, exports.getRootTypeMap)(schema);
      return new Set(rootTypeMap.values());
    });
    exports.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
      const rootTypeMap = /* @__PURE__ */ new Map();
      const queryType = schema.getQueryType();
      if (queryType) {
        rootTypeMap.set("query", queryType);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        rootTypeMap.set("mutation", mutationType);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        rootTypeMap.set("subscription", subscriptionType);
      }
      return rootTypeMap;
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
var require_print_schema_with_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeDirectiveNodes = exports.makeDirectiveNode = exports.makeDeprecatedDirective = exports.astFromEnumValue = exports.astFromInputField = exports.astFromField = exports.astFromScalarType = exports.astFromEnumType = exports.astFromInputObjectType = exports.astFromUnionType = exports.astFromInterfaceType = exports.astFromObjectType = exports.astFromArg = exports.getDeprecatableDirectiveNodes = exports.getDirectiveNodes = exports.astFromDirective = exports.astFromSchema = exports.printSchemaWithDirectives = exports.getDocumentNodeFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    var get_directives_js_1 = require_get_directives();
    var astFromValueUntyped_js_1 = require_astFromValueUntyped();
    var helpers_js_1 = require_helpers();
    var rootTypes_js_1 = require_rootTypes();
    function getDocumentNodeFromSchema(schema, options = {}) {
      const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
      const typesMap = schema.getTypeMap();
      const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
      const definitions = schemaNode != null ? [schemaNode] : [];
      const directives = schema.getDirectives();
      for (const directive of directives) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          continue;
        }
        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
      }
      for (const typeName in typesMap) {
        const type = typesMap[typeName];
        const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
        const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
        if (isPredefinedScalar || isIntrospection) {
          continue;
        }
        if ((0, graphql_1.isObjectType)(type)) {
          definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isUnionType)(type)) {
          definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isEnumType)(type)) {
          definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
        } else if ((0, graphql_1.isScalarType)(type)) {
          definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
        } else {
          throw new Error(`Unknown type ${type}.`);
        }
      }
      return {
        kind: graphql_1.Kind.DOCUMENT,
        definitions
      };
    }
    exports.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
    function printSchemaWithDirectives(schema, options = {}) {
      const documentNode = getDocumentNodeFromSchema(schema, options);
      return (0, graphql_1.print)(documentNode);
    }
    exports.printSchemaWithDirectives = printSchemaWithDirectives;
    function astFromSchema(schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const operationTypeMap = /* @__PURE__ */ new Map([
        ["query", void 0],
        ["mutation", void 0],
        ["subscription", void 0]
      ]);
      const nodes = [];
      if (schema.astNode != null) {
        nodes.push(schema.astNode);
      }
      if (schema.extensionASTNodes != null) {
        for (const extensionASTNode of schema.extensionASTNodes) {
          nodes.push(extensionASTNode);
        }
      }
      for (const node of nodes) {
        if (node.operationTypes) {
          for (const operationTypeDefinitionNode of node.operationTypes) {
            operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
          }
        }
      }
      const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
      for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
        const rootType = rootTypeMap.get(operationTypeNode);
        if (rootType != null) {
          const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
          if (operationTypeDefinitionNode != null) {
            operationTypeDefinitionNode.type = rootTypeAST;
          } else {
            operationTypeMap.set(operationTypeNode, {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: operationTypeNode,
              type: rootTypeAST
            });
          }
        }
      }
      const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
      const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
      if (!operationTypes.length && !directives.length) {
        return null;
      }
      const schemaNode = {
        kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
        operationTypes,
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
      schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
        kind: graphql_1.Kind.STRING,
        value: schema.description,
        block: true
      } : void 0;
      return schemaNode;
    }
    exports.astFromSchema = astFromSchema;
    function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c, _d;
      return {
        kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
        description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
          kind: graphql_1.Kind.STRING,
          value: directive.description
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: directive.name
        },
        arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        repeatable: directive.isRepeatable,
        locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
          kind: graphql_1.Kind.NAME,
          value: location
        }))) || []
      };
    }
    exports.astFromDirective = astFromDirective;
    function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let nodes = [];
      if (entity.astNode != null) {
        nodes.push(entity.astNode);
      }
      if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
        nodes = nodes.concat(entity.extensionASTNodes);
      }
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = [];
        for (const node of nodes) {
          if (node.directives) {
            directives.push(...node.directives);
          }
        }
      }
      return directives;
    }
    exports.getDirectiveNodes = getDirectiveNodes;
    function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      let directiveNodesBesidesDeprecated = [];
      let deprecatedDirectiveNode = null;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
      let directives;
      if (directivesInExtensions != null) {
        directives = makeDirectiveNodes(schema, directivesInExtensions);
      } else {
        directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
      }
      if (directives != null) {
        directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
        if (entity.deprecationReason != null) {
          deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
        }
      }
      if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
      }
      return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
    }
    exports.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
    function astFromArg(arg, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
          kind: graphql_1.Kind.STRING,
          value: arg.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: arg.name
        },
        type: (0, astFromType_js_1.astFromType)(arg.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        defaultValue: arg.defaultValue !== void 0 ? (_c = (0, graphql_1.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
        directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromArg = astFromArg;
    function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromObjectType = astFromObjectType;
    function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      const node = {
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
      if ("getInterfaces" in type) {
        node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
      }
      return node;
    }
    exports.astFromInterfaceType = astFromInterfaceType;
    function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
        types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
      };
    }
    exports.astFromUnionType = astFromUnionType;
    function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromInputObjectType = astFromInputObjectType;
    function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        description: (_b = (_a = type.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromEnumType = astFromEnumType;
    function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
      const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
      const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
      if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
        const specifiedByArgs = {
          url: specifiedByValue
        };
        directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
      }
      return {
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
        description: (_c = (_b = type.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.description ? {
          kind: graphql_1.Kind.STRING,
          value: type.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: type.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives
      };
    }
    exports.astFromScalarType = astFromScalarType;
    function astFromField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.FIELD_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromField = astFromField;
    function astFromInputField(field, schema, pathToDirectivesInExtensions) {
      var _a, _b, _c;
      return {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
          kind: graphql_1.Kind.STRING,
          value: field.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        type: (0, astFromType_js_1.astFromType)(field.type),
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
        defaultValue: (_c = (0, graphql_1.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
      };
    }
    exports.astFromInputField = astFromInputField;
    function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
      var _a, _b;
      return {
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
          kind: graphql_1.Kind.STRING,
          value: value.description,
          block: true
        } : void 0,
        name: {
          kind: graphql_1.Kind.NAME,
          value: value.name
        },
        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
        directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
      };
    }
    exports.astFromEnumValue = astFromEnumValue;
    function makeDeprecatedDirective(deprecationReason) {
      return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
    }
    exports.makeDeprecatedDirective = makeDeprecatedDirective;
    function makeDirectiveNode(name, args, directive) {
      const directiveArguments = [];
      if (directive != null) {
        for (const arg of directive.args) {
          const argName = arg.name;
          const argValue = args[argName];
          if (argValue !== void 0) {
            const value = (0, graphql_1.astFromValue)(argValue, arg.type);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
      } else {
        for (const argName in args) {
          const argValue = args[argName];
          const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
          if (value) {
            directiveArguments.push({
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argName
              },
              value
            });
          }
        }
      }
      return {
        kind: graphql_1.Kind.DIRECTIVE,
        name: {
          kind: graphql_1.Kind.NAME,
          value: name
        },
        arguments: directiveArguments
      };
    }
    exports.makeDirectiveNode = makeDirectiveNode;
    function makeDirectiveNodes(schema, directiveValues) {
      const directiveNodes = [];
      for (const directiveName in directiveValues) {
        const arrayOrSingleValue = directiveValues[directiveName];
        const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
        if (Array.isArray(arrayOrSingleValue)) {
          for (const value of arrayOrSingleValue) {
            directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
          }
        } else {
          directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
        }
      }
      return directiveNodes;
    }
    exports.makeDirectiveNodes = makeDirectiveNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/validate-documents.js
var require_validate_documents = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultRules = exports.validateGraphQlDocuments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
      var _a;
      const definitionMap = /* @__PURE__ */ new Map();
      for (const document2 of documents) {
        for (const docDefinition of document2.definitions) {
          if ("name" in docDefinition && docDefinition.name) {
            definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
          } else {
            definitionMap.set(Date.now().toString(), docDefinition);
          }
        }
      }
      const fullAST = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: Array.from(definitionMap.values())
      };
      const errors = (0, graphql_1.validate)(schema, fullAST, rules);
      for (const error of errors) {
        error.stack = error.message;
        if (error.locations) {
          for (const location of error.locations) {
            error.stack += `
    at ${(_a = error.source) === null || _a === void 0 ? void 0 : _a.name}:${location.line}:${location.column}`;
          }
        }
      }
      return errors;
    }
    exports.validateGraphQlDocuments = validateGraphQlDocuments;
    function createDefaultRules() {
      let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
      if (graphql_1.versionInfo.major < 15) {
        ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
      }
      return graphql_1.specifiedRules.filter((f) => !ignored.includes(f.name));
    }
    exports.createDefaultRules = createDefaultRules;
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
var require_parse_graphql_json = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGraphQLJSON = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function stripBOM(content) {
      content = content.toString();
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function parseBOM(content) {
      return JSON.parse(stripBOM(content));
    }
    function parseGraphQLJSON(location, jsonContent, options) {
      let parsedJson = parseBOM(jsonContent);
      if (parsedJson.data) {
        parsedJson = parsedJson.data;
      }
      if (parsedJson.kind === "Document") {
        return {
          location,
          document: parsedJson
        };
      } else if (parsedJson.__schema) {
        const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
        return {
          location,
          schema
        };
      } else if (typeof parsedJson === "string") {
        return {
          location,
          rawSDL: parsedJson
        };
      }
      throw new Error(`Not valid JSON content`);
    }
    exports.parseGraphQLJSON = parseGraphQLJSON;
  }
});

// node_modules/@graphql-tools/utils/cjs/comments.js
var require_comments = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/comments.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var MAX_LINE_LENGTH2 = 80;
    var commentsRegistry = {};
    function resetComments() {
      commentsRegistry = {};
    }
    exports.resetComments = resetComments;
    function collectComment(node) {
      var _a;
      const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
      if (entityName == null) {
        return;
      }
      pushComment(node, entityName);
      switch (node.kind) {
        case "EnumTypeDefinition":
          if (node.values) {
            for (const value of node.values) {
              pushComment(value, entityName, value.name.value);
            }
          }
          break;
        case "ObjectTypeDefinition":
        case "InputObjectTypeDefinition":
        case "InterfaceTypeDefinition":
          if (node.fields) {
            for (const field of node.fields) {
              pushComment(field, entityName, field.name.value);
              if (isFieldDefinitionNode(field) && field.arguments) {
                for (const arg of field.arguments) {
                  pushComment(arg, entityName, field.name.value, arg.name.value);
                }
              }
            }
          }
          break;
      }
    }
    exports.collectComment = collectComment;
    function pushComment(node, entity, field, argument) {
      const comment = getComment(node);
      if (typeof comment !== "string" || comment.length === 0) {
        return;
      }
      const keys2 = [entity];
      if (field) {
        keys2.push(field);
        if (argument) {
          keys2.push(argument);
        }
      }
      const path = keys2.join(".");
      if (!commentsRegistry[path]) {
        commentsRegistry[path] = [];
      }
      commentsRegistry[path].push(comment);
    }
    exports.pushComment = pushComment;
    function printComment(comment) {
      return "\n# " + comment.replace(/\n/g, "\n# ");
    }
    exports.printComment = printComment;
    function join2(maybeArray, separator) {
      return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
    }
    function hasMultilineItems2(maybeArray) {
      var _a;
      return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
    }
    function addDescription(cb) {
      return (node, _key, _parent, path, ancestors) => {
        var _a;
        const keys2 = [];
        const parent = path.reduce((prev, key2) => {
          if (["fields", "arguments", "values"].includes(key2) && prev.name) {
            keys2.push(prev.name.value);
          }
          return prev[key2];
        }, ancestors[0]);
        const key = [...keys2, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
        const items = [];
        if (node.kind.includes("Definition") && commentsRegistry[key]) {
          items.push(...commentsRegistry[key]);
        }
        return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
      };
    }
    function indent2(maybeString) {
      return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
    }
    function block2(array) {
      return array && array.length !== 0 ? `{
${indent2(join2(array, "\n"))}
}` : "";
    }
    function wrap2(start, maybeString, end) {
      return maybeString ? start + maybeString + (end || "") : "";
    }
    function printBlockString2(value, isDescription = false) {
      const escaped = value.replace(/"""/g, '\\"""');
      return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
    }
    var printDocASTReducer2 = {
      Name: { leave: (node) => node.value },
      Variable: { leave: (node) => "$" + node.name },
      // Document
      Document: {
        leave: (node) => join2(node.definitions, "\n\n")
      },
      OperationDefinition: {
        leave: (node) => {
          const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
          return prefix + " " + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
      },
      SelectionSet: { leave: ({ selections }) => block2(selections) },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: { leave: ({ name, value }) => name + ": " + value },
      // Fragments
      FragmentSpread: {
        leave: ({ name, directives }) => "..." + name + wrap2(" ", join2(directives, " "))
      },
      InlineFragment: {
        leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives, " "), selectionSet], " ")
      },
      FragmentDefinition: {
        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // Note: fragment variable definitions are experimental and may be changed
          // or removed in the future.
          `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
        )
      },
      // Value
      IntValue: { leave: ({ value }) => value },
      FloatValue: { leave: ({ value }) => value },
      StringValue: {
        leave: ({ value, block: isBlockString }) => {
          if (isBlockString) {
            return printBlockString2(value);
          }
          return JSON.stringify(value);
        }
      },
      BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value }) => value },
      ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
      ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
      ObjectField: { leave: ({ name, value }) => name + ": " + value },
      // Directive
      Directive: {
        leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")")
      },
      // Type
      NamedType: { leave: ({ name }) => name },
      ListType: { leave: ({ type }) => "[" + type + "]" },
      NonNullType: { leave: ({ type }) => type + "!" },
      // Type System Definitions
      SchemaDefinition: {
        leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      OperationTypeDefinition: {
        leave: ({ operation, type }) => operation + ": " + type
      },
      ScalarTypeDefinition: {
        leave: ({ name, directives }) => join2(["scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      FieldDefinition: {
        leave: ({ name, arguments: args, type, directives }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
      },
      InputValueDefinition: {
        leave: ({ name, type, defaultValue, directives }) => join2([name + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")], " ")
      },
      InterfaceTypeDefinition: {
        leave: ({ name, interfaces, directives, fields }) => join2(["interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeDefinition: {
        leave: ({ name, directives, types }) => join2(["union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeDefinition: {
        leave: ({ name, directives, values }) => join2(["enum", name, join2(directives, " "), block2(values)], " ")
      },
      EnumValueDefinition: {
        leave: ({ name, directives }) => join2([name, join2(directives, " ")], " ")
      },
      InputObjectTypeDefinition: {
        leave: ({ name, directives, fields }) => join2(["input", name, join2(directives, " "), block2(fields)], " ")
      },
      DirectiveDefinition: {
        leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
      },
      SchemaExtension: {
        leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block2(operationTypes)], " ")
      },
      ScalarTypeExtension: {
        leave: ({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " ")
      },
      ObjectTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend type", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      InterfaceTypeExtension: {
        leave: ({ name, interfaces, directives, fields }) => join2(["extend interface", name, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
      },
      UnionTypeExtension: {
        leave: ({ name, directives, types }) => join2(["extend union", name, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
      },
      EnumTypeExtension: {
        leave: ({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block2(values)], " ")
      },
      InputObjectTypeExtension: {
        leave: ({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block2(fields)], " ")
      }
    };
    var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
      ...prev,
      [key]: {
        leave: addDescription(printDocASTReducer2[key].leave)
      }
    }), {});
    function printWithComments(ast) {
      return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
    }
    exports.printWithComments = printWithComments;
    function isFieldDefinitionNode(node) {
      return node.kind === "FieldDefinition";
    }
    function getDescription(node, options) {
      if (node.description != null) {
        return node.description.value;
      }
      if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {
        return getComment(node);
      }
    }
    exports.getDescription = getDescription;
    function getComment(node) {
      const rawValue = getLeadingCommentBlock(node);
      if (rawValue !== void 0) {
        return dedentBlockStringValue(`
${rawValue}`);
      }
    }
    exports.getComment = getComment;
    function getLeadingCommentBlock(node) {
      const loc = node.loc;
      if (!loc) {
        return;
      }
      const comments = [];
      let token = loc.startToken.prev;
      while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
        const value = String(token.value);
        comments.push(value);
        token = token.prev;
      }
      return comments.length > 0 ? comments.reverse().join("\n") : void 0;
    }
    exports.getLeadingCommentBlock = getLeadingCommentBlock;
    function dedentBlockStringValue(rawString) {
      const lines = rawString.split(/\r\n|[\n\r]/g);
      const commonIndent = getBlockStringIndentation(lines);
      if (commonIndent !== 0) {
        for (let i = 1; i < lines.length; i++) {
          lines[i] = lines[i].slice(commonIndent);
        }
      }
      while (lines.length > 0 && isBlank(lines[0])) {
        lines.shift();
      }
      while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
        lines.pop();
      }
      return lines.join("\n");
    }
    exports.dedentBlockStringValue = dedentBlockStringValue;
    function getBlockStringIndentation(lines) {
      let commonIndent = null;
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const indent3 = leadingWhitespace2(line);
        if (indent3 === line.length) {
          continue;
        }
        if (commonIndent === null || indent3 < commonIndent) {
          commonIndent = indent3;
          if (commonIndent === 0) {
            break;
          }
        }
      }
      return commonIndent === null ? 0 : commonIndent;
    }
    exports.getBlockStringIndentation = getBlockStringIndentation;
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (str[i] === " " || str[i] === "	")) {
        i++;
      }
      return i;
    }
    function isBlank(str) {
      return leadingWhitespace2(str) === str.length;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
var require_parse_graphql_sdl = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDescribable = exports.transformCommentsToDescriptions = exports.parseGraphQLSDL = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var comments_js_1 = require_comments();
    function parseGraphQLSDL(location, rawSDL, options = {}) {
      let document2;
      try {
        if (options.commentDescriptions && rawSDL.includes("#")) {
          document2 = transformCommentsToDescriptions(rawSDL, options);
          if (options.noLocation) {
            document2 = (0, graphql_1.parse)((0, graphql_1.print)(document2), options);
          }
        } else {
          document2 = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
        }
      } catch (e) {
        if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
          document2 = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions: []
          };
        } else {
          throw e;
        }
      }
      return {
        location,
        document: document2
      };
    }
    exports.parseGraphQLSDL = parseGraphQLSDL;
    function transformCommentsToDescriptions(sourceSdl, options = {}) {
      const parsedDoc = (0, graphql_1.parse)(sourceSdl, {
        ...options,
        noLocation: false
      });
      const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
        leave: (node) => {
          if (isDescribable(node)) {
            const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
            if (rawValue !== void 0) {
              const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
              const isBlock = commentsBlock.includes("\n");
              if (!node.description) {
                return {
                  ...node,
                  description: {
                    kind: graphql_1.Kind.STRING,
                    value: commentsBlock,
                    block: isBlock
                  }
                };
              } else {
                return {
                  ...node,
                  description: {
                    ...node.description,
                    value: node.description.value + "\n" + commentsBlock,
                    block: true
                  }
                };
              }
            }
          }
        }
      });
      return modifiedDoc;
    }
    exports.transformCommentsToDescriptions = transformCommentsToDescriptions;
    function isDescribable(node) {
      return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
    }
    exports.isDescribable = isDescribable;
  }
});

// node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
var require_build_operation_for_field = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildOperationNodeForField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var rootTypes_js_1 = require_rootTypes();
    var operationVariables = [];
    var fieldTypeMap = /* @__PURE__ */ new Map();
    function addOperationVariable(variable) {
      operationVariables.push(variable);
    }
    function resetOperationVariables() {
      operationVariables = [];
    }
    function resetFieldMap() {
      fieldTypeMap = /* @__PURE__ */ new Map();
    }
    function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
      resetOperationVariables();
      resetFieldMap();
      const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
      const operationNode = buildOperationAndCollectVariables({
        schema,
        fieldName: field,
        kind,
        models: models || [],
        ignore,
        depthLimit: depthLimit || Infinity,
        circularReferenceDepth: circularReferenceDepth || 1,
        argNames,
        selectedFields,
        rootTypeNames
      });
      operationNode.variableDefinitions = [...operationVariables];
      resetOperationVariables();
      resetFieldMap();
      return operationNode;
    }
    exports.buildOperationNodeForField = buildOperationNodeForField;
    function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
      const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
      const field = type.getFields()[fieldName];
      const operationName = `${fieldName}_${kind}`;
      if (field.args) {
        for (const arg of field.args) {
          const argName = arg.name;
          if (!argNames || argNames.includes(argName)) {
            addOperationVariable(resolveVariable(arg, argName));
          }
        }
      }
      return {
        kind: graphql_1.Kind.OPERATION_DEFINITION,
        operation: kind,
        name: {
          kind: graphql_1.Kind.NAME,
          value: operationName
        },
        variableDefinitions: [],
        selectionSet: {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: [
            resolveField({
              type,
              field,
              models,
              firstCall: true,
              path: [],
              ancestors: [],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: 0,
              argNames,
              selectedFields,
              rootTypeNames
            })
          ]
        }
      };
    }
    function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      if (typeof selectedFields === "boolean" && depth > depthLimit) {
        return;
      }
      if ((0, graphql_1.isUnionType)(type)) {
        const types = type.getTypes();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isInterfaceType)(type)) {
        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: types.filter((t) => !hasCircularRef([...ancestors, t], {
            depth: circularReferenceDepth
          })).map((t) => {
            return {
              kind: graphql_1.Kind.INLINE_FRAGMENT,
              typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: t.name
                }
              },
              selectionSet: resolveSelectionSet({
                parent: type,
                type: t,
                models,
                path,
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields,
                rootTypeNames
              })
            };
          }).filter((fragmentNode) => {
            var _a, _b;
            return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;
          })
        };
      }
      if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
        const isModel = models.includes(type.name);
        if (!firstCall && isModel && !isIgnored) {
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              {
                kind: graphql_1.Kind.FIELD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "id"
                }
              }
            ]
          };
        }
        const fields = type.getFields();
        return {
          kind: graphql_1.Kind.SELECTION_SET,
          selections: Object.keys(fields).filter((fieldName) => {
            return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
              depth: circularReferenceDepth
            });
          }).map((fieldName) => {
            const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
            if (selectedSubFields) {
              return resolveField({
                type,
                field: fields[fieldName],
                models,
                path: [...path, fieldName],
                ancestors,
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth,
                argNames,
                selectedFields: selectedSubFields,
                rootTypeNames
              });
            }
            return null;
          }).filter((f) => {
            var _a, _b;
            if (f == null) {
              return false;
            } else if ("selectionSet" in f) {
              return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);
            }
            return true;
          })
        };
      }
    }
    function resolveVariable(arg, name) {
      function resolveVariableType(type) {
        if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: resolveVariableType(type.ofType)
          };
        }
        if ((0, graphql_1.isNonNullType)(type)) {
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            // for v16 compatibility
            type: resolveVariableType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      return {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name || arg.name
          }
        },
        type: resolveVariableType(arg.type)
      };
    }
    function getArgumentName(name, path) {
      return [...path, name].join("_");
    }
    function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
      const namedType = (0, graphql_1.getNamedType)(field.type);
      let args = [];
      let removeField = false;
      if (field.args && field.args.length) {
        args = field.args.map((arg) => {
          const argumentName = getArgumentName(arg.name, path);
          if (argNames && !argNames.includes(argumentName)) {
            if ((0, graphql_1.isNonNullType)(arg.type)) {
              removeField = true;
            }
            return null;
          }
          if (!firstCall) {
            addOperationVariable(resolveVariable(arg, argumentName));
          }
          return {
            kind: graphql_1.Kind.ARGUMENT,
            name: {
              kind: graphql_1.Kind.NAME,
              value: arg.name
            },
            value: {
              kind: graphql_1.Kind.VARIABLE,
              name: {
                kind: graphql_1.Kind.NAME,
                value: getArgumentName(arg.name, path)
              }
            }
          };
        }).filter(Boolean);
      }
      if (removeField) {
        return null;
      }
      const fieldPath = [...path, field.name];
      const fieldPathStr = fieldPath.join(".");
      let fieldName = field.name;
      if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
        fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
      }
      fieldTypeMap.set(fieldPathStr, field.type.toString());
      if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
        return {
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
          selectionSet: resolveSelectionSet({
            parent: type,
            type: namedType,
            models,
            firstCall,
            path: fieldPath,
            ancestors: [...ancestors, type],
            ignore,
            depthLimit,
            circularReferenceDepth,
            schema,
            depth: depth + 1,
            argNames,
            selectedFields,
            rootTypeNames
          }) || void 0,
          arguments: args
        };
      }
      return {
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: field.name
        },
        ...fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } },
        arguments: args
      };
    }
    function hasCircularRef(types, config2 = {
      depth: 1
    }) {
      const type = types[types.length - 1];
      if ((0, graphql_1.isScalarType)(type)) {
        return false;
      }
      const size = types.filter((t) => t.name === type.name).length;
      return size > config2.depth;
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/types.js
var require_types = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectiveLocation = void 0;
    var DirectiveLocation2;
    (function(DirectiveLocation3) {
      DirectiveLocation3["QUERY"] = "QUERY";
      DirectiveLocation3["MUTATION"] = "MUTATION";
      DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation3["FIELD"] = "FIELD";
      DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation3["SCHEMA"] = "SCHEMA";
      DirectiveLocation3["SCALAR"] = "SCALAR";
      DirectiveLocation3["OBJECT"] = "OBJECT";
      DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation3["INTERFACE"] = "INTERFACE";
      DirectiveLocation3["UNION"] = "UNION";
      DirectiveLocation3["ENUM"] = "ENUM";
      DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation2 = exports.DirectiveLocation || (exports.DirectiveLocation = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/Interfaces.js
var require_Interfaces = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapperKind = void 0;
    var MapperKind;
    (function(MapperKind2) {
      MapperKind2["TYPE"] = "MapperKind.TYPE";
      MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
      MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
      MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
      MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
      MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
      MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
      MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
      MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
      MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
      MapperKind2["QUERY"] = "MapperKind.QUERY";
      MapperKind2["MUTATION"] = "MapperKind.MUTATION";
      MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
      MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
      MapperKind2["FIELD"] = "MapperKind.FIELD";
      MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
      MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
      MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
      MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
      MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
      MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
      MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
      MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
      MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
      MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
    })(MapperKind = exports.MapperKind || (exports.MapperKind = {}));
  }
});

// node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
var require_getObjectTypeFromTypeMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getObjectTypeFromTypeMap = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getObjectTypeFromTypeMap(typeMap, type) {
      if (type) {
        const maybeObjectType = typeMap[type.name];
        if ((0, graphql_1.isObjectType)(maybeObjectType)) {
          return maybeObjectType;
        }
      }
    }
    exports.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/stub.js
var require_stub = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/stub.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBuiltInForStub = exports.isNamedStub = exports.createStub = exports.createNamedStub = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function createNamedStub(name, type) {
      let constructor;
      if (type === "object") {
        constructor = graphql_1.GraphQLObjectType;
      } else if (type === "interface") {
        constructor = graphql_1.GraphQLInterfaceType;
      } else {
        constructor = graphql_1.GraphQLInputObjectType;
      }
      return new constructor({
        name,
        fields: {
          _fake: {
            type: graphql_1.GraphQLString
          }
        }
      });
    }
    exports.createNamedStub = createNamedStub;
    function createStub(node, type) {
      switch (node.kind) {
        case graphql_1.Kind.LIST_TYPE:
          return new graphql_1.GraphQLList(createStub(node.type, type));
        case graphql_1.Kind.NON_NULL_TYPE:
          return new graphql_1.GraphQLNonNull(createStub(node.type, type));
        default:
          if (type === "output") {
            return createNamedStub(node.name.value, "object");
          }
          return createNamedStub(node.name.value, "input");
      }
    }
    exports.createStub = createStub;
    function isNamedStub(type) {
      if ("getFields" in type) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          return field.name === "_fake";
        }
      }
      return false;
    }
    exports.isNamedStub = isNamedStub;
    function getBuiltInForStub(type) {
      switch (type.name) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;
        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;
        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;
        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;
        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;
        default:
          return type;
      }
    }
    exports.getBuiltInForStub = getBuiltInForStub;
  }
});

// node_modules/@graphql-tools/utils/cjs/rewire.js
var require_rewire = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/rewire.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rewireTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var stub_js_1 = require_stub();
    function rewireTypes(originalTypeMap, directives) {
      const referenceTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        referenceTypeMap[typeName] = originalTypeMap[typeName];
      }
      const newTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in referenceTypeMap) {
        const namedType = referenceTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const newName = namedType.name;
        if (newName.startsWith("__")) {
          continue;
        }
        if (newTypeMap[newName] != null) {
          console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
          continue;
        }
        newTypeMap[newName] = namedType;
      }
      for (const typeName in newTypeMap) {
        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
      }
      const newDirectives = directives.map((directive) => rewireDirective(directive));
      return {
        typeMap: newTypeMap,
        directives: newDirectives
      };
      function rewireDirective(directive) {
        if ((0, graphql_1.isSpecifiedDirective)(directive)) {
          return directive;
        }
        const directiveConfig = directive.toConfig();
        directiveConfig.args = rewireArgs(directiveConfig.args);
        return new graphql_1.GraphQLDirective(directiveConfig);
      }
      function rewireArgs(args) {
        const rewiredArgs = {};
        for (const argName in args) {
          const arg = args[argName];
          const rewiredArgType = rewireType(arg.type);
          if (rewiredArgType != null) {
            arg.type = rewiredArgType;
            rewiredArgs[argName] = arg;
          }
        }
        return rewiredArgs;
      }
      function rewireNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config2 = type.toConfig();
          const newConfig = {
            ...config2,
            fields: () => rewireFields(config2.fields),
            interfaces: () => rewireNamedTypes(config2.interfaces)
          };
          return new graphql_1.GraphQLObjectType(newConfig);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config2 = type.toConfig();
          const newConfig = {
            ...config2,
            fields: () => rewireFields(config2.fields)
          };
          if ("interfaces" in newConfig) {
            newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
          }
          return new graphql_1.GraphQLInterfaceType(newConfig);
        } else if ((0, graphql_1.isUnionType)(type)) {
          const config2 = type.toConfig();
          const newConfig = {
            ...config2,
            types: () => rewireNamedTypes(config2.types)
          };
          return new graphql_1.GraphQLUnionType(newConfig);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config2 = type.toConfig();
          const newConfig = {
            ...config2,
            fields: () => rewireInputFields(config2.fields)
          };
          return new graphql_1.GraphQLInputObjectType(newConfig);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const enumConfig = type.toConfig();
          return new graphql_1.GraphQLEnumType(enumConfig);
        } else if ((0, graphql_1.isScalarType)(type)) {
          if ((0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          const scalarConfig = type.toConfig();
          return new graphql_1.GraphQLScalarType(scalarConfig);
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function rewireFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null && field.args) {
            field.type = rewiredFieldType;
            field.args = rewireArgs(field.args);
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireInputFields(fields) {
        const rewiredFields = {};
        for (const fieldName in fields) {
          const field = fields[fieldName];
          const rewiredFieldType = rewireType(field.type);
          if (rewiredFieldType != null) {
            field.type = rewiredFieldType;
            rewiredFields[fieldName] = field;
          }
        }
        return rewiredFields;
      }
      function rewireNamedTypes(namedTypes) {
        const rewiredTypes = [];
        for (const namedType of namedTypes) {
          const rewiredType = rewireType(namedType);
          if (rewiredType != null) {
            rewiredTypes.push(rewiredType);
          }
        }
        return rewiredTypes;
      }
      function rewireType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const rewiredType = rewireType(type.ofType);
          return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          let rewiredType = referenceTypeMap[type.name];
          if (rewiredType === void 0) {
            rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
            newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
          }
          return rewiredType != null ? newTypeMap[rewiredType.name] : null;
        }
        return null;
      }
    }
    exports.rewireTypes = rewireTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/transformInputValue.js
var require_transformInputValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseInputValueLiteral = exports.parseInputValue = exports.serializeInputValue = exports.transformInputValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var helpers_js_1 = require_helpers();
    function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(type);
      if ((0, graphql_1.isLeafType)(nullableType)) {
        return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
      } else if ((0, graphql_1.isListType)(nullableType)) {
        return (0, helpers_js_1.asArray)(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
      } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
        const fields = nullableType.getFields();
        const newValue = {};
        for (const key in value) {
          const field = fields[key];
          if (field != null) {
            newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
          }
        }
        return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
      }
    }
    exports.transformInputValue = transformInputValue;
    function serializeInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.serialize(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports.serializeInputValue = serializeInputValue;
    function parseInputValue(type, value) {
      return transformInputValue(type, value, (t, v) => {
        try {
          return t.parseValue(v);
        } catch (_a) {
          return v;
        }
      });
    }
    exports.parseInputValue = parseInputValue;
    function parseInputValueLiteral(type, value) {
      return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));
    }
    exports.parseInputValueLiteral = parseInputValueLiteral;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapSchema.js
var require_mapSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.correctASTNodes = exports.mapSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var Interfaces_js_1 = require_Interfaces();
    var rewire_js_1 = require_rewire();
    var transformInputValue_js_1 = require_transformInputValue();
    function mapSchema(schema, schemaMapper = {}) {
      const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
      const originalDirectives = schema.getDirectives();
      const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
      return new graphql_1.GraphQLSchema({
        ...schema.toConfig(),
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
        types: Object.values(typeMap),
        directives
      });
    }
    exports.mapSchema = mapSchema;
    function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (originalType == null || !testFn(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
          if (typeMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const maybeNewType = typeMapper(originalType, schema);
          if (maybeNewType === void 0) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          newTypeMap[typeName] = maybeNewType;
        }
      }
      return newTypeMap;
    }
    function mapEnumValues(originalTypeMap, schema, schemaMapper) {
      const enumValueMapper = getEnumValueMapper(schemaMapper);
      if (!enumValueMapper) {
        return originalTypeMap;
      }
      return mapTypes(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          const config2 = type.toConfig();
          const originalEnumValueConfigMap = config2.values;
          const newEnumValueConfigMap = {};
          for (const externalValue in originalEnumValueConfigMap) {
            const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
            const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
            if (mappedEnumValue === void 0) {
              newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
            } else if (Array.isArray(mappedEnumValue)) {
              const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
              newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
            } else if (mappedEnumValue !== null) {
              newEnumValueConfigMap[externalValue] = mappedEnumValue;
            }
          }
          return correctASTNodes(new graphql_1.GraphQLEnumType({
            ...config2,
            values: newEnumValueConfigMap
          }));
        }
      }, (type) => (0, graphql_1.isEnumType)(type));
    }
    function mapDefaultValues(originalTypeMap, schema, fn) {
      const newTypeMap = mapArguments(originalTypeMap, schema, {
        [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
          if (argumentConfig.defaultValue === void 0) {
            return argumentConfig;
          }
          const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
          if (maybeNewType != null) {
            return {
              ...argumentConfig,
              defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
            };
          }
        }
      });
      return mapFields(newTypeMap, schema, {
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
          if (inputFieldConfig.defaultValue === void 0) {
            return inputFieldConfig;
          }
          const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
          if (maybeNewType != null) {
            return {
              ...inputFieldConfig,
              defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
            };
          }
        }
      });
    }
    function getNewType(newTypeMap, type) {
      if ((0, graphql_1.isListType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLList(newType) : null;
      } else if ((0, graphql_1.isNonNullType)(type)) {
        const newType = getNewType(newTypeMap, type.ofType);
        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
      } else if ((0, graphql_1.isNamedType)(type)) {
        const newType = newTypeMap[type.name];
        return newType != null ? newType : null;
      }
      return null;
    }
    function mapFields(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
          if (fieldMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
            if (mappedField === void 0) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
            } else if (Array.isArray(mappedField)) {
              const [newFieldName, newFieldConfig] = mappedField;
              if (newFieldConfig.astNode != null) {
                newFieldConfig.astNode = {
                  ...newFieldConfig.astNode,
                  name: {
                    ...newFieldConfig.astNode.name,
                    value: newFieldName
                  }
                };
              }
              newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
            } else if (mappedField !== null) {
              newFieldConfigMap[fieldName] = mappedField;
            }
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            }));
          } else {
            newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      }
      return newTypeMap;
    }
    function mapArguments(originalTypeMap, schema, schemaMapper) {
      const newTypeMap = {};
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__")) {
          const originalType = originalTypeMap[typeName];
          if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const argumentMapper = getArgumentMapper(schemaMapper);
          if (argumentMapper == null) {
            newTypeMap[typeName] = originalType;
            continue;
          }
          const config2 = originalType.toConfig();
          const originalFieldConfigMap = config2.fields;
          const newFieldConfigMap = {};
          for (const fieldName in originalFieldConfigMap) {
            const originalFieldConfig = originalFieldConfigMap[fieldName];
            const originalArgumentConfigMap = originalFieldConfig.args;
            if (originalArgumentConfigMap == null) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const argumentNames = Object.keys(originalArgumentConfigMap);
            if (!argumentNames.length) {
              newFieldConfigMap[fieldName] = originalFieldConfig;
              continue;
            }
            const newArgumentConfigMap = {};
            for (const argumentName of argumentNames) {
              const originalArgumentConfig = originalArgumentConfigMap[argumentName];
              const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
              if (mappedArgument === void 0) {
                newArgumentConfigMap[argumentName] = originalArgumentConfig;
              } else if (Array.isArray(mappedArgument)) {
                const [newArgumentName, newArgumentConfig] = mappedArgument;
                newArgumentConfigMap[newArgumentName] = newArgumentConfig;
              } else if (mappedArgument !== null) {
                newArgumentConfigMap[argumentName] = mappedArgument;
              }
            }
            newFieldConfigMap[fieldName] = {
              ...originalFieldConfig,
              args: newArgumentConfigMap
            };
          }
          if ((0, graphql_1.isObjectType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else if ((0, graphql_1.isInterfaceType)(originalType)) {
            newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({
              ...config2,
              fields: newFieldConfigMap
            });
          } else {
            newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({
              ...config2,
              fields: newFieldConfigMap
            });
          }
        }
      }
      return newTypeMap;
    }
    function mapDirectives(originalDirectives, schema, schemaMapper) {
      const directiveMapper = getDirectiveMapper(schemaMapper);
      if (directiveMapper == null) {
        return originalDirectives.slice();
      }
      const newDirectives = [];
      for (const directive of originalDirectives) {
        const mappedDirective = directiveMapper(directive, schema);
        if (mappedDirective === void 0) {
          newDirectives.push(directive);
        } else if (mappedDirective !== null) {
          newDirectives.push(mappedDirective);
        }
      }
      return newDirectives;
    }
    function getTypeSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.TYPE];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
        }
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
      } else if ((0, graphql_1.isUnionType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
      } else if ((0, graphql_1.isEnumType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
      } else if ((0, graphql_1.isScalarType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
      }
      return specifiers;
    }
    function getTypeMapper(schema, schemaMapper, typeName) {
      const specifiers = getTypeSpecifiers(schema, typeName);
      let typeMapper;
      const stack = [...specifiers];
      while (!typeMapper && stack.length > 0) {
        const next = stack.pop();
        typeMapper = schemaMapper[next];
      }
      return typeMapper != null ? typeMapper : null;
    }
    function getFieldSpecifiers(schema, typeName) {
      var _a, _b, _c;
      const type = schema.getType(typeName);
      const specifiers = [Interfaces_js_1.MapperKind.FIELD];
      if ((0, graphql_1.isObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
        } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
        } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
          specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
        }
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
      }
      return specifiers;
    }
    function getFieldMapper(schema, schemaMapper, typeName) {
      const specifiers = getFieldSpecifiers(schema, typeName);
      let fieldMapper;
      const stack = [...specifiers];
      while (!fieldMapper && stack.length > 0) {
        const next = stack.pop();
        fieldMapper = schemaMapper[next];
      }
      return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
    }
    function getArgumentMapper(schemaMapper) {
      const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
      return argumentMapper != null ? argumentMapper : null;
    }
    function getDirectiveMapper(schemaMapper) {
      const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
      return directiveMapper != null ? directiveMapper : null;
    }
    function getEnumValueMapper(schemaMapper) {
      const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
      return enumValueMapper != null ? enumValueMapper : null;
    }
    function correctASTNodes(type) {
      if ((0, graphql_1.isObjectType)(type)) {
        const config2 = type.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLObjectType(config2);
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        const config2 = type.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInterfaceType(config2);
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        const config2 = type.toConfig();
        if (config2.astNode != null) {
          const fields = [];
          for (const fieldName in config2.fields) {
            const fieldConfig = config2.fields[fieldName];
            if (fieldConfig.astNode != null) {
              fields.push(fieldConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            fields
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            fields: void 0
          }));
        }
        return new graphql_1.GraphQLInputObjectType(config2);
      } else if ((0, graphql_1.isEnumType)(type)) {
        const config2 = type.toConfig();
        if (config2.astNode != null) {
          const values = [];
          for (const enumKey in config2.values) {
            const enumValueConfig = config2.values[enumKey];
            if (enumValueConfig.astNode != null) {
              values.push(enumValueConfig.astNode);
            }
          }
          config2.astNode = {
            ...config2.astNode,
            values
          };
        }
        if (config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
            ...node,
            values: void 0
          }));
        }
        return new graphql_1.GraphQLEnumType(config2);
      } else {
        return type;
      }
    }
    exports.correctASTNodes = correctASTNodes;
  }
});

// node_modules/@graphql-tools/utils/cjs/filterSchema.js
var require_filterSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
      const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
      });
      return filteredSchema;
    }
    exports.filterSchema = filterSchema;
    function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
      if (rootFieldFilter || argumentFilter) {
        const config2 = type.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && field.args) {
            for (const argName in field.args) {
              if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new graphql_1.GraphQLObjectType(config2);
      }
      return type;
    }
    function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
      if (fieldFilter || argumentFilter) {
        const config2 = type.toConfig();
        for (const fieldName in config2.fields) {
          const field = config2.fields[fieldName];
          if (fieldFilter && !fieldFilter(type.name, fieldName, config2.fields[fieldName])) {
            delete config2.fields[fieldName];
          } else if (argumentFilter && "args" in field) {
            for (const argName in field.args) {
              if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                delete field.args[argName];
              }
            }
          }
        }
        return new ElementConstructor(config2);
      }
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/heal.js
var require_heal = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/heal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.healTypes = exports.healSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function healSchema(schema) {
      healTypes(schema.getTypeMap(), schema.getDirectives());
      return schema;
    }
    exports.healSchema = healSchema;
    function healTypes(originalTypeMap, directives) {
      const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (namedType == null || typeName.startsWith("__")) {
          continue;
        }
        const actualName = namedType.name;
        if (actualName.startsWith("__")) {
          continue;
        }
        if (actualNamedTypeMap[actualName] != null) {
          console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
          continue;
        }
        actualNamedTypeMap[actualName] = namedType;
      }
      for (const typeName in actualNamedTypeMap) {
        const namedType = actualNamedTypeMap[typeName];
        originalTypeMap[typeName] = namedType;
      }
      for (const decl of directives) {
        decl.args = decl.args.filter((arg) => {
          arg.type = healType(arg.type);
          return arg.type !== null;
        });
      }
      for (const typeName in originalTypeMap) {
        const namedType = originalTypeMap[typeName];
        if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
          if (namedType != null) {
            healNamedType(namedType);
          }
        }
      }
      for (const typeName in originalTypeMap) {
        if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
          delete originalTypeMap[typeName];
        }
      }
      function healNamedType(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          healFields(type);
          healInterfaces(type);
          return;
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          healFields(type);
          if ("getInterfaces" in type) {
            healInterfaces(type);
          }
          return;
        } else if ((0, graphql_1.isUnionType)(type)) {
          healUnderlyingTypes(type);
          return;
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          healInputFields(type);
          return;
        } else if ((0, graphql_1.isLeafType)(type)) {
          return;
        }
        throw new Error(`Unexpected schema type: ${type}`);
      }
      function healFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.args.map((arg) => {
            arg.type = healType(arg.type);
            return arg.type === null ? null : arg;
          }).filter(Boolean);
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healInterfaces(type) {
        if ("getInterfaces" in type) {
          const interfaces = type.getInterfaces();
          interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
        }
      }
      function healInputFields(type) {
        const fieldMap = type.getFields();
        for (const [key, field] of Object.entries(fieldMap)) {
          field.type = healType(field.type);
          if (field.type === null) {
            delete fieldMap[key];
          }
        }
      }
      function healUnderlyingTypes(type) {
        const types = type.getTypes();
        types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
      }
      function healType(type) {
        if ((0, graphql_1.isListType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const healedType = healType(type.ofType);
          return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const officialType = originalTypeMap[type.name];
          if (officialType && type !== officialType) {
            return officialType;
          }
        }
        return type;
      }
    }
    exports.healTypes = healTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
var require_getResolversFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResolversFromSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function getResolversFromSchema(schema, includeDefaultMergedResolver) {
      var _a, _b;
      const resolvers = /* @__PURE__ */ Object.create(null);
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        if (!typeName.startsWith("__")) {
          const type = typeMap[typeName];
          if ((0, graphql_1.isScalarType)(type)) {
            if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
              const config2 = type.toConfig();
              delete config2.astNode;
              resolvers[typeName] = new graphql_1.GraphQLScalarType(config2);
            }
          } else if ((0, graphql_1.isEnumType)(type)) {
            resolvers[typeName] = {};
            const values = type.getValues();
            for (const value of values) {
              resolvers[typeName][value.name] = value.value;
            }
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isUnionType)(type)) {
            if (type.resolveType != null) {
              resolvers[typeName] = {
                __resolveType: type.resolveType
              };
            }
          } else if ((0, graphql_1.isObjectType)(type)) {
            resolvers[typeName] = {};
            if (type.isTypeOf != null) {
              resolvers[typeName].__isTypeOf = type.isTypeOf;
            }
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              if (field.subscribe != null) {
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].subscribe = field.subscribe;
              }
              if (field.resolve != null && ((_a = field.resolve) === null || _a === void 0 ? void 0 : _a.name) !== "defaultFieldResolver") {
                switch ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) {
                  case "defaultMergedResolver":
                    if (!includeDefaultMergedResolver) {
                      continue;
                    }
                    break;
                  case "defaultFieldResolver":
                    continue;
                }
                resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                resolvers[typeName][fieldName].resolve = field.resolve;
              }
            }
          }
        }
      }
      return resolvers;
    }
    exports.getResolversFromSchema = getResolversFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachField.js
var require_forEachField = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forEachField = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachField(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            fn(field, typeName, fieldName);
          }
        }
      }
    }
    exports.forEachField = forEachField;
  }
});

// node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
var require_forEachDefaultValue = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forEachDefaultValue = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function forEachDefaultValue(schema, fn) {
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
          if ((0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              for (const arg of field.args) {
                arg.defaultValue = fn(arg.type, arg.defaultValue);
              }
            }
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              field.defaultValue = fn(field.type, field.defaultValue);
            }
          }
        }
      }
    }
    exports.forEachDefaultValue = forEachDefaultValue;
  }
});

// node_modules/@graphql-tools/utils/cjs/addTypes.js
var require_addTypes = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
    var rewire_js_1 = require_rewire();
    function addTypes(schema, newTypesOrDirectives) {
      const config2 = schema.toConfig();
      const originalTypeMap = {};
      for (const type of config2.types) {
        originalTypeMap[type.name] = type;
      }
      const originalDirectiveMap = {};
      for (const directive of config2.directives) {
        originalDirectiveMap[directive.name] = directive;
      }
      for (const newTypeOrDirective of newTypesOrDirectives) {
        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
          originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
        } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
          originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
        }
      }
      const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
      return new graphql_1.GraphQLSchema({
        ...config2,
        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
        types: Object.values(typeMap),
        directives
      });
    }
    exports.addTypes = addTypes;
  }
});

// node_modules/@graphql-tools/utils/cjs/prune.js
var require_prune = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/prune.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pruneSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    var rootTypes_js_1 = require_rootTypes();
    var get_implementing_types_js_1 = require_get_implementing_types();
    function pruneSchema(schema, options = {}) {
      const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
      let prunedTypes = [];
      let prunedSchema = schema;
      do {
        let visited = visitSchema(prunedSchema);
        if (skipPruning) {
          const revisit = [];
          for (const typeName in prunedSchema.getTypeMap()) {
            if (typeName.startsWith("__")) {
              continue;
            }
            const type = prunedSchema.getType(typeName);
            if (type && skipPruning(type)) {
              revisit.push(typeName);
            }
          }
          visited = visitQueue(revisit, prunedSchema, visited);
        }
        prunedTypes = [];
        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
          [Interfaces_js_1.MapperKind.TYPE]: (type) => {
            if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
              if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                if (skipUnusedTypesPruning) {
                  return type;
                }
                if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                  return type;
                }
                if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                  if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                    return type;
                  }
                }
                if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                  return type;
                }
              }
              prunedTypes.push(type.name);
              visited.delete(type.name);
              return null;
            }
            return type;
          }
        });
      } while (prunedTypes.length);
      return prunedSchema;
    }
    exports.pruneSchema = pruneSchema;
    function visitSchema(schema) {
      const queue2 = [];
      for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
        queue2.push(type.name);
      }
      return visitQueue(queue2, schema);
    }
    function visitQueue(queue2, schema, visited = /* @__PURE__ */ new Set()) {
      const revisit = /* @__PURE__ */ new Map();
      while (queue2.length) {
        const typeName = queue2.pop();
        if (visited.has(typeName) && revisit[typeName] !== true) {
          continue;
        }
        const type = schema.getType(typeName);
        if (type) {
          if ((0, graphql_1.isUnionType)(type)) {
            queue2.push(...type.getTypes().map((type2) => type2.name));
          }
          if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
            queue2.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
            revisit[typeName] = false;
          }
          if ((0, graphql_1.isEnumType)(type)) {
            queue2.push(...type.getValues().flatMap((value) => {
              if (value.astNode) {
                return getDirectivesArgumentsTypeNames(schema, value.astNode);
              }
              return [];
            }));
          }
          if ("getInterfaces" in type) {
            queue2.push(...type.getInterfaces().map((iface) => iface.name));
          }
          if ("getFields" in type) {
            const fields = type.getFields();
            const entries = Object.entries(fields);
            if (!entries.length) {
              continue;
            }
            for (const [, field] of entries) {
              if ((0, graphql_1.isObjectType)(type)) {
                queue2.push(...field.args.flatMap((arg) => {
                  const typeNames = [(0, graphql_1.getNamedType)(arg.type).name];
                  if (arg.astNode) {
                    typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                  }
                  return typeNames;
                }));
              }
              const namedType = (0, graphql_1.getNamedType)(field.type);
              queue2.push(namedType.name);
              if (field.astNode) {
                queue2.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
              }
              if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                revisit[namedType.name] = true;
              }
            }
          }
          if (type.astNode) {
            queue2.push(...getDirectivesArgumentsTypeNames(schema, type.astNode));
          }
          visited.add(typeName);
        }
      }
      return visited;
    }
    function getDirectivesArgumentsTypeNames(schema, astNode) {
      var _a;
      return ((_a = astNode.directives) !== null && _a !== void 0 ? _a : []).flatMap((directive) => {
        var _a2, _b;
        return (_b = (_a2 = schema.getDirective(directive.name.value)) === null || _a2 === void 0 ? void 0 : _a2.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name)) !== null && _b !== void 0 ? _b : [];
      });
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/mergeDeep.js
var require_mergeDeep = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDeep = void 0;
    var helpers_js_1 = require_helpers();
    function mergeDeep(sources, respectPrototype = false) {
      const target = sources[0] || {};
      const output = {};
      if (respectPrototype) {
        Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
      }
      for (const source of sources) {
        if (isObject2(target) && isObject2(source)) {
          if (respectPrototype) {
            const outputPrototype = Object.getPrototypeOf(output);
            const sourcePrototype = Object.getPrototypeOf(source);
            if (sourcePrototype) {
              for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                if ((0, helpers_js_1.isSome)(descriptor)) {
                  Object.defineProperty(outputPrototype, key, descriptor);
                }
              }
            }
          }
          for (const key in source) {
            if (isObject2(source[key])) {
              if (!(key in output)) {
                Object.assign(output, { [key]: source[key] });
              } else {
                output[key] = mergeDeep([output[key], source[key]], respectPrototype);
              }
            } else {
              Object.assign(output, { [key]: source[key] });
            }
          }
        }
      }
      return output;
    }
    exports.mergeDeep = mergeDeep;
    function isObject2(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/selectionSets.js
var require_selectionSets = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseSelectionSet = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function parseSelectionSet(selectionSet, options) {
      const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
      return query.selectionSet;
    }
    exports.parseSelectionSet = parseSelectionSet;
  }
});

// node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
var require_getResponseKeyFromInfo = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getResponseKeyFromInfo = void 0;
    function getResponseKeyFromInfo(info) {
      return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
    }
    exports.getResponseKeyFromInfo = getResponseKeyFromInfo;
  }
});

// node_modules/@graphql-tools/utils/cjs/fields.js
var require_fields = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fields.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modifyObjectFields = exports.selectObjectFields = exports.removeObjectFields = exports.appendObjectFields = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var Interfaces_js_1 = require_Interfaces();
    var mapSchema_js_1 = require_mapSchema();
    var addTypes_js_1 = require_addTypes();
    function appendObjectFields(schema, typeName, additionalFields) {
      if (schema.getType(typeName) == null) {
        return (0, addTypes_js_1.addTypes)(schema, [
          new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: additionalFields
          })
        ]);
      }
      return (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config2 = type.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
            }
            for (const fieldName in additionalFields) {
              newFieldConfigMap[fieldName] = additionalFields[fieldName];
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
    }
    exports.appendObjectFields = appendObjectFields;
    function removeObjectFields(schema, typeName, testFn) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config2 = type.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports.removeObjectFields = removeObjectFields;
    function selectObjectFields(schema, typeName, testFn) {
      const selectedFields = {};
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config2 = type.toConfig();
            const originalFieldConfigMap = config2.fields;
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                selectedFields[fieldName] = originalFieldConfig;
              }
            }
          }
          return void 0;
        }
      });
      return selectedFields;
    }
    exports.selectObjectFields = selectObjectFields;
    function modifyObjectFields(schema, typeName, testFn, newFields) {
      const removedFields = {};
      const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          if (type.name === typeName) {
            const config2 = type.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              if (testFn(fieldName, originalFieldConfig)) {
                removedFields[fieldName] = originalFieldConfig;
              } else {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              }
            }
            for (const fieldName in newFields) {
              const fieldConfig = newFields[fieldName];
              newFieldConfigMap[fieldName] = fieldConfig;
            }
            return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType({
              ...config2,
              fields: newFieldConfigMap
            }));
          }
        }
      });
      return [newSchema, removedFields];
    }
    exports.modifyObjectFields = modifyObjectFields;
  }
});

// node_modules/@graphql-tools/utils/cjs/renameType.js
var require_renameType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/renameType.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renameType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function renameType(type, newTypeName) {
      if ((0, graphql_1.isObjectType)(type)) {
        return new graphql_1.GraphQLObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInterfaceType)(type)) {
        return new graphql_1.GraphQLInterfaceType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isUnionType)(type)) {
        return new graphql_1.GraphQLUnionType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isInputObjectType)(type)) {
        return new graphql_1.GraphQLInputObjectType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isEnumType)(type)) {
        return new graphql_1.GraphQLEnumType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      } else if ((0, graphql_1.isScalarType)(type)) {
        return new graphql_1.GraphQLScalarType({
          ...type.toConfig(),
          name: newTypeName,
          astNode: type.astNode == null ? type.astNode : {
            ...type.astNode,
            name: {
              ...type.astNode.name,
              value: newTypeName
            }
          },
          extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => ({
            ...node,
            name: {
              ...node.name,
              value: newTypeName
            }
          }))
        });
      }
      throw new Error(`Unknown type ${type}.`);
    }
    exports.renameType = renameType;
  }
});

// node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapAsyncIterator = void 0;
    function mapAsyncIterator2(iterator, callback, rejectCallback) {
      let $return;
      let abruptClose;
      if (typeof iterator.return === "function") {
        $return = iterator.return;
        abruptClose = (error) => {
          const rethrow = () => Promise.reject(error);
          return $return.call(iterator).then(rethrow, rethrow);
        };
      }
      function mapResult(result) {
        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
      }
      let mapReject;
      if (rejectCallback) {
        const reject = rejectCallback;
        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
      }
      return {
        next() {
          return iterator.next().then(mapResult, mapReject);
        },
        return() {
          return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          if (typeof iterator.throw === "function") {
            return iterator.throw(error).then(mapResult, mapReject);
          }
          return Promise.reject(error).catch(abruptClose);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports.mapAsyncIterator = mapAsyncIterator2;
    function asyncMapValue(value, callback) {
      return new Promise((resolve) => resolve(callback(value)));
    }
    function iteratorResult(value) {
      return { value, done: false };
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/updateArgument.js
var require_updateArgument = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVariableNameGenerator = exports.updateArgument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var astFromType_js_1 = require_astFromType();
    function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
      argumentNodes[argName] = {
        kind: graphql_1.Kind.ARGUMENT,
        name: {
          kind: graphql_1.Kind.NAME,
          value: argName
        },
        value: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        }
      };
      variableDefinitionsMap[varName] = {
        kind: graphql_1.Kind.VARIABLE_DEFINITION,
        variable: {
          kind: graphql_1.Kind.VARIABLE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: varName
          }
        },
        type: (0, astFromType_js_1.astFromType)(type)
      };
      if (value !== void 0) {
        variableValues[varName] = value;
        return;
      }
      if (varName in variableValues) {
        delete variableValues[varName];
      }
    }
    exports.updateArgument = updateArgument;
    function createVariableNameGenerator(variableDefinitionMap) {
      let varCounter = 0;
      return (argName) => {
        let varName;
        do {
          varName = `_v${(varCounter++).toString()}_${argName}`;
        } while (varName in variableDefinitionMap);
        return varName;
      };
    }
    exports.createVariableNameGenerator = createVariableNameGenerator;
  }
});

// node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
var require_implementsAbstractType = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.implementsAbstractType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function implementsAbstractType(schema, typeA, typeB) {
      if (typeB == null || typeA == null) {
        return false;
      } else if (typeA === typeB) {
        return true;
      } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
        return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
      }
      return false;
    }
    exports.implementsAbstractType = implementsAbstractType;
  }
});

// node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
var require_observableToAsyncIterable = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observableToAsyncIterable = void 0;
    function observableToAsyncIterable(observable) {
      const pullQueue = [];
      const pushQueue = [];
      let listening = true;
      const pushValue = (value) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value, done: false });
        } else {
          pushQueue.push({ value, done: false });
        }
      };
      const pushError = (error) => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ value: { errors: [error] }, done: false });
        } else {
          pushQueue.push({ value: { errors: [error] }, done: false });
        }
      };
      const pushDone = () => {
        if (pullQueue.length !== 0) {
          pullQueue.shift()({ done: true });
        } else {
          pushQueue.push({ done: true });
        }
      };
      const pullValue = () => new Promise((resolve) => {
        if (pushQueue.length !== 0) {
          const element = pushQueue.shift();
          resolve(element);
        } else {
          pullQueue.push(resolve);
        }
      });
      const subscription = observable.subscribe({
        next(value) {
          pushValue(value);
        },
        error(err) {
          pushError(err);
        },
        complete() {
          pushDone();
        }
      });
      const emptyQueue = () => {
        if (listening) {
          listening = false;
          subscription.unsubscribe();
          for (const resolve of pullQueue) {
            resolve({ value: void 0, done: true });
          }
          pullQueue.length = 0;
          pushQueue.length = 0;
        }
      };
      return {
        next() {
          return listening ? pullValue() : this.return();
        },
        return() {
          emptyQueue();
          return Promise.resolve({ value: void 0, done: true });
        },
        throw(error) {
          emptyQueue();
          return Promise.reject(error);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    exports.observableToAsyncIterable = observableToAsyncIterable;
  }
});

// node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
var require_getOperationASTFromRequest = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOperationASTFromRequest = exports.getOperationASTFromDocument = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var memoize_js_1 = require_memoize();
    function getOperationASTFromDocument(documentNode, operationName) {
      const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
      if (!doc) {
        throw new Error(`Cannot infer operation ${operationName || ""}`);
      }
      return doc;
    }
    exports.getOperationASTFromDocument = getOperationASTFromDocument;
    exports.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
      return getOperationASTFromDocument(request.document, request.operationName);
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/directives.js
var require_directives = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphQLStreamDirective = exports.GraphQLDeferDirective = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    exports.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
      name: "defer",
      description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FRAGMENT_SPREAD, graphql_1.DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Deferred when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        }
      }
    });
    exports.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
      name: "stream",
      description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
      locations: [graphql_1.DirectiveLocation.FIELD],
      args: {
        if: {
          type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
          description: "Stream when true or undefined.",
          defaultValue: true
        },
        label: {
          type: graphql_1.GraphQLString,
          description: "Unique name"
        },
        initialCount: {
          defaultValue: 0,
          type: graphql_1.GraphQLInt,
          description: "Number of items to return immediately"
        }
      }
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js
var require_AccumulatorMap = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccumulatorMap = void 0;
    var AccumulatorMap = class extends Map {
      get [Symbol.toStringTag]() {
        return "AccumulatorMap";
      }
      add(key, item) {
        const group = this.get(key);
        if (group === void 0) {
          this.set(key, [item]);
        } else {
          group.push(item);
        }
      }
    };
    exports.AccumulatorMap = AccumulatorMap;
  }
});

// node_modules/@graphql-tools/utils/cjs/collectFields.js
var require_collectFields = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectSubFields = exports.getDeferValues = exports.getFieldEntryKey = exports.doesFragmentConditionMatch = exports.shouldIncludeNode = exports.collectFields = void 0;
    var memoize_js_1 = require_memoize();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives();
    var AccumulatorMap_js_1 = require_AccumulatorMap();
    function collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case graphql_1.Kind.FIELD: {
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            fields.add(getFieldEntryKey2(selection), selection);
            break;
          }
          case graphql_1.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
          case graphql_1.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (!shouldIncludeNode2(variableValues, selection)) {
              continue;
            }
            const defer = getDeferValues(variableValues, selection);
            if (visitedFragmentNames.has(fragName) && !defer) {
              continue;
            }
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
              continue;
            }
            if (!defer) {
              visitedFragmentNames.add(fragName);
            }
            if (defer) {
              const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
              patches.push({
                label: defer.label,
                fields: patchFields
              });
            } else {
              collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
            }
            break;
          }
        }
      }
    }
    function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = new AccumulatorMap_js_1.AccumulatorMap();
      const patches = [];
      collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
      return { fields, patches };
    }
    exports.collectFields = collectFields2;
    function shouldIncludeNode2(variableValues, node) {
      const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
      if ((skip === null || skip === void 0 ? void 0 : skip["if"]) === true) {
        return false;
      }
      const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
      if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
        return false;
      }
      return true;
    }
    exports.shouldIncludeNode = shouldIncludeNode2;
    function doesFragmentConditionMatch2(schema, fragment, type) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
      if (conditionalType === type) {
        return true;
      }
      if ((0, graphql_1.isAbstractType)(conditionalType)) {
        const possibleTypes = schema.getPossibleTypes(conditionalType);
        return possibleTypes.includes(type);
      }
      return false;
    }
    exports.doesFragmentConditionMatch = doesFragmentConditionMatch2;
    function getFieldEntryKey2(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    exports.getFieldEntryKey = getFieldEntryKey2;
    function getDeferValues(variableValues, node) {
      const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
      if (!defer) {
        return;
      }
      if (defer["if"] === false) {
        return;
      }
      return {
        label: typeof defer["label"] === "string" ? defer["label"] : void 0
      };
    }
    exports.getDeferValues = getDeferValues;
    exports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields3(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      const subPatches = [];
      const subFieldsAndPatches = {
        fields: subFieldNodes,
        patches: subPatches
      };
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl2(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
        }
      }
      return subFieldsAndPatches;
    });
  }
});

// node_modules/@graphql-tools/utils/cjs/visitResult.js
var require_visitResult = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.visitResult = exports.visitErrors = exports.visitData = void 0;
    var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest();
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var collectFields_js_1 = require_collectFields();
    function visitData(data, enter, leave) {
      if (Array.isArray(data)) {
        return data.map((value) => visitData(value, enter, leave));
      } else if (typeof data === "object") {
        const newData = enter != null ? enter(data) : data;
        if (newData != null) {
          for (const key in newData) {
            const value = newData[key];
            Object.defineProperty(newData, key, {
              value: visitData(value, enter, leave)
            });
          }
        }
        return leave != null ? leave(newData) : newData;
      }
      return data;
    }
    exports.visitData = visitData;
    function visitErrors(errors, visitor) {
      return errors.map((error) => visitor(error));
    }
    exports.visitErrors = visitErrors;
    function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
      const fragments = request.document.definitions.reduce((acc, def) => {
        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
          acc[def.name.value] = def;
        }
        return acc;
      }, {});
      const variableValues = request.variables || {};
      const errorInfo = {
        segmentInfoMap: /* @__PURE__ */ new Map(),
        unpathedErrors: /* @__PURE__ */ new Set()
      };
      const data = result.data;
      const errors = result.errors;
      const visitingErrors = errors != null && errorVisitorMap != null;
      const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
      if (data != null && operationDocumentNode != null) {
        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
      }
      if (errors != null && errorVisitorMap) {
        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
      }
      return result;
    }
    exports.visitResult = visitResult;
    function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
      const segmentInfoMap = errorInfo.segmentInfoMap;
      const unpathedErrors = errorInfo.unpathedErrors;
      const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
      return errors.map((originalError) => {
        const pathSegmentsInfo = segmentInfoMap.get(originalError);
        const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
          const typeName = segmentInfo.type.name;
          const typeVisitorMap = errorVisitorMap[typeName];
          if (typeVisitorMap == null) {
            return acc;
          }
          const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
          return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
        }, originalError);
        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
          return unpathedErrorVisitor(newError);
        }
        return newError;
      });
    }
    function getOperationRootType2(schema, operationDef) {
      switch (operationDef.operation) {
        case "query":
          return schema.getQueryType();
        case "mutation":
          return schema.getMutationType();
        case "subscription":
          return schema.getSubscriptionType();
      }
    }
    function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
      const operationRootType = getOperationRootType2(schema, operation);
      const { fields: collectedFields } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
      return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
    }
    function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      var _a;
      const fieldMap = type.getFields();
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];
      const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;
      const newObject = enterObject != null ? enterObject(object) : object;
      let sortedErrors;
      let errorMap = null;
      if (errors != null) {
        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
        errorMap = sortedErrors.errorMap;
        for (const error of sortedErrors.unpathedErrors) {
          errorInfo.unpathedErrors.add(error);
        }
      }
      for (const [responseKey, subFieldNodes] of fieldNodeMap) {
        const fieldName = subFieldNodes[0].name.value;
        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;
        if (fieldType == null) {
          switch (fieldName) {
            case "__typename":
              fieldType = graphql_1.TypeNameMetaFieldDef.type;
              break;
            case "__schema":
              fieldType = graphql_1.SchemaMetaFieldDef.type;
              break;
            case "__type":
              fieldType = graphql_1.TypeMetaFieldDef.type;
              break;
          }
        }
        const newPathIndex = pathIndex + 1;
        let fieldErrors;
        if (errorMap) {
          fieldErrors = errorMap[responseKey];
          if (fieldErrors != null) {
            delete errorMap[responseKey];
          }
          addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
        }
        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
      }
      const oldTypename = newObject.__typename;
      if (oldTypename != null) {
        updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
      }
      if (errorMap) {
        for (const errorsKey in errorMap) {
          const errors2 = errorMap[errorsKey];
          for (const error of errors2) {
            errorInfo.unpathedErrors.add(error);
          }
        }
      }
      const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;
      return leaveObject != null ? leaveObject(newObject) : newObject;
    }
    function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
      if (typeVisitorMap == null) {
        object[responseKey] = newValue;
        return;
      }
      const fieldVisitor = typeVisitorMap[fieldName];
      if (fieldVisitor == null) {
        object[responseKey] = newValue;
        return;
      }
      const visitedValue = fieldVisitor(newValue);
      if (visitedValue === void 0) {
        delete object[responseKey];
        return;
      }
      object[responseKey] = visitedValue;
    }
    function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
      return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
    }
    function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
      if (value == null) {
        return value;
      }
      const nullableType = (0, graphql_1.getNullableType)(returnType);
      if ((0, graphql_1.isListType)(nullableType)) {
        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isAbstractType)(nullableType)) {
        const finalType = schema.getType(value.__typename);
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      } else if ((0, graphql_1.isObjectType)(nullableType)) {
        const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
      }
      const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];
      if (typeVisitorMap == null) {
        return value;
      }
      const visitedValue = typeVisitorMap(value);
      return visitedValue === void 0 ? value : visitedValue;
    }
    function sortErrorsByPathSegment(errors, pathIndex) {
      var _a;
      const errorMap = /* @__PURE__ */ Object.create(null);
      const unpathedErrors = /* @__PURE__ */ new Set();
      for (const error of errors) {
        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];
        if (pathSegment == null) {
          unpathedErrors.add(error);
          continue;
        }
        if (pathSegment in errorMap) {
          errorMap[pathSegment].push(error);
        } else {
          errorMap[pathSegment] = [error];
        }
      }
      return {
        errorMap,
        unpathedErrors
      };
    }
    function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
      for (const error of errors) {
        const segmentInfo = {
          type,
          fieldName,
          pathIndex
        };
        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
        if (pathSegmentsInfo == null) {
          errorInfo.segmentInfoMap.set(error, [segmentInfo]);
        } else {
          pathSegmentsInfo.push(segmentInfo);
        }
      }
    }
  }
});

// node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
var require_valueMatchesCriteria = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.valueMatchesCriteria = void 0;
    function valueMatchesCriteria(value, criteria) {
      if (value == null) {
        return value === criteria;
      } else if (Array.isArray(value)) {
        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
      } else if (typeof value === "object") {
        return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
      } else if (criteria instanceof RegExp) {
        return criteria.test(value);
      }
      return value === criteria;
    }
    exports.valueMatchesCriteria = valueMatchesCriteria;
  }
});

// node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = void 0;
    function isAsyncIterable2(value) {
      return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
    }
    exports.isAsyncIterable = isAsyncIterable2;
  }
});

// node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
var require_isDocumentNode = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isDocumentNode = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isDocumentNode(object) {
      return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
    }
    exports.isDocumentNode = isDocumentNode;
  }
});

// node_modules/@graphql-tools/utils/cjs/executor.js
var require_executor = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/executor.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/utils/cjs/withCancel.js
var require_withCancel = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withCancel = exports.getAsyncIterableWithCancel = exports.getAsyncIteratorWithCancel = void 0;
    var memoize_js_1 = require_memoize();
    async function defaultAsyncIteratorReturn(value) {
      return { value, done: true };
    }
    var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
      return function proxyMethod(...args) {
        return Reflect.apply(targetMethod, target, args);
      };
    });
    function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
      return new Proxy(asyncIterator, {
        has(asyncIterator2, prop) {
          if (prop === "return") {
            return true;
          }
          return Reflect.has(asyncIterator2, prop);
        },
        get(asyncIterator2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
          if (prop === "return") {
            const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
            return async function returnWithCancel(value) {
              const returnValue = await onCancel(value);
              return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterator2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
    function getAsyncIterableWithCancel(asyncIterable, onCancel) {
      return new Proxy(asyncIterable, {
        get(asyncIterable2, prop, receiver) {
          const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
          if (Symbol.asyncIterator === prop) {
            return function asyncIteratorFactory() {
              const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
              return getAsyncIteratorWithCancel(asyncIterator, onCancel);
            };
          } else if (typeof existingPropValue === "function") {
            return proxyMethodFactory(asyncIterable2, existingPropValue);
          }
          return existingPropValue;
        }
      });
    }
    exports.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
    exports.withCancel = getAsyncIterableWithCancel;
  }
});

// node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
var require_fixSchemaAst = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fixSchemaAst = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var print_schema_with_directives_js_1 = require_print_schema_with_directives();
    function buildFixedSchema(schema, options) {
      const document2 = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
      return (0, graphql_1.buildASTSchema)(document2, {
        ...options || {}
      });
    }
    function fixSchemaAst(schema, options) {
      let schemaWithValidAst = void 0;
      if (!schema.astNode || !schema.extensionASTNodes) {
        schemaWithValidAst = buildFixedSchema(schema, options);
      }
      if (!schema.astNode && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.astNode = schemaWithValidAst.astNode;
      }
      if (!schema.extensionASTNodes && (schemaWithValidAst === null || schemaWithValidAst === void 0 ? void 0 : schemaWithValidAst.astNode)) {
        schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
      }
      return schema;
    }
    exports.fixSchemaAst = fixSchemaAst;
  }
});

// node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js
var require_extractExtensionsFromSchema = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractExtensionsFromSchema = void 0;
    var mapSchema_js_1 = require_mapSchema();
    var Interfaces_js_1 = require_Interfaces();
    function extractExtensionsFromSchema(schema) {
      const result = {
        schemaExtensions: schema.extensions || {},
        types: {}
      };
      (0, mapSchema_js_1.mapSchema)(schema, {
        [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            arguments: {},
            extensions: field.extensions || {}
          };
          const args = field.args;
          if (args != null) {
            for (const argName in args) {
              result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
            }
          }
          return field;
        },
        [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
          result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
          result.types[typeName].values[valueName] = value.extensions || {};
          return value;
        },
        [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => {
          result.types[type.name] = { type: "scalar", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => {
          result.types[type.name] = { type: "union", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => {
          result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} };
          return type;
        },
        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
          result.types[typeName].fields[fieldName] = {
            extensions: field.extensions || {}
          };
          return field;
        }
      });
      return result;
    }
    exports.extractExtensionsFromSchema = extractExtensionsFromSchema;
  }
});

// node_modules/@graphql-tools/utils/cjs/Path.js
var require_Path = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/Path.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printPathArray = exports.pathToArray = exports.addPath = void 0;
    function addPath2(prev, key, typename) {
      return { prev, key, typename };
    }
    exports.addPath = addPath2;
    function pathToArray2(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    exports.pathToArray = pathToArray2;
    function printPathArray2(path) {
      return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
    }
    exports.printPathArray = printPathArray2;
  }
});

// node_modules/@graphql-tools/utils/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@graphql-tools/utils/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_loaders(), exports);
    tslib_1.__exportStar(require_helpers(), exports);
    tslib_1.__exportStar(require_get_directives(), exports);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports);
    tslib_1.__exportStar(require_get_arguments_with_directives(), exports);
    tslib_1.__exportStar(require_get_implementing_types(), exports);
    tslib_1.__exportStar(require_print_schema_with_directives(), exports);
    tslib_1.__exportStar(require_get_fields_with_directives(), exports);
    tslib_1.__exportStar(require_validate_documents(), exports);
    tslib_1.__exportStar(require_parse_graphql_json(), exports);
    tslib_1.__exportStar(require_parse_graphql_sdl(), exports);
    tslib_1.__exportStar(require_build_operation_for_field(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_filterSchema(), exports);
    tslib_1.__exportStar(require_heal(), exports);
    tslib_1.__exportStar(require_getResolversFromSchema(), exports);
    tslib_1.__exportStar(require_forEachField(), exports);
    tslib_1.__exportStar(require_forEachDefaultValue(), exports);
    tslib_1.__exportStar(require_mapSchema(), exports);
    tslib_1.__exportStar(require_addTypes(), exports);
    tslib_1.__exportStar(require_rewire(), exports);
    tslib_1.__exportStar(require_prune(), exports);
    tslib_1.__exportStar(require_mergeDeep(), exports);
    tslib_1.__exportStar(require_Interfaces(), exports);
    tslib_1.__exportStar(require_stub(), exports);
    tslib_1.__exportStar(require_selectionSets(), exports);
    tslib_1.__exportStar(require_getResponseKeyFromInfo(), exports);
    tslib_1.__exportStar(require_fields(), exports);
    tslib_1.__exportStar(require_renameType(), exports);
    tslib_1.__exportStar(require_transformInputValue(), exports);
    tslib_1.__exportStar(require_mapAsyncIterator(), exports);
    tslib_1.__exportStar(require_updateArgument(), exports);
    tslib_1.__exportStar(require_implementsAbstractType(), exports);
    tslib_1.__exportStar(require_errors(), exports);
    tslib_1.__exportStar(require_observableToAsyncIterable(), exports);
    tslib_1.__exportStar(require_visitResult(), exports);
    tslib_1.__exportStar(require_getArgumentValues(), exports);
    tslib_1.__exportStar(require_valueMatchesCriteria(), exports);
    tslib_1.__exportStar(require_isAsyncIterable(), exports);
    tslib_1.__exportStar(require_isDocumentNode(), exports);
    tslib_1.__exportStar(require_astFromValueUntyped(), exports);
    tslib_1.__exportStar(require_executor(), exports);
    tslib_1.__exportStar(require_withCancel(), exports);
    tslib_1.__exportStar(require_AggregateError(), exports);
    tslib_1.__exportStar(require_rootTypes(), exports);
    tslib_1.__exportStar(require_comments(), exports);
    tslib_1.__exportStar(require_collectFields(), exports);
    tslib_1.__exportStar(require_inspect(), exports);
    tslib_1.__exportStar(require_memoize(), exports);
    tslib_1.__exportStar(require_fixSchemaAst(), exports);
    tslib_1.__exportStar(require_getOperationASTFromRequest(), exports);
    tslib_1.__exportStar(require_extractExtensionsFromSchema(), exports);
    tslib_1.__exportStar(require_Path(), exports);
    tslib_1.__exportStar(require_jsutils(), exports);
    tslib_1.__exportStar(require_directives(), exports);
  }
});

// node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js
var require_assertResolversPresent = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertResolversPresent = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function assertResolversPresent(schema, resolverValidationOptions = {}) {
      const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
      if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
        throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
      }
      (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {
        if (requireResolversForAllFields) {
          expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
        }
        if (requireResolversForArgs && field.args.length > 0) {
          expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
        }
        if (requireResolversForNonScalar !== "ignore" && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {
          expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
        }
      });
    }
    exports.assertResolversPresent = assertResolversPresent;
    function expectResolver(validator, behavior, field, typeName, fieldName) {
      if (!field.resolve) {
        const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
        if (behavior === "error") {
          throw new Error(message);
        }
        if (behavior === "warn") {
          console.warn(message);
        }
        return;
      }
      if (typeof field.resolve !== "function") {
        throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
      }
    }
  }
});

// node_modules/@graphql-tools/schema/cjs/chainResolvers.js
var require_chainResolvers = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/chainResolvers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainResolvers = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function chainResolvers(resolvers) {
      return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {
        if (curResolver != null) {
          return curResolver(prev, args, ctx, info);
        }
        return (0, graphql_1.defaultFieldResolver)(prev, args, ctx, info);
      }, root);
    }
    exports.chainResolvers = chainResolvers;
  }
});

// node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js
var require_checkForResolveTypeResolver = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/checkForResolveTypeResolver.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkForResolveTypeResolver = void 0;
    var utils_1 = require_cjs();
    function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
      (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.ABSTRACT_TYPE]: (type) => {
          if (!type.resolveType) {
            const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
            if (requireResolversForResolveType === "error") {
              throw new Error(message);
            }
            if (requireResolversForResolveType === "warn") {
              console.warn(message);
            }
          }
          return void 0;
        }
      });
    }
    exports.checkForResolveTypeResolver = checkForResolveTypeResolver;
  }
});

// node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js
var require_extendResolversFromInterfaces = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/extendResolversFromInterfaces.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendResolversFromInterfaces = void 0;
    function extendResolversFromInterfaces(schema, resolvers) {
      const extendedResolvers = {};
      const typeMap = schema.getTypeMap();
      for (const typeName in typeMap) {
        const type = typeMap[typeName];
        if ("getInterfaces" in type) {
          extendedResolvers[typeName] = {};
          for (const iFace of type.getInterfaces()) {
            if (resolvers[iFace.name]) {
              for (const fieldName in resolvers[iFace.name]) {
                if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
                  extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
                }
              }
            }
          }
          const typeResolvers = resolvers[typeName];
          extendedResolvers[typeName] = {
            ...extendedResolvers[typeName],
            ...typeResolvers
          };
        } else {
          const typeResolvers = resolvers[typeName];
          if (typeResolvers != null) {
            extendedResolvers[typeName] = typeResolvers;
          }
        }
      }
      return extendedResolvers;
    }
    exports.extendResolversFromInterfaces = extendResolversFromInterfaces;
  }
});

// node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js
var require_addResolversToSchema = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addResolversToSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver2, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
      const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
      const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;
      for (const typeName in resolvers) {
        const resolverValue = resolvers[typeName];
        const resolverType = typeof resolverValue;
        if (resolverType !== "object") {
          throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
        }
        const type = schema.getType(typeName);
        if (type == null) {
          if (requireResolversToMatchSchema === "ignore") {
            continue;
          }
          throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
        } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const values = type.getValues();
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);
            }
          }
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (!fieldName.startsWith("__")) {
              const fields = type.getFields();
              const field = fields[fieldName];
              if (field == null) {
                if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
                  throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
                }
              } else {
                const fieldResolve = resolverValue[fieldName];
                if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
                  throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
                }
              }
            }
          }
        }
      }
      schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2);
      if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);
      }
      return schema;
    }
    exports.addResolversToSchema = addResolversToSchema;
    function addResolversToExistingSchema(schema, resolvers, defaultFieldResolver2) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeMap = schema.getTypeMap();
      for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        const resolverValue = resolvers[typeName];
        if ((0, graphql_1.isScalarType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && type.astNode != null) {
              type.astNode = {
                ...type.astNode,
                description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,
                directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
              };
            } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
              type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else {
              type[fieldName] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config2 = type.toConfig();
          const enumValueConfigMap = config2.values;
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              config2[fieldName.substring(2)] = resolverValue[fieldName];
            } else if (fieldName === "astNode" && config2.astNode != null) {
              config2.astNode = {
                ...config2.astNode,
                description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
                directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
              };
            } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
              config2.extensionASTNodes = config2.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
            } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
              type.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
            } else if (enumValueConfigMap[fieldName]) {
              enumValueConfigMap[fieldName].value = resolverValue[fieldName];
            }
          }
          typeMap[typeName] = new graphql_1.GraphQLEnumType(config2);
        } else if ((0, graphql_1.isUnionType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
            }
          }
        } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {
          for (const fieldName in resolverValue) {
            if (fieldName.startsWith("__")) {
              type[fieldName.substring(2)] = resolverValue[fieldName];
              continue;
            }
            const fields = type.getFields();
            const field = fields[fieldName];
            if (field != null) {
              const fieldResolve = resolverValue[fieldName];
              if (typeof fieldResolve === "function") {
                field.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(field, fieldResolve);
              }
            }
          }
        }
      }
      (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);
      (0, utils_1.healSchema)(schema);
      (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);
      if (defaultFieldResolver2 != null) {
        (0, utils_1.forEachField)(schema, (field) => {
          if (!field.resolve) {
            field.resolve = defaultFieldResolver2;
          }
        });
      }
      return schema;
    }
    function createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver2) {
      schema = (0, utils_1.mapSchema)(schema, {
        [utils_1.MapperKind.SCALAR_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const config2 = type.toConfig();
          const resolverValue = resolvers[type.name];
          if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else {
                config2[fieldName] = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLScalarType(config2);
          }
        },
        [utils_1.MapperKind.ENUM_TYPE]: (type) => {
          var _a, _b, _c, _d, _e, _f;
          const resolverValue = resolvers[type.name];
          const config2 = type.toConfig();
          const enumValueConfigMap = config2.values;
          if (resolverValue != null) {
            for (const fieldName in resolverValue) {
              if (fieldName.startsWith("__")) {
                config2[fieldName.substring(2)] = resolverValue[fieldName];
              } else if (fieldName === "astNode" && config2.astNode != null) {
                config2.astNode = {
                  ...config2.astNode,
                  description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
                  directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
                };
              } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
                config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
              } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
                config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type.extensions, resolverValue.extensions);
              } else if (enumValueConfigMap[fieldName]) {
                enumValueConfigMap[fieldName].value = resolverValue[fieldName];
              }
            }
            return new graphql_1.GraphQLEnumType(config2);
          }
        },
        [utils_1.MapperKind.UNION_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config2 = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLUnionType(config2);
          }
        },
        [utils_1.MapperKind.OBJECT_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config2 = type.toConfig();
            if (resolverValue["__isTypeOf"]) {
              config2.isTypeOf = resolverValue["__isTypeOf"];
            }
            return new graphql_1.GraphQLObjectType(config2);
          }
        },
        [utils_1.MapperKind.INTERFACE_TYPE]: (type) => {
          const resolverValue = resolvers[type.name];
          if (resolverValue != null) {
            const config2 = type.toConfig();
            if (resolverValue["__resolveType"]) {
              config2.resolveType = resolverValue["__resolveType"];
            }
            return new graphql_1.GraphQLInterfaceType(config2);
          }
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
          const resolverValue = resolvers[typeName];
          if (resolverValue != null) {
            const fieldResolve = resolverValue[fieldName];
            if (fieldResolve != null) {
              const newFieldConfig = { ...fieldConfig };
              if (typeof fieldResolve === "function") {
                newFieldConfig.resolve = fieldResolve.bind(resolverValue);
              } else {
                setFieldProperties(newFieldConfig, fieldResolve);
              }
              return newFieldConfig;
            }
          }
        }
      });
      if (defaultFieldResolver2 != null) {
        schema = (0, utils_1.mapSchema)(schema, {
          [utils_1.MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
            ...fieldConfig,
            resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver2
          })
        });
      }
      return schema;
    }
    function setFieldProperties(field, propertiesObj) {
      for (const propertyName in propertiesObj) {
        field[propertyName] = propertiesObj[propertyName];
      }
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
var require_merge_resolvers = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeResolvers = void 0;
    var utils_1 = require_cjs();
    function mergeResolvers(resolversDefinitions, options) {
      if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
        return {};
      }
      if (!Array.isArray(resolversDefinitions)) {
        return resolversDefinitions;
      }
      if (resolversDefinitions.length === 1) {
        return resolversDefinitions[0] || {};
      }
      const resolvers = new Array();
      for (let resolversDefinition of resolversDefinitions) {
        if (Array.isArray(resolversDefinition)) {
          resolversDefinition = mergeResolvers(resolversDefinition);
        }
        if (typeof resolversDefinition === "object" && resolversDefinition) {
          resolvers.push(resolversDefinition);
        }
      }
      const result = (0, utils_1.mergeDeep)(resolvers, true);
      if (options === null || options === void 0 ? void 0 : options.exclusions) {
        for (const exclusion of options.exclusions) {
          const [typeName, fieldName] = exclusion.split(".");
          if (!fieldName || fieldName === "*") {
            delete result[typeName];
          } else if (result[typeName]) {
            delete result[typeName][fieldName];
          }
        }
      }
      return result;
    }
    exports.mergeResolvers = mergeResolvers;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
var require_arguments = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeArguments = void 0;
    var utils_1 = require_cjs();
    function mergeArguments(args1, args2, config2) {
      const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome));
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports.mergeArguments = mergeArguments;
    function deduplicateArguments(args) {
      return args.reduce((acc, current) => {
        const dup = acc.find((arg) => arg.name.value === current.name.value);
        if (!dup) {
          return acc.concat([current]);
        }
        return acc;
      }, []);
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
var require_directives2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeDirective = exports.mergeDirectives = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    function directiveAlreadyExists(directivesArr, otherDirective) {
      return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
    }
    function nameAlreadyExists(name, namesArr) {
      return namesArr.some(({ value }) => value === name.value);
    }
    function mergeArguments(a1, a2) {
      const result = [...a2];
      for (const argument of a1) {
        const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
        if (existingIndex > -1) {
          const existingArg = result[existingIndex];
          if (existingArg.value.kind === "ListValue") {
            const source = existingArg.value.values;
            const target = argument.value.values;
            existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
              const value = targetVal.value;
              return !value || !source2.some((sourceVal) => sourceVal.value === value);
            });
          } else {
            existingArg.value = argument.value;
          }
        } else {
          result.push(argument);
        }
      }
      return result;
    }
    function deduplicateDirectives(directives) {
      return directives.map((directive, i, all) => {
        const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
        if (firstAt !== i) {
          const dup = all[firstAt];
          directive.arguments = mergeArguments(directive.arguments, dup.arguments);
          return null;
        }
        return directive;
      }).filter(utils_1.isSome);
    }
    function mergeDirectives(d1 = [], d2 = [], config2) {
      const reverseOrder = config2 && config2.reverseDirectives;
      const asNext = reverseOrder ? d1 : d2;
      const asFirst = reverseOrder ? d2 : d1;
      const result = deduplicateDirectives([...asNext]);
      for (const directive of asFirst) {
        if (directiveAlreadyExists(result, directive)) {
          const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
          const existingDirective = result[existingDirectiveIndex];
          result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
        } else {
          result.push(directive);
        }
      }
      return result;
    }
    exports.mergeDirectives = mergeDirectives;
    function validateInputs(node, existingNode) {
      const printedNode = (0, graphql_1.print)({
        ...node,
        description: void 0
      });
      const printedExistingNode = (0, graphql_1.print)({
        ...existingNode,
        description: void 0
      });
      const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
      const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
      if (!sameArguments) {
        throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
      }
    }
    function mergeDirective(node, existingNode) {
      if (existingNode) {
        validateInputs(node, existingNode);
        return {
          ...node,
          locations: [
            ...existingNode.locations,
            ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
          ]
        };
      }
      return node;
    }
    exports.mergeDirective = mergeDirective;
    function deduplicateLists(source, target, filterFn) {
      return source.concat(target.filter((val) => filterFn(val, source)));
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
var require_enum_values = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeEnumValues = void 0;
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    function mergeEnumValues(first, second, config2) {
      if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
        const reversed = [];
        if (first) {
          reversed.push(...first);
        }
        first = second;
        second = reversed;
      }
      const enumValueMap = /* @__PURE__ */ new Map();
      if (first) {
        for (const firstValue of first) {
          enumValueMap.set(firstValue.name.value, firstValue);
        }
      }
      if (second) {
        for (const secondValue of second) {
          const enumValue = secondValue.name.value;
          if (enumValueMap.has(enumValue)) {
            const firstValue = enumValueMap.get(enumValue);
            firstValue.description = secondValue.description || firstValue.description;
            firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives);
          } else {
            enumValueMap.set(enumValue, secondValue);
          }
        }
      }
      const result = [...enumValueMap.values()];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports.mergeEnumValues = mergeEnumValues;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
var require_enum = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeEnum = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var enum_values_js_1 = require_enum_values();
    function mergeEnum(e1, e2, config2) {
      if (e2) {
        return {
          name: e1.name,
          description: e1["description"] || e2["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
          loc: e1.loc,
          directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config2),
          values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...e1,
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
      } : e1;
    }
    exports.mergeEnum = mergeEnum;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
var require_utils = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultStringComparator = exports.CompareVal = exports.printTypeNode = exports.isNonNullTypeNode = exports.isListTypeNode = exports.isWrappingTypeNode = exports.extractType = exports.isSourceTypes = exports.isStringTypes = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    function isStringTypes(types) {
      return typeof types === "string";
    }
    exports.isStringTypes = isStringTypes;
    function isSourceTypes(types) {
      return types instanceof graphql_1.Source;
    }
    exports.isSourceTypes = isSourceTypes;
    function extractType(type) {
      let visitedType = type;
      while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
        visitedType = visitedType.type;
      }
      return visitedType;
    }
    exports.extractType = extractType;
    function isWrappingTypeNode(type) {
      return type.kind !== graphql_1.Kind.NAMED_TYPE;
    }
    exports.isWrappingTypeNode = isWrappingTypeNode;
    function isListTypeNode(type) {
      return type.kind === graphql_1.Kind.LIST_TYPE;
    }
    exports.isListTypeNode = isListTypeNode;
    function isNonNullTypeNode(type) {
      return type.kind === graphql_1.Kind.NON_NULL_TYPE;
    }
    exports.isNonNullTypeNode = isNonNullTypeNode;
    function printTypeNode(type) {
      if (isListTypeNode(type)) {
        return `[${printTypeNode(type.type)}]`;
      }
      if (isNonNullTypeNode(type)) {
        return `${printTypeNode(type.type)}!`;
      }
      return type.name.value;
    }
    exports.printTypeNode = printTypeNode;
    var CompareVal;
    (function(CompareVal2) {
      CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
      CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
      CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
    })(CompareVal = exports.CompareVal || (exports.CompareVal = {}));
    function defaultStringComparator(a, b) {
      if (a == null && b == null) {
        return CompareVal.A_EQUALS_B;
      }
      if (a == null) {
        return CompareVal.A_SMALLER_THAN_B;
      }
      if (b == null) {
        return CompareVal.A_GREATER_THAN_B;
      }
      if (a < b)
        return CompareVal.A_SMALLER_THAN_B;
      if (a > b)
        return CompareVal.A_GREATER_THAN_B;
      return CompareVal.A_EQUALS_B;
    }
    exports.defaultStringComparator = defaultStringComparator;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
var require_fields2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeFields = void 0;
    var utils_js_1 = require_utils();
    var directives_js_1 = require_directives2();
    var utils_1 = require_cjs();
    var arguments_js_1 = require_arguments();
    function fieldAlreadyExists(fieldsArr, otherField, config2) {
      const result = fieldsArr.find((field) => field.name.value === otherField.name.value);
      if (result && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
        const t1 = (0, utils_js_1.extractType)(result.type);
        const t2 = (0, utils_js_1.extractType)(otherField.type);
        if (t1.name.value !== t2.name.value) {
          throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
        }
      }
      return !!result;
    }
    function mergeFields(type, f1, f2, config2) {
      const result = [];
      if (f2 != null) {
        result.push(...f2);
      }
      if (f1 != null) {
        for (const field of f1) {
          if (fieldAlreadyExists(result, field, config2)) {
            const existing = result.find((f) => f.name.value === field.name.value);
            if (!(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
              if (config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) {
                preventConflicts(type, existing, field, false);
              } else {
                preventConflicts(type, existing, field, true);
              }
              if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {
                existing.type = field.type;
              }
            }
            existing.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing.arguments || [], config2);
            existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config2);
            existing.description = field.description || existing.description;
          } else {
            result.push(field);
          }
        }
      }
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      if (config2 && config2.exclusions) {
        const exclusions = config2.exclusions;
        return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
      }
      return result;
    }
    exports.mergeFields = mergeFields;
    function preventConflicts(type, a, b, ignoreNullability = false) {
      const aType = (0, utils_js_1.printTypeNode)(a.type);
      const bType = (0, utils_js_1.printTypeNode)(b.type);
      if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
      }
    }
    function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
      if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
        return oldType.toString() === newType.toString();
      }
      if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
        return safeChangeForFieldType(ofType, newType.type);
      }
      if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
        return safeChangeForFieldType(newType, oldType, ignoreNullability);
      }
      if ((0, utils_js_1.isListTypeNode)(oldType)) {
        return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
      }
      return false;
    }
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
var require_input_type = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInputType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    function mergeInputType(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports.mergeInputType = mergeInputType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
var require_merge_named_type_array = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeNamedTypeArray = void 0;
    var utils_1 = require_cjs();
    function alreadyExists(arr, other) {
      return !!arr.find((i) => i.name.value === other.name.value);
    }
    function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
      const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
      if (config2 && config2.sort) {
        result.sort(utils_1.compareNodes);
      }
      return result;
    }
    exports.mergeNamedTypeArray = mergeNamedTypeArray;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
var require_interface = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInterface = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeInterface(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
            interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config2) : void 0
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
      } : node;
    }
    exports.mergeInterface = mergeInterface;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
var require_type = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeType = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var fields_js_1 = require_fields2();
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeType(node, existingNode, config2) {
      if (existingNode) {
        try {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
            loc: node.loc,
            fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
            interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config2)
          };
        } catch (e) {
          throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
        }
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
      } : node;
    }
    exports.mergeType = mergeType;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
var require_scalar = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeScalar = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    function mergeScalar(node, existingNode, config2) {
      if (existingNode) {
        return {
          name: node.name,
          description: node["description"] || existingNode["description"],
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
          loc: node.loc,
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
      } : node;
    }
    exports.mergeScalar = mergeScalar;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
var require_union = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeUnion = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    var merge_named_type_array_js_1 = require_merge_named_type_array();
    function mergeUnion(first, second, config2) {
      if (second) {
        return {
          name: first.name,
          description: first["description"] || second["description"],
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config2),
          kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
          loc: first.loc,
          types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config2)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...first,
        kind: graphql_1.Kind.UNION_TYPE_DEFINITION
      } : first;
    }
    exports.mergeUnion = mergeUnion;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
var require_schema_def = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeSchemaDefs = exports.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var directives_js_1 = require_directives2();
    exports.DEFAULT_OPERATION_TYPE_NAME_MAP = {
      query: "Query",
      mutation: "Mutation",
      subscription: "Subscription"
    };
    function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
      const finalOpNodeList = [];
      for (const opNodeType in exports.DEFAULT_OPERATION_TYPE_NAME_MAP) {
        const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
        if (opNode) {
          finalOpNodeList.push(opNode);
        }
      }
      return finalOpNodeList;
    }
    function mergeSchemaDefs(node, existingNode, config2) {
      if (existingNode) {
        return {
          kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          description: node["description"] || existingNode["description"],
          directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2),
          operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
        };
      }
      return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
        ...node,
        kind: graphql_1.Kind.SCHEMA_DEFINITION
      } : node;
    }
    exports.mergeSchemaDefs = mergeSchemaDefs;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
var require_merge_nodes = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeGraphQLNodes = exports.isNamedDefinitionNode = exports.schemaDefSymbol = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var type_js_1 = require_type();
    var enum_js_1 = require_enum();
    var scalar_js_1 = require_scalar();
    var union_js_1 = require_union();
    var input_type_js_1 = require_input_type();
    var interface_js_1 = require_interface();
    var directives_js_1 = require_directives2();
    var schema_def_js_1 = require_schema_def();
    var utils_1 = require_cjs();
    exports.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
    function isNamedDefinitionNode(definitionNode) {
      return "name" in definitionNode;
    }
    exports.isNamedDefinitionNode = isNamedDefinitionNode;
    function mergeGraphQLNodes(nodes, config2) {
      var _a, _b, _c;
      const mergedResultMap = {};
      for (const nodeDefinition of nodes) {
        if (isNamedDefinitionNode(nodeDefinition)) {
          const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
          if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
            (0, utils_1.collectComment)(nodeDefinition);
          }
          if (name == null) {
            continue;
          }
          if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
            delete mergedResultMap[name];
          } else {
            switch (nodeDefinition.kind) {
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                mergedResultMap[name] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_EXTENSION:
                mergedResultMap[name] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                mergedResultMap[name] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                mergedResultMap[name] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                mergedResultMap[name] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name], config2);
                break;
              case graphql_1.Kind.DIRECTIVE_DEFINITION:
                mergedResultMap[name] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name]);
                break;
            }
          }
        } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
          mergedResultMap[exports.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports.schemaDefSymbol], config2);
        }
      }
      return mergedResultMap;
    }
    exports.mergeGraphQLNodes = mergeGraphQLNodes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
var require_merge_typedefs = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_js_1 = require_utils();
    var merge_nodes_js_1 = require_merge_nodes();
    var utils_1 = require_cjs();
    var schema_def_js_1 = require_schema_def();
    function mergeTypeDefs(typeSource, config2) {
      (0, utils_1.resetComments)();
      const doc = {
        kind: graphql_1.Kind.DOCUMENT,
        definitions: mergeGraphQLTypes(typeSource, {
          useSchemaDefinition: true,
          forceSchemaDefinition: false,
          throwOnConflict: false,
          commentDescriptions: false,
          ...config2
        })
      };
      let result;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        result = (0, utils_1.printWithComments)(doc);
      } else {
        result = doc;
      }
      (0, utils_1.resetComments)();
      return result;
    }
    exports.mergeTypeDefs = mergeTypeDefs;
    function visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
      if (typeSource && !visitedTypeSources.has(typeSource)) {
        visitedTypeSources.add(typeSource);
        if (typeof typeSource === "function") {
          visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);
        } else if (Array.isArray(typeSource)) {
          for (const type of typeSource) {
            visitTypeSources(type, options, allNodes, visitedTypeSources);
          }
        } else if ((0, graphql_1.isSchema)(typeSource)) {
          const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
          const documentNode = (0, graphql_1.parse)(typeSource, options);
          visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);
        } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
          allNodes.push(typeSource);
        } else if ((0, utils_1.isDocumentNode)(typeSource)) {
          visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);
        } else {
          throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
        }
      }
      return allNodes;
    }
    function mergeGraphQLTypes(typeSource, config2) {
      var _a, _b, _c;
      (0, utils_1.resetComments)();
      const allNodes = visitTypeSources(typeSource, config2);
      const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config2);
      if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: []
        };
        const operationTypes = schemaDef.operationTypes;
        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
          if (!opTypeDefNode) {
            const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
            const existingPossibleRootType = mergedNodes[possibleRootTypeName];
            if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
              operationTypes.push({
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: existingPossibleRootType.name
                },
                operation: opTypeDefNodeType
              });
            }
          }
        }
        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
        }
      }
      if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
          kind: graphql_1.Kind.SCHEMA_DEFINITION,
          operationTypes: [
            {
              kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
              operation: "query",
              type: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: "Query"
                }
              }
            }
          ]
        };
      }
      const mergedNodeDefinitions = Object.values(mergedNodes);
      if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
        const sortFn = typeof config2.sort === "function" ? config2.sort : utils_js_1.defaultStringComparator;
        mergedNodeDefinitions.sort((a, b) => {
          var _a2, _b2;
          return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
        });
      }
      return mergedNodeDefinitions;
    }
    exports.mergeGraphQLTypes = mergeGraphQLTypes;
  }
});

// node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
var require_typedefs_mergers = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_arguments(), exports);
    tslib_1.__exportStar(require_directives2(), exports);
    tslib_1.__exportStar(require_enum_values(), exports);
    tslib_1.__exportStar(require_enum(), exports);
    tslib_1.__exportStar(require_fields2(), exports);
    tslib_1.__exportStar(require_input_type(), exports);
    tslib_1.__exportStar(require_interface(), exports);
    tslib_1.__exportStar(require_merge_named_type_array(), exports);
    tslib_1.__exportStar(require_merge_nodes(), exports);
    tslib_1.__exportStar(require_merge_typedefs(), exports);
    tslib_1.__exportStar(require_scalar(), exports);
    tslib_1.__exportStar(require_type(), exports);
    tslib_1.__exportStar(require_union(), exports);
    tslib_1.__exportStar(require_utils(), exports);
  }
});

// node_modules/@graphql-tools/merge/cjs/extensions.js
var require_extensions = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/extensions.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyExtensions = exports.mergeExtensions = exports.extractExtensionsFromSchema = void 0;
    var utils_1 = require_cjs();
    var utils_2 = require_cjs();
    Object.defineProperty(exports, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_2.extractExtensionsFromSchema;
    } });
    function mergeExtensions(extensions) {
      return (0, utils_1.mergeDeep)(extensions);
    }
    exports.mergeExtensions = mergeExtensions;
    function applyExtensionObject(obj, extensions) {
      if (!obj) {
        return;
      }
      obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
    }
    function applyExtensions(schema, extensions) {
      applyExtensionObject(schema, extensions.schemaExtensions);
      for (const [typeName, data] of Object.entries(extensions.types || {})) {
        const type = schema.getType(typeName);
        if (type) {
          applyExtensionObject(type, data.extensions);
          if (data.type === "object" || data.type === "interface") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              if (field) {
                applyExtensionObject(field, fieldData.extensions);
                for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                  applyExtensionObject(field.args.find((a) => a.name === arg), argData);
                }
              }
            }
          } else if (data.type === "input") {
            for (const [fieldName, fieldData] of Object.entries(data.fields)) {
              const field = type.getFields()[fieldName];
              applyExtensionObject(field, fieldData.extensions);
            }
          } else if (data.type === "enum") {
            for (const [valueName, valueData] of Object.entries(data.values)) {
              const value = type.getValue(valueName);
              applyExtensionObject(value, valueData);
            }
          }
        }
      }
      return schema;
    }
    exports.applyExtensions = applyExtensions;
  }
});

// node_modules/@graphql-tools/merge/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@graphql-tools/merge/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_merge_resolvers(), exports);
    tslib_1.__exportStar(require_typedefs_mergers(), exports);
    tslib_1.__exportStar(require_extensions(), exports);
  }
});

// node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js
var require_makeExecutableSchema = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeExecutableSchema = void 0;
    var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
    var utils_1 = require_cjs();
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    var merge_1 = require_cjs2();
    function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
      if (typeof resolverValidationOptions !== "object") {
        throw new Error("Expected `resolverValidationOptions` to be an object");
      }
      if (!typeDefs) {
        throw new Error("Must provide typeDefs");
      }
      let schema;
      if ((0, graphql_1.isSchema)(typeDefs)) {
        schema = typeDefs;
      } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {
          ...otherOptions,
          commentDescriptions: true
        });
        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);
      } else {
        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);
        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);
      }
      schema = (0, addResolversToSchema_js_1.addResolversToSchema)({
        schema,
        resolvers: (0, merge_1.mergeResolvers)(resolvers),
        resolverValidationOptions,
        inheritResolversFromInterfaces,
        updateResolversInPlace
      });
      if (Object.keys(resolverValidationOptions).length > 0) {
        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);
      }
      if (schemaExtensions) {
        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));
        (0, merge_1.applyExtensions)(schema, schemaExtensions);
      }
      return schema;
    }
    exports.makeExecutableSchema = makeExecutableSchema;
  }
});

// node_modules/@graphql-tools/schema/cjs/types.js
var require_types2 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@graphql-tools/schema/cjs/merge-schemas.js
var require_merge_schemas = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/merge-schemas.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeSchemas = void 0;
    var utils_1 = require_cjs();
    var makeExecutableSchema_js_1 = require_makeExecutableSchema();
    function mergeSchemas(config2) {
      const extractedTypeDefs = [];
      const extractedResolvers = [];
      const extractedSchemaExtensions = [];
      if (config2.schemas != null) {
        for (const schema of config2.schemas) {
          extractedTypeDefs.push(schema);
          extractedResolvers.push((0, utils_1.getResolversFromSchema)(schema));
          extractedSchemaExtensions.push((0, utils_1.extractExtensionsFromSchema)(schema));
        }
      }
      if (config2.typeDefs != null) {
        extractedTypeDefs.push(config2.typeDefs);
      }
      if (config2.resolvers != null) {
        const additionalResolvers = (0, utils_1.asArray)(config2.resolvers);
        extractedResolvers.push(...additionalResolvers);
      }
      if (config2.schemaExtensions != null) {
        const additionalSchemaExtensions = (0, utils_1.asArray)(config2.schemaExtensions);
        extractedSchemaExtensions.push(...additionalSchemaExtensions);
      }
      return (0, makeExecutableSchema_js_1.makeExecutableSchema)({
        ...config2,
        typeDefs: extractedTypeDefs,
        resolvers: extractedResolvers,
        schemaExtensions: extractedSchemaExtensions
      });
    }
    exports.mergeSchemas = mergeSchemas;
  }
});

// node_modules/@graphql-tools/schema/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@graphql-tools/schema/cjs/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractExtensionsFromSchema = exports.extendResolversFromInterfaces = exports.checkForResolveTypeResolver = exports.addResolversToSchema = exports.chainResolvers = exports.assertResolversPresent = void 0;
    var tslib_1 = require_tslib();
    var assertResolversPresent_js_1 = require_assertResolversPresent();
    Object.defineProperty(exports, "assertResolversPresent", { enumerable: true, get: function() {
      return assertResolversPresent_js_1.assertResolversPresent;
    } });
    var chainResolvers_js_1 = require_chainResolvers();
    Object.defineProperty(exports, "chainResolvers", { enumerable: true, get: function() {
      return chainResolvers_js_1.chainResolvers;
    } });
    var addResolversToSchema_js_1 = require_addResolversToSchema();
    Object.defineProperty(exports, "addResolversToSchema", { enumerable: true, get: function() {
      return addResolversToSchema_js_1.addResolversToSchema;
    } });
    var checkForResolveTypeResolver_js_1 = require_checkForResolveTypeResolver();
    Object.defineProperty(exports, "checkForResolveTypeResolver", { enumerable: true, get: function() {
      return checkForResolveTypeResolver_js_1.checkForResolveTypeResolver;
    } });
    var extendResolversFromInterfaces_js_1 = require_extendResolversFromInterfaces();
    Object.defineProperty(exports, "extendResolversFromInterfaces", { enumerable: true, get: function() {
      return extendResolversFromInterfaces_js_1.extendResolversFromInterfaces;
    } });
    tslib_1.__exportStar(require_makeExecutableSchema(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_merge_schemas(), exports);
    var utils_1 = require_cjs();
    Object.defineProperty(exports, "extractExtensionsFromSchema", { enumerable: true, get: function() {
      return utils_1.extractExtensionsFromSchema;
    } });
  }
});

// node_modules/async-mutex/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/async-mutex/lib/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.E_CANCELED = exports.E_ALREADY_LOCKED = exports.E_TIMEOUT = void 0;
    exports.E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
    exports.E_ALREADY_LOCKED = new Error("mutex already locked");
    exports.E_CANCELED = new Error("request for lock canceled");
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var errors_1 = require_errors2();
    var Semaphore = (
      /** @class */
      function() {
        function Semaphore2(_value, _cancelError) {
          if (_cancelError === void 0) {
            _cancelError = errors_1.E_CANCELED;
          }
          this._value = _value;
          this._cancelError = _cancelError;
          this._weightedQueues = [];
          this._weightedWaiters = [];
        }
        Semaphore2.prototype.acquire = function(weight) {
          var _this = this;
          if (weight === void 0) {
            weight = 1;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          return new Promise(function(resolve, reject) {
            if (!_this._weightedQueues[weight - 1])
              _this._weightedQueues[weight - 1] = [];
            _this._weightedQueues[weight - 1].push({ resolve, reject });
            _this._dispatch();
          });
        };
        Semaphore2.prototype.runExclusive = function(callback, weight) {
          if (weight === void 0) {
            weight = 1;
          }
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, value, release2;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.acquire(weight)];
                case 1:
                  _a = _b.sent(), value = _a[0], release2 = _a[1];
                  _b.label = 2;
                case 2:
                  _b.trys.push([2, , 4, 5]);
                  return [4, callback(value)];
                case 3:
                  return [2, _b.sent()];
                case 4:
                  release2();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Semaphore2.prototype.waitForUnlock = function(weight) {
          var _this = this;
          if (weight === void 0) {
            weight = 1;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          return new Promise(function(resolve) {
            if (!_this._weightedWaiters[weight - 1])
              _this._weightedWaiters[weight - 1] = [];
            _this._weightedWaiters[weight - 1].push(resolve);
            _this._dispatch();
          });
        };
        Semaphore2.prototype.isLocked = function() {
          return this._value <= 0;
        };
        Semaphore2.prototype.getValue = function() {
          return this._value;
        };
        Semaphore2.prototype.setValue = function(value) {
          this._value = value;
          this._dispatch();
        };
        Semaphore2.prototype.release = function(weight) {
          if (weight === void 0) {
            weight = 1;
          }
          if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          this._value += weight;
          this._dispatch();
        };
        Semaphore2.prototype.cancel = function() {
          var _this = this;
          this._weightedQueues.forEach(function(queue2) {
            return queue2.forEach(function(entry) {
              return entry.reject(_this._cancelError);
            });
          });
          this._weightedQueues = [];
        };
        Semaphore2.prototype._dispatch = function() {
          var _a;
          for (var weight = this._value; weight > 0; weight--) {
            var queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
            if (!queueEntry)
              continue;
            var previousValue = this._value;
            var previousWeight = weight;
            this._value -= weight;
            weight = this._value + 1;
            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
          }
          this._drainUnlockWaiters();
        };
        Semaphore2.prototype._newReleaser = function(weight) {
          var _this = this;
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            _this.release(weight);
          };
        };
        Semaphore2.prototype._drainUnlockWaiters = function() {
          for (var weight = this._value; weight > 0; weight--) {
            if (!this._weightedWaiters[weight - 1])
              continue;
            this._weightedWaiters[weight - 1].forEach(function(waiter) {
              return waiter();
            });
            this._weightedWaiters[weight - 1] = [];
          }
        };
        return Semaphore2;
      }()
    );
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    var Semaphore_1 = require_Semaphore();
    var Mutex = (
      /** @class */
      function() {
        function Mutex2(cancelError) {
          this._semaphore = new Semaphore_1.default(1, cancelError);
        }
        Mutex2.prototype.acquire = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a, releaser;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this._semaphore.acquire()];
                case 1:
                  _a = _b.sent(), releaser = _a[1];
                  return [2, releaser];
              }
            });
          });
        };
        Mutex2.prototype.runExclusive = function(callback) {
          return this._semaphore.runExclusive(function() {
            return callback();
          });
        };
        Mutex2.prototype.isLocked = function() {
          return this._semaphore.isLocked();
        };
        Mutex2.prototype.waitForUnlock = function() {
          return this._semaphore.waitForUnlock();
        };
        Mutex2.prototype.release = function() {
          if (this._semaphore.isLocked())
            this._semaphore.release();
        };
        Mutex2.prototype.cancel = function() {
          return this._semaphore.cancel();
        };
        return Mutex2;
      }()
    );
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_1 = require_tslib();
    var errors_1 = require_errors2();
    function withTimeout(sync, timeout, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = errors_1.E_TIMEOUT;
      }
      return {
        acquire: function(weight) {
          if (weight !== void 0 && weight <= 0) {
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          }
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, handle, ticket, release2, e_1;
              return tslib_1.__generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    isTimeout = false;
                    handle = setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, sync.acquire(weight)];
                  case 2:
                    ticket = _a.sent();
                    if (isTimeout) {
                      release2 = Array.isArray(ticket) ? ticket[1] : ticket;
                      release2();
                    } else {
                      clearTimeout(handle);
                      resolve(ticket);
                    }
                    return [3, 4];
                  case 3:
                    e_1 = _a.sent();
                    if (!isTimeout) {
                      clearTimeout(handle);
                      reject(e_1);
                    }
                    return [3, 4];
                  case 4:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          });
        },
        runExclusive: function(callback, weight) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release2, ticket;
            return tslib_1.__generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  release2 = function() {
                    return void 0;
                  };
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, , 7, 8]);
                  return [4, this.acquire(weight)];
                case 2:
                  ticket = _a.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release2 = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a.sent()];
                case 4:
                  release2 = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release2();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        },
        release: function(weight) {
          sync.release(weight);
        },
        cancel: function() {
          return sync.cancel();
        },
        waitForUnlock: function(weight) {
          if (weight !== void 0 && weight <= 0) {
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
          }
          return new Promise(function(resolve, reject) {
            sync.waitForUnlock(weight).then(resolve);
            setTimeout(function() {
              return reject(timeoutError);
            }, timeout);
          });
        },
        isLocked: function() {
          return sync.isLocked();
        },
        getValue: function() {
          return sync.getValue();
        },
        setValue: function(value) {
          return sync.setValue(value);
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/tryAcquire.js
var require_tryAcquire = __commonJS({
  "node_modules/async-mutex/lib/tryAcquire.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryAcquire = void 0;
    var errors_1 = require_errors2();
    var withTimeout_1 = require_withTimeout();
    function tryAcquire(sync, alreadyAcquiredError) {
      if (alreadyAcquiredError === void 0) {
        alreadyAcquiredError = errors_1.E_ALREADY_LOCKED;
      }
      return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);
    }
    exports.tryAcquire = tryAcquire;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryAcquire = exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var tslib_1 = require_tslib();
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
    var tryAcquire_1 = require_tryAcquire();
    Object.defineProperty(exports, "tryAcquire", { enumerable: true, get: function() {
      return tryAcquire_1.tryAcquire;
    } });
    tslib_1.__exportStar(require_errors2(), exports);
  }
});

// node-modules-polyfills:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "node-modules-polyfills:crypto"() {
    init_process();
    init_buffer();
    crypto_default = {};
  }
});

// node-modules-polyfills-commonjs:crypto
var require_crypto = __commonJS({
  "node-modules-polyfills-commonjs:crypto"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "node-modules-polyfills:fs"() {
    init_process();
    init_buffer();
    fs_default = {};
  }
});

// node-modules-polyfills-commonjs:fs
var require_fs = __commonJS({
  "node-modules-polyfills-commonjs:fs"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_fs(), __toCommonJS(fs_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/checksum/checksum.js
var require_checksum = __commonJS({
  "node_modules/checksum/checksum.js"(exports, module) {
    init_process();
    init_buffer();
    var crypto = require_crypto();
    var fs = require_fs();
    module.exports = checksum;
    checksum.file = checksumFile;
    function checksum(value, options) {
      options || (options = {});
      if (!options.algorithm)
        options.algorithm = "sha1";
      var hash = crypto.createHash(options.algorithm);
      if (!hash.write) {
        hash.update(value);
        return hash.digest("hex");
      } else {
        hash.write(value);
        return hash.digest("hex");
      }
    }
    function checksumFile(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options || (options = {});
      if (!options.algorithm)
        options.algorithm = "sha1";
      fs.stat(filename, function(err, stat) {
        if (!err && !stat.isFile())
          err = new Error("Not a file");
        if (err)
          return callback(err);
        var hash = crypto.createHash(options.algorithm), fileStream = fs.createReadStream(filename);
        if (!hash.write) {
          fileStream.on("data", function(data) {
            hash.update(data);
          });
          fileStream.on("end", function() {
            callback(null, hash.digest("hex"));
          });
        } else {
          hash.setEncoding("hex");
          fileStream.pipe(hash, { end: false });
          fileStream.on("end", function() {
            hash.end();
            callback(null, hash.read());
          });
        }
      });
    }
  }
});

// node_modules/bitset/bitset.js
var require_bitset = __commonJS({
  "node_modules/bitset/bitset.js"(exports, module) {
    init_process();
    init_buffer();
    (function(root) {
      "use strict";
      var WORD_LENGTH = 32;
      var WORD_LOG = 5;
      function popCount(v) {
        v -= v >>> 1 & 1431655765;
        v = (v & 858993459) + (v >>> 2 & 858993459);
        return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
      }
      function divide(arr, B) {
        var r = 0;
        for (var i = 0; i < arr.length; i++) {
          r *= 2;
          var d = (arr[i] + r) / B | 0;
          r = (arr[i] + r) % B;
          arr[i] = d;
        }
        return r;
      }
      function parse2(P2, val) {
        if (val == null) {
          P2["data"] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          P2["_"] = 0;
          return;
        }
        if (val instanceof BitSet) {
          P2["data"] = val["data"];
          P2["_"] = val["_"];
          return;
        }
        switch (typeof val) {
          case "number":
            P2["data"] = [val | 0];
            P2["_"] = 0;
            break;
          case "string":
            var base = 2;
            var len = WORD_LENGTH;
            if (val.indexOf("0b") === 0) {
              val = val.substr(2);
            } else if (val.indexOf("0x") === 0) {
              val = val.substr(2);
              base = 16;
              len = 8;
            }
            P2["data"] = [];
            P2["_"] = 0;
            var a = val.length - len;
            var b = val.length;
            do {
              var num = parseInt(val.slice(a > 0 ? a : 0, b), base);
              if (isNaN(num)) {
                throw SyntaxError("Invalid param");
              }
              P2["data"].push(num | 0);
              if (a <= 0)
                break;
              a -= len;
              b -= len;
            } while (1);
            break;
          default:
            P2["data"] = [0];
            var data = P2["data"];
            if (val instanceof Array) {
              for (var i = val.length - 1; i >= 0; i--) {
                var ndx = val[i];
                if (ndx === Infinity) {
                  P2["_"] = -1;
                } else {
                  scale(P2, ndx);
                  data[ndx >>> WORD_LOG] |= 1 << ndx;
                }
              }
              break;
            }
            if (Uint8Array && val instanceof Uint8Array) {
              var bits = 8;
              scale(P2, val.length * bits);
              for (var i = 0; i < val.length; i++) {
                var n = val[i];
                for (var j = 0; j < bits; j++) {
                  var k = i * bits + j;
                  data[k >>> WORD_LOG] |= (n >> j & 1) << k;
                }
              }
              break;
            }
            throw SyntaxError("Invalid param");
        }
      }
      function BitSet(param) {
        if (!(this instanceof BitSet)) {
          return new BitSet(param);
        }
        parse2(this, param);
        this["data"] = this["data"].slice();
      }
      function scale(dst, ndx) {
        var l = ndx >>> WORD_LOG;
        var d = dst["data"];
        var v = dst["_"];
        for (var i = d.length; l >= i; l--) {
          d.push(v);
        }
      }
      var P = {
        "data": [],
        // Holds the actual bits in form of a 32bit integer array.
        "_": 0
        // Holds the MSB flag information to make indefinitely large bitsets inversion-proof
      };
      BitSet.prototype = {
        "data": [],
        "_": 0,
        /**
         * Set a single bit flag
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * bs1.set(3, 1);
         *
         * @param {number} ndx The index of the bit to be set
         * @param {number=} value Optional value that should be set on the index (0 or 1)
         * @returns {BitSet} this
         */
        "set": function(ndx, value) {
          ndx |= 0;
          scale(this, ndx);
          if (value === void 0 || value) {
            this["data"][ndx >>> WORD_LOG] |= 1 << ndx;
          } else {
            this["data"][ndx >>> WORD_LOG] &= ~(1 << ndx);
          }
          return this;
        },
        /**
         * Get a single bit flag of a certain bit position
         *
         * Ex:
         * bs1 = new BitSet();
         * var isValid = bs1.get(12);
         *
         * @param {number} ndx the index to be fetched
         * @returns {number} The binary flag
         */
        "get": function(ndx) {
          ndx |= 0;
          var d = this["data"];
          var n = ndx >>> WORD_LOG;
          if (n >= d.length) {
            return this["_"] & 1;
          }
          return d[n] >>> ndx & 1;
        },
        /**
         * Creates the bitwise NOT of a set.
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * res = bs1.not();
         *
         * @returns {BitSet} A new BitSet object, containing the bitwise NOT of this
         */
        "not": function() {
          var t = this["clone"]();
          var d = t["data"];
          for (var i = 0; i < d.length; i++) {
            d[i] = ~d[i];
          }
          t["_"] = ~t["_"];
          return t;
        },
        /**
         * Creates the bitwise AND of two sets.
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = new BitSet(10);
         *
         * res = bs1.and(bs2);
         *
         * @param {BitSet} value A bitset object
         * @returns {BitSet} A new BitSet object, containing the bitwise AND of this and value
         */
        "and": function(value) {
          parse2(P, value);
          var T = this["clone"]();
          var t = T["data"];
          var p = P["data"];
          var pl = p.length;
          var p_ = P["_"];
          var t_ = T["_"];
          if (t_ !== 0) {
            scale(T, pl * WORD_LENGTH - 1);
          }
          var tl = t.length;
          var l = Math.min(pl, tl);
          var i = 0;
          for (; i < l; i++) {
            t[i] &= p[i];
          }
          for (; i < tl; i++) {
            t[i] &= p_;
          }
          T["_"] &= p_;
          return T;
        },
        /**
         * Creates the bitwise OR of two sets.
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = new BitSet(10);
         *
         * res = bs1.or(bs2);
         *
         * @param {BitSet} val A bitset object
         * @returns {BitSet} A new BitSet object, containing the bitwise OR of this and val
         */
        "or": function(val) {
          parse2(P, val);
          var t = this["clone"]();
          var d = t["data"];
          var p = P["data"];
          var pl = p.length - 1;
          var tl = d.length - 1;
          var minLength = Math.min(tl, pl);
          for (var i = pl; i > minLength; i--) {
            d[i] = p[i];
          }
          for (; i >= 0; i--) {
            d[i] |= p[i];
          }
          t["_"] |= P["_"];
          return t;
        },
        /**
         * Creates the bitwise XOR of two sets.
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = new BitSet(10);
         *
         * res = bs1.xor(bs2);
         *
         * @param {BitSet} val A bitset object
         * @returns {BitSet} A new BitSet object, containing the bitwise XOR of this and val
         */
        "xor": function(val) {
          parse2(P, val);
          var t = this["clone"]();
          var d = t["data"];
          var p = P["data"];
          var t_ = t["_"];
          var p_ = P["_"];
          var i = 0;
          var tl = d.length - 1;
          var pl = p.length - 1;
          for (i = tl; i > pl; i--) {
            d[i] ^= p_;
          }
          for (i = pl; i > tl; i--) {
            d[i] = t_ ^ p[i];
          }
          for (; i >= 0; i--) {
            d[i] ^= p[i];
          }
          t["_"] ^= p_;
          return t;
        },
        /**
         * Creates the bitwise AND NOT (not confuse with NAND!) of two sets.
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = new BitSet(10);
         *
         * res = bs1.notAnd(bs2);
         *
         * @param {BitSet} val A bitset object
         * @returns {BitSet} A new BitSet object, containing the bitwise AND NOT of this and other
         */
        "andNot": function(val) {
          return this["and"](new BitSet(val)["flip"]());
        },
        /**
         * Flip/Invert a range of bits by setting
         *
         * Ex:
         * bs1 = new BitSet();
         * bs1.flip(); // Flip entire set
         * bs1.flip(5); // Flip single bit
         * bs1.flip(3,10); // Flip a bit range
         *
         * @param {number=} from The start index of the range to be flipped
         * @param {number=} to The end index of the range to be flipped
         * @returns {BitSet} this
         */
        "flip": function(from2, to) {
          if (from2 === void 0) {
            var d = this["data"];
            for (var i = 0; i < d.length; i++) {
              d[i] = ~d[i];
            }
            this["_"] = ~this["_"];
          } else if (to === void 0) {
            scale(this, from2);
            this["data"][from2 >>> WORD_LOG] ^= 1 << from2;
          } else if (0 <= from2 && from2 <= to) {
            scale(this, to);
            for (var i = from2; i <= to; i++) {
              this["data"][i >>> WORD_LOG] ^= 1 << i;
            }
          }
          return this;
        },
        /**
         * Clear a range of bits by setting it to 0
         *
         * Ex:
         * bs1 = new BitSet();
         * bs1.clear(); // Clear entire set
         * bs1.clear(5); // Clear single bit
         * bs1.clear(3,10); // Clear a bit range
         *
         * @param {number=} from The start index of the range to be cleared
         * @param {number=} to The end index of the range to be cleared
         * @returns {BitSet} this
         */
        "clear": function(from2, to) {
          var data = this["data"];
          if (from2 === void 0) {
            for (var i = data.length - 1; i >= 0; i--) {
              data[i] = 0;
            }
            this["_"] = 0;
          } else if (to === void 0) {
            from2 |= 0;
            scale(this, from2);
            data[from2 >>> WORD_LOG] &= ~(1 << from2);
          } else if (from2 <= to) {
            scale(this, to);
            for (var i = from2; i <= to; i++) {
              data[i >>> WORD_LOG] &= ~(1 << i);
            }
          }
          return this;
        },
        /**
         * Gets an entire range as a new bitset object
         *
         * Ex:
         * bs1 = new BitSet();
         * bs1.slice(4, 8);
         *
         * @param {number=} from The start index of the range to be get
         * @param {number=} to The end index of the range to be get
         * @returns {BitSet} A new smaller bitset object, containing the extracted range
         */
        "slice": function(from2, to) {
          if (from2 === void 0) {
            return this["clone"]();
          } else if (to === void 0) {
            to = this["data"].length * WORD_LENGTH;
            var im = Object.create(BitSet.prototype);
            im["_"] = this["_"];
            im["data"] = [0];
            for (var i = from2; i <= to; i++) {
              im["set"](i - from2, this["get"](i));
            }
            return im;
          } else if (from2 <= to && 0 <= from2) {
            var im = Object.create(BitSet.prototype);
            im["data"] = [0];
            for (var i = from2; i <= to; i++) {
              im["set"](i - from2, this["get"](i));
            }
            return im;
          }
          return null;
        },
        /**
         * Set a range of bits
         *
         * Ex:
         * bs1 = new BitSet();
         *
         * bs1.setRange(10, 15, 1);
         *
         * @param {number} from The start index of the range to be set
         * @param {number} to The end index of the range to be set
         * @param {number} value Optional value that should be set on the index (0 or 1)
         * @returns {BitSet} this
         */
        "setRange": function(from2, to, value) {
          for (var i = from2; i <= to; i++) {
            this["set"](i, value);
          }
          return this;
        },
        /**
         * Clones the actual object
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = bs1.clone();
         *
         * @returns {BitSet|Object} A new BitSet object, containing a copy of the actual object
         */
        "clone": function() {
          var im = Object.create(BitSet.prototype);
          im["data"] = this["data"].slice();
          im["_"] = this["_"];
          return im;
        },
        /**
         * Gets a list of set bits
         *
         * @returns {Array}
         */
        "toArray": Math["clz32"] ? function() {
          var ret = [];
          var data = this["data"];
          for (var i = data.length - 1; i >= 0; i--) {
            var num = data[i];
            while (num !== 0) {
              var t = 31 - Math["clz32"](num);
              num ^= 1 << t;
              ret.unshift(i * WORD_LENGTH + t);
            }
          }
          if (this["_"] !== 0)
            ret.push(Infinity);
          return ret;
        } : function() {
          var ret = [];
          var data = this["data"];
          for (var i = 0; i < data.length; i++) {
            var num = data[i];
            while (num !== 0) {
              var t = num & -num;
              num ^= t;
              ret.push(i * WORD_LENGTH + popCount(t - 1));
            }
          }
          if (this["_"] !== 0)
            ret.push(Infinity);
          return ret;
        },
        /**
         * Overrides the toString method to get a binary representation of the BitSet
         *
         * @param {number=} base
         * @returns string A binary string
         */
        "toString": function(base) {
          var data = this["data"];
          if (!base)
            base = 2;
          if ((base & base - 1) === 0 && base < 36) {
            var ret = "";
            var len = 2 + Math.log(
              4294967295
              /*Math.pow(2, WORD_LENGTH)-1*/
            ) / Math.log(base) | 0;
            for (var i = data.length - 1; i >= 0; i--) {
              var cur = data[i];
              if (cur < 0)
                cur += 4294967296;
              var tmp = cur.toString(base);
              if (ret !== "") {
                ret += "0".repeat(len - tmp.length - 1);
              }
              ret += tmp;
            }
            if (this["_"] === 0) {
              ret = ret.replace(/^0+/, "");
              if (ret === "")
                ret = "0";
              return ret;
            } else {
              ret = "1111" + ret;
              return ret.replace(/^1+/, "...1111");
            }
          } else {
            if (2 > base || base > 36)
              throw SyntaxError("Invalid base");
            var ret = [];
            var arr = [];
            for (var i = data.length; i--; ) {
              for (var j = WORD_LENGTH; j--; ) {
                arr.push(data[i] >>> j & 1);
              }
            }
            do {
              ret.unshift(divide(arr, base).toString(base));
            } while (!arr.every(function(x) {
              return x === 0;
            }));
            return ret.join("");
          }
        },
        /**
         * Check if the BitSet is empty, means all bits are unset
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * bs1.isEmpty() ? 'yes' : 'no'
         *
         * @returns {boolean} Whether the bitset is empty
         */
        "isEmpty": function() {
          if (this["_"] !== 0)
            return false;
          var d = this["data"];
          for (var i = d.length - 1; i >= 0; i--) {
            if (d[i] !== 0)
              return false;
          }
          return true;
        },
        /**
         * Calculates the number of bits set
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * var num = bs1.cardinality();
         *
         * @returns {number} The number of bits set
         */
        "cardinality": function() {
          if (this["_"] !== 0) {
            return Infinity;
          }
          var s = 0;
          var d = this["data"];
          for (var i = 0; i < d.length; i++) {
            var n = d[i];
            if (n !== 0)
              s += popCount(n);
          }
          return s;
        },
        /**
         * Calculates the Most Significant Bit / log base two
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * var logbase2 = bs1.msb();
         *
         * var truncatedTwo = Math.pow(2, logbase2); // May overflow!
         *
         * @returns {number} The index of the highest bit set
         */
        "msb": Math["clz32"] ? function() {
          if (this["_"] !== 0) {
            return Infinity;
          }
          var data = this["data"];
          for (var i = data.length; i-- > 0; ) {
            var c = Math["clz32"](data[i]);
            if (c !== WORD_LENGTH) {
              return i * WORD_LENGTH + WORD_LENGTH - 1 - c;
            }
          }
          return Infinity;
        } : function() {
          if (this["_"] !== 0) {
            return Infinity;
          }
          var data = this["data"];
          for (var i = data.length; i-- > 0; ) {
            var v = data[i];
            var c = 0;
            if (v) {
              for (; (v >>>= 1) > 0; c++) {
              }
              return i * WORD_LENGTH + c;
            }
          }
          return Infinity;
        },
        /**
         * Calculates the number of trailing zeros
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * var ntz = bs1.ntz();
         *
         * @returns {number} The index of the lowest bit set
         */
        "ntz": function() {
          var data = this["data"];
          for (var j = 0; j < data.length; j++) {
            var v = data[j];
            if (v !== 0) {
              v = (v ^ v - 1) >>> 1;
              return j * WORD_LENGTH + popCount(v);
            }
          }
          return Infinity;
        },
        /**
         * Calculates the Least Significant Bit
         *
         * Ex:
         * bs1 = new BitSet(10);
         *
         * var lsb = bs1.lsb();
         *
         * @returns {number} The index of the lowest bit set
         */
        "lsb": function() {
          var data = this["data"];
          for (var i = 0; i < data.length; i++) {
            var v = data[i];
            var c = 0;
            if (v) {
              var bit = v & -v;
              for (; bit >>>= 1; c++) {
              }
              return WORD_LENGTH * i + c;
            }
          }
          return this["_"] & 1;
        },
        /**
         * Compares two BitSet objects
         *
         * Ex:
         * bs1 = new BitSet(10);
         * bs2 = new BitSet(10);
         *
         * bs1.equals(bs2) ? 'yes' : 'no'
         *
         * @param {BitSet} val A bitset object
         * @returns {boolean} Whether the two BitSets have the same bits set (valid for indefinite sets as well)
         */
        "equals": function(val) {
          parse2(P, val);
          var t = this["data"];
          var p = P["data"];
          var t_ = this["_"];
          var p_ = P["_"];
          var tl = t.length - 1;
          var pl = p.length - 1;
          if (p_ !== t_) {
            return false;
          }
          var minLength = tl < pl ? tl : pl;
          var i = 0;
          for (; i <= minLength; i++) {
            if (t[i] !== p[i])
              return false;
          }
          for (i = tl; i > pl; i--) {
            if (t[i] !== p_)
              return false;
          }
          for (i = pl; i > tl; i--) {
            if (p[i] !== t_)
              return false;
          }
          return true;
        },
        [Symbol.iterator]: function() {
          var d = this["data"];
          var ndx = 0;
          if (this["_"] === 0) {
            var highest = 0;
            for (var i = d.length - 1; i >= 0; i--) {
              if (d[i] !== 0) {
                highest = i;
                break;
              }
            }
            return {
              "next": function() {
                var n = ndx >>> WORD_LOG;
                return {
                  "done": n > highest || n === highest && d[n] >>> ndx === 0,
                  "value": n > highest ? 0 : d[n] >>> ndx++ & 1
                };
              }
            };
          } else {
            return {
              "next": function() {
                var n = ndx >>> WORD_LOG;
                return {
                  "done": false,
                  "value": n < d.length ? d[n] >>> ndx++ & 1 : 1
                };
              }
            };
          }
        }
      };
      BitSet["fromBinaryString"] = function(str) {
        return new BitSet("0b" + str);
      };
      BitSet["fromHexString"] = function(str) {
        return new BitSet("0x" + str);
      };
      BitSet["Random"] = function(n) {
        if (n === void 0 || n < 0) {
          n = WORD_LENGTH;
        }
        var m = n % WORD_LENGTH;
        var t = [];
        var len = Math.ceil(n / WORD_LENGTH);
        var s = Object.create(BitSet.prototype);
        for (var i = 0; i < len; i++) {
          t.push(Math.random() * 4294967296 | 0);
        }
        if (m > 0) {
          t[len - 1] &= (1 << m) - 1;
        }
        s["data"] = t;
        s["_"] = 0;
        return s;
      };
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return BitSet;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(exports, "__esModule", { "value": true });
        BitSet["default"] = BitSet;
        BitSet["BitSet"] = BitSet;
        module["exports"] = BitSet;
      } else {
        root["BitSet"] = BitSet;
      }
    })(exports);
  }
});

// node_modules/proskomma-core/package.json
var require_package = __commonJS({
  "node_modules/proskomma-core/package.json"(exports, module) {
    module.exports = {
      name: "proskomma-core",
      version: "0.9.14",
      description: "A Scripture Runtime Engine",
      exports: {
        require: "./index.cjs",
        import: "./esm/wrapper.mjs"
      },
      scripts: {
        test: 'export PKSRC=dist && npm run build && bash -c "tape -r @babel/register test/code/*.cjs | node_modules/tap-summary/bin/cmd.js"',
        srcTest: 'bash -c "tape test/code/main/*.cjs test/code/utils/*.cjs | node_modules/tap-summary/bin/cmd.js"',
        rawTest: 'export PKSRC=dist && npm run build && bash -c "tape -r @babel/register test/code/*.cjs"',
        oneTest: 'bash -c "tape -r @babel/register test/code/$TESTSCRIPT.cjs"',
        oneSrcTest: 'export PKSRC=src && bash -c "tape -r @babel/register test/code/$TESTSCRIPT.cjs"',
        coverage: 'node_modules/nyc/bin/nyc.js bash -c "tape -r @babel/register test/code/*.cjs"',
        build: "rm -fr dist && webpack --mode production --config webpack.prod.js",
        serialize: "tape -r @babel/register test/code/serialize.cjs",
        rawSrcTest: 'export PKSRC=src && bash -c "tape test/code/main/*.cjs"',
        testUtils: 'bash -c "tape test/code/utils/*.cjs"'
      },
      repository: {
        type: "git",
        url: "git+https://github.com/Proskomma/proskomma-core.git"
      },
      keywords: [
        "USFM",
        "USX",
        "Scripture",
        "parser",
        "lexer",
        "Proskomma"
      ],
      author: "Mark Howe",
      license: "MIT",
      bugs: {
        url: "https://github.com/Proskomma/proskomma-core/issues"
      },
      homepage: "https://github.com/Proskomma/proskomma-core#readme",
      dependencies: {
        "@babel/core": "^7.19.0",
        "@graphql-tools/schema": "^9.0.3",
        assert: "^2.0.0",
        "async-mutex": "^0.4.0",
        "babel-eslint": "^10.1.0",
        "base64-js": "^1.5.1",
        bitset: "^5.1.1",
        btoa: "^1.2.1",
        checksum: "^1.0.0",
        "constants-browserify": "^1.0.0",
        "crypto-browserify": "^3.12.0",
        "deep-copy-all": "^1.3.4",
        "deep-equal": "^2.0.5",
        exceljs: "^4.3.0",
        "fs-extra": "^11.1.0",
        graphql: "^v16.6.0",
        "node-polyfill-webpack-plugin": "^2.0.1",
        "path-browserify": "^1.0.1",
        "proskomma-json-tools": "^0.6.5",
        "pure-uuid": "^1.6.2",
        sax: "^1.2.4",
        stream: "0.0.2",
        string_decoder: "^1.3.0",
        "utf8-string-bytes": "^1.0.3",
        util: "^0.12.4",
        xregexp: "^5.1.1"
      },
      devDependencies: {
        "@babel/cli": "^7.18.10",
        "@babel/eslint-parser": "^7.18.9",
        "@babel/preset-env": "^7.19.0",
        "@babel/register": "^7.18.9",
        "babel-loader": "^8.2.5",
        buffer: "^6.0.3",
        eslint: "^8.23.0",
        "eslint-config-prettier": "^8.5.0",
        "eslint-plugin-import": "^2.26.0",
        "eslint-plugin-jsdoc": "^39.3.6",
        "eslint-plugin-prettier": "^v4.2.1",
        nyc: "^15.1.0",
        path: "^0.12.7",
        prettier: "^2.7.1",
        process: "^0.11.10",
        "tap-summary": "^4.0.0",
        tape: "^5.6.0",
        webpack: "5.75.0",
        "webpack-cli": "4.10.0"
      }
    };
  }
});

// node_modules/utf8-string-bytes/index.js
var require_utf8_string_bytes = __commonJS({
  "node_modules/utf8-string-bytes/index.js"(exports, module) {
    init_process();
    init_buffer();
    var stringToUtf8ByteArray = function(str) {
      var out = [], p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if ((c & 64512) == 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) == 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    var utf8ByteArrayToString = function(bytes) {
      var out = [], pos = 0, c = 0;
      while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          var c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          var c4 = bytes[pos++];
          var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    module.exports = {
      utf8ByteArrayToString,
      stringToUtf8ByteArray
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    exports.byteLength = byteLength2;
    exports.toByteArray = toByteArray2;
    exports.fromByteArray = fromByteArray2;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup2[i] = code[i];
      revLookup2[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/proskomma-core/src/util/byteArray.cjs
var require_byteArray = __commonJS({
  "node_modules/proskomma-core/src/util/byteArray.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { utf8ByteArrayToString, stringToUtf8ByteArray } = require_utf8_string_bytes();
    var base64 = require_base64_js();
    var checkNum = (n, func, field) => {
      if (typeof n !== "number") {
        throw new Error(`Argument ${field} of ${func} should be a number, not '${n}' (${typeof n})`);
      }
    };
    var ByteArray = class {
      constructor(initialArraySize, initialLength) {
        initialArraySize = initialArraySize || 64;
        initialLength = initialLength || 0;
        this.growMax = 1024 * 16;
        this.length = initialLength;
        this.byteArray = new Uint8Array(initialArraySize);
      }
      byte(n) {
        checkNum(n, "byte", "n");
        if (n > this.length - 1) {
          throw Error(`Attempt to read byte ${n} of ByteArray of length ${this.length}`);
        }
        return this.byteArray[n];
      }
      bytes(n, l) {
        checkNum(n, "bytes", "n");
        checkNum(l, "bytes", "l");
        if (n + l > this.length) {
          throw Error(`Attempt to read ${l} bytes from start ${n} of ByteArray of length ${this.length}`);
        }
        return this.byteArray.subarray(n, n + l);
      }
      setByte(n, v) {
        checkNum(n, "setByte", "n");
        checkNum(v, "setByte", "v");
        if (n > this.length - 1) {
          throw Error(`Attempt to set byte ${n} of ByteArray of length ${this.length}`);
        }
        if (typeof v !== "number" || v < 0 || v > 255) {
          throw Error(`Expected value 0-255 when setting ByteArray, found ${v}`);
        }
        this.byteArray[n] = v;
      }
      setBytes(n, v) {
        checkNum(n, "setBytes", "n");
        if (n + v.length > this.length) {
          throw Error(`Attempt to set ${v.length} bytes from start ${n} of ByteArray of length ${this.length}`);
        }
        this.byteArray.set(v, n);
      }
      pushByte(v) {
        if (typeof v !== "number" || v < 0 || v > 255) {
          throw Error(`Expected value 0-255 when pushing to ByteArray, found ${v}`);
        }
        if (this.length === this.byteArray.length) {
          this.grow();
        }
        this.byteArray[this.length] = v;
        this.length++;
      }
      grow(minNewSize) {
        const newBytes = new Uint8Array(
          Math.max(
            minNewSize || 0,
            this.byteArray.length + Math.min(
              this.growMax,
              Math.max(
                16,
                this.byteArray.length
              )
            )
          )
        );
        newBytes.set(this.byteArray);
        this.byteArray = newBytes;
      }
      trim() {
        const newBytes = new Uint8Array(this.length);
        newBytes.set(this.byteArray.subarray(0, this.length));
        this.byteArray = newBytes;
      }
      pushBytes(v) {
        for (const ve of v) {
          this.pushByte(ve);
        }
      }
      pushNByte(v) {
        checkNum(v, "pushNByte", "v");
        if (typeof v !== "number" || v < 0) {
          throw Error(`Expected positive number in pushNByte, found ${v}`);
        }
        if (v < 128) {
          this.pushByte(v + 128);
        } else {
          const modulo = v % 128;
          this.pushByte(modulo);
          this.pushNByte(v >> 7);
        }
      }
      pushNBytes(vArray) {
        for (const v of vArray) {
          try {
            this.pushNByte(v);
          } catch (err) {
            throw Error(`Error from pushNByte, called as pushNBytes(${JSON.stringify(vArray)})`);
          }
        }
      }
      nByte(n) {
        checkNum(n, "nByte", "n");
        if (n > this.length - 1) {
          throw Error(`Attempt to read nByte ${n} of ByteArray of length ${this.length}`);
        }
        const v = this.byteArray[n];
        if (v > 127) {
          return v - 128;
        } else {
          return v + 128 * this.nByte(n + 1);
        }
      }
      nBytes(n, nValues) {
        checkNum(n, "nBytes", "n");
        checkNum(nValues, "nBytes", "nValues");
        const ret = [];
        while (nValues > 0) {
          let done2 = false;
          let currentValue = 0;
          let multiplier = 1;
          do {
            if (n > this.length - 1) {
              throw Error(`Attempt to read nByte ${n} of ByteArray of length ${this.length} in nBytes(${n}, ${nValues})`);
            }
            const v = this.byteArray[n];
            if (v > 127) {
              currentValue += (v - 128) * multiplier;
              ret.push(currentValue);
              currentValue = 0;
              done2 = true;
            } else {
              currentValue += v * multiplier;
              multiplier *= 128;
            }
            n++;
          } while (!done2);
          nValues--;
        }
        return ret;
      }
      nByteLength(v) {
        checkNum(v, "nByteLength", "v");
        if (v >= 128 ** 4) {
          throw new Error("> 4 bytes found in nByteLength");
        }
        let ret = 1;
        while (v > 127) {
          v = v >> 7;
          ret += 1;
        }
        return ret;
      }
      pushCountedString(s) {
        const sA = stringToUtf8ByteArray(s);
        this.pushByte(sA.length);
        this.pushBytes(sA);
      }
      countedString(n) {
        checkNum(n, "countedString", "n");
        const sLength = this.byte(n);
        return utf8ByteArrayToString(this.bytes(n + 1, sLength));
      }
      clear() {
        this.byteArray.fill(0);
        this.length = 0;
      }
      base64() {
        return base64.fromByteArray(this.byteArray);
      }
      fromBase64(s) {
        this.byteArray = base64.toByteArray(s);
        this.length = this.byteArray.length;
      }
      deleteItem(n) {
        checkNum(n, "deleteItem", "n");
        const itemLength = this.byte(n) & 63;
        this.length -= itemLength;
        if (this.length > n) {
          const remainingBytes = this.byteArray.slice(n + itemLength);
          this.byteArray.set(remainingBytes, n);
        }
      }
      insert(n, iba) {
        checkNum(n, "insert", "n");
        const insertLength = iba.length;
        const newLength = this.length + insertLength;
        if (newLength >= this.byteArray.length + insertLength) {
          this.grow(newLength);
        }
        if (n < newLength) {
          const displacedBytes = this.byteArray.slice(n, this.length);
          this.byteArray.set(displacedBytes, n + insertLength);
        }
        this.byteArray.set(iba.byteArray.slice(0, iba.length), n);
        this.length = newLength;
      }
    };
    module.exports = ByteArray;
  }
});

// node_modules/proskomma-core/src/util/canons.cjs
var require_canons = __commonJS({
  "node_modules/proskomma-core/src/util/canons.cjs"(exports, module) {
    init_process();
    init_buffer();
    var ptBookArray = [
      { code: "GEN", categories: ["ot", "pentateuch"] },
      { code: "EXO", categories: ["ot", "pentateuch"] },
      { code: "LEV", categories: ["ot", "pentateuch"] },
      { code: "NUM", categories: ["ot", "pentateuch"] },
      { code: "DEU", categories: ["ot", "pentateuch"] },
      { code: "JOS", categories: ["ot", "history"] },
      { code: "JDG", categories: ["ot", "history"] },
      { code: "RUT", categories: ["ot", "history"] },
      { code: "1SA", categories: ["ot", "history"] },
      { code: "2SA", categories: ["ot", "history"] },
      { code: "1KI", categories: ["ot", "history"] },
      { code: "2KI", categories: ["ot", "history"] },
      { code: "1CH", categories: ["ot", "history"] },
      { code: "2CH", categories: ["ot", "history"] },
      { code: "EZR", categories: ["ot", "history"] },
      { code: "NEH", categories: ["ot", "history"] },
      { code: "EST", categories: ["ot", "history"] },
      { code: "JOB", categories: ["ot", "wisdom"] },
      { code: "PSA", categories: ["ot", "wisdom"] },
      { code: "PRO", categories: ["ot", "wisdom"] },
      { code: "ECC", categories: ["ot", "wisdom"] },
      { code: "SNG", categories: ["ot", "wisdom"] },
      { code: "ISA", categories: ["ot", "prophecy"] },
      { code: "JER", categories: ["ot", "prophecy"] },
      { code: "LAM", categories: ["ot", "prophecy"] },
      { code: "EZK", categories: ["ot", "prophecy"] },
      { code: "DAN", categories: ["ot", "prophecy"] },
      { code: "HOS", categories: ["ot", "prophecy"] },
      { code: "JOL", categories: ["ot", "prophecy"] },
      { code: "AMO", categories: ["ot", "prophecy"] },
      { code: "OBA", categories: ["ot", "prophecy"] },
      { code: "JON", categories: ["ot", "prophecy"] },
      { code: "MIC", categories: ["ot", "prophecy"] },
      { code: "NAM", categories: ["ot", "prophecy"] },
      { code: "HAB", categories: ["ot", "prophecy"] },
      { code: "ZEP", categories: ["ot", "prophecy"] },
      { code: "HAG", categories: ["ot", "prophecy"] },
      { code: "ZEC", categories: ["ot", "prophecy"] },
      { code: "MAL", categories: ["ot", "prophecy"] },
      { code: "MAT", categories: ["nt", "gospel", "synoptic"] },
      { code: "MRK", categories: ["nt", "gospel", "synoptic"] },
      { code: "LUK", categories: ["nt", "gospel", "synoptic"] },
      { code: "JHN", categories: ["nt", "gospel"] },
      { code: "ACT", categories: ["nt", "gospel"] },
      { code: "ROM", categories: ["nt", "epistle"] },
      { code: "1CO", categories: ["nt", "epistle"] },
      { code: "2CO", categories: ["nt", "epistle"] },
      { code: "GAL", categories: ["nt", "epistle"] },
      { code: "EPH", categories: ["nt", "epistle"] },
      { code: "PHP", categories: ["nt", "epistle"] },
      { code: "COL", categories: ["nt", "epistle"] },
      { code: "1TH", categories: ["nt", "epistle"] },
      { code: "2TH", categories: ["nt", "epistle"] },
      { code: "1TI", categories: ["nt", "epistle"] },
      { code: "2TI", categories: ["nt", "epistle"] },
      { code: "TIT", categories: ["nt", "epistle"] },
      { code: "PHM", categories: ["nt", "epistle"] },
      { code: "HEB", categories: ["nt", "epistle"] },
      { code: "JAS", categories: ["nt", "epistle"] },
      { code: "1PE", categories: ["nt", "epistle"] },
      { code: "2PE", categories: ["nt", "epistle"] },
      { code: "1JN", categories: ["nt", "epistle"] },
      { code: "2JN", categories: ["nt", "epistle"] },
      { code: "3JN", categories: ["nt", "epistle"] },
      { code: "JUD", categories: ["nt", "epistle"] },
      { code: "REV", categories: ["nt", "epistle"] },
      { code: "TOB", categories: ["dc"] },
      { code: "JDT", categories: ["dc"] },
      { code: "ESG", categories: ["dc", "history"] },
      { code: "WIS", categories: ["dc", "wisdom"] },
      { code: "SIR", categories: ["dc", "wisdom"] },
      { code: "BAR", categories: ["dc", "prophecy"] },
      { code: "LJE", categories: ["dc"] },
      { code: "S3Y", categories: ["dc"] },
      { code: "SUS", categories: ["dc"] },
      { code: "BEL", categories: ["dc"] },
      { code: "1MA", categories: ["dc"] },
      { code: "2MA", categories: ["dc"] },
      { code: "3MA", categories: ["dc"] },
      { code: "4MA", categories: ["dc"] },
      { code: "1ES", categories: ["dc"] },
      { code: "2ES", categories: ["dc"] },
      { code: "MAN", categories: ["dc"] },
      { code: "PS2", categories: ["dc"] },
      { code: "ODA", categories: ["dc"] },
      { code: "PSS", categories: ["dc"] },
      { code: "JSA", categories: ["dc"] },
      { code: "JDB", categories: ["dc"] },
      { code: "TBS", categories: ["dc"] },
      { code: "SST", categories: ["dc"] },
      { code: "DNT", categories: ["dc"] },
      { code: "BLT", categories: ["dc"] },
      { code: "EZA", categories: ["dc"] },
      { code: "5EZ", categories: ["dc"] },
      { code: "6EZ", categories: ["dc"] },
      { code: "DAG", categories: ["dc"] },
      { code: "PS3", categories: ["dc"] },
      { code: "2BA", categories: ["dc"] },
      { code: "LBA", categories: ["dc"] },
      { code: "JUB", categories: ["dc"] },
      { code: "ENO", categories: ["dc"] },
      { code: "1MQ", categories: ["dc"] },
      { code: "2MQ", categories: ["dc"] },
      { code: "3MQ", categories: ["dc"] },
      { code: "REP", categories: ["dc"] },
      { code: "4BA", categories: ["dc"] },
      { code: "LAO", categories: ["dc"] }
    ];
    var ptBooks = {};
    for (const br of ptBookArray.entries()) {
      ptBooks[br[1].code] = { ...br[1], position: br[0] };
    }
    module.exports = { ptBookArray, ptBooks };
  }
});

// node_modules/proskomma-core/src/util/enums.cjs
var require_enums = __commonJS({
  "node_modules/proskomma-core/src/util/enums.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var enumStringIndex = (enumSuccinct, str) => {
      let pos = 0;
      let count = 0;
      while (pos < enumSuccinct.length) {
        const stringLength = enumSuccinct.byte(pos);
        const enumString = enumSuccinct.countedString(pos);
        if (enumString === str) {
          return count;
        }
        pos += stringLength + 1;
        count += 1;
      }
      return -1;
    };
    var enumRegexIndexTuples = (enumSuccinct, regex) => {
      let pos = 0;
      let count = 0;
      const ret = [];
      while (pos < enumSuccinct.length) {
        const stringLength = enumSuccinct.byte(pos);
        const enumString = enumSuccinct.countedString(pos);
        if (xre.exec(enumString, xre(regex, "i"))) {
          ret.push([count, enumString]);
        }
        pos += stringLength + 1;
        count += 1;
      }
      return ret;
    };
    module.exports = {
      enumStringIndex,
      enumRegexIndexTuples
    };
  }
});

// node_modules/pure-uuid/uuid.js
var require_uuid = __commonJS({
  "node_modules/pure-uuid/uuid.js"(exports, module) {
    init_process();
    init_buffer();
    (function(root, name, factory) {
      if (typeof define === "function" && typeof define.amd !== "undefined")
        define(function() {
          return factory(root);
        });
      else if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(root);
        module.exports.default = module.exports;
      } else
        root[name] = factory(root);
    })(exports, "UUID", function() {
      var a2hs = function(bytes, begin, end, uppercase, str, pos) {
        var mkNum = function(num, uppercase2) {
          var base16 = num.toString(16);
          if (base16.length < 2)
            base16 = "0" + base16;
          if (uppercase2)
            base16 = base16.toUpperCase();
          return base16;
        };
        for (var i = begin; i <= end; i++)
          str[pos++] = mkNum(bytes[i], uppercase);
        return str;
      };
      var hs2a = function(str, begin, end, bytes, pos) {
        for (var i = begin; i <= end; i += 2)
          bytes[pos++] = parseInt(str.substr(i, 2), 16);
      };
      var z85_encoder = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#".split("");
      var z85_decoder = [
        0,
        68,
        0,
        84,
        83,
        82,
        72,
        0,
        75,
        76,
        70,
        65,
        0,
        63,
        62,
        69,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        64,
        0,
        73,
        66,
        74,
        71,
        81,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        77,
        0,
        78,
        67,
        0,
        0,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        79,
        0,
        80,
        0,
        0
      ];
      var z85_encode = function(data, size) {
        if (size % 4 !== 0)
          throw new Error("z85_encode: invalid input length (multiple of 4 expected)");
        var str = "";
        var i = 0;
        var value = 0;
        while (i < size) {
          value = value * 256 + data[i++];
          if (i % 4 === 0) {
            var divisor = 85 * 85 * 85 * 85;
            while (divisor >= 1) {
              var idx = Math.floor(value / divisor) % 85;
              str += z85_encoder[idx];
              divisor /= 85;
            }
            value = 0;
          }
        }
        return str;
      };
      var z85_decode = function(str, dest) {
        var l = str.length;
        if (l % 5 !== 0)
          throw new Error("z85_decode: invalid input length (multiple of 5 expected)");
        if (typeof dest === "undefined")
          dest = new Array(l * 4 / 5);
        var i = 0;
        var j = 0;
        var value = 0;
        while (i < l) {
          var idx = str.charCodeAt(i++) - 32;
          if (idx < 0 || idx >= z85_decoder.length)
            break;
          value = value * 85 + z85_decoder[idx];
          if (i % 5 === 0) {
            var divisor = 256 * 256 * 256;
            while (divisor >= 1) {
              dest[j++] = Math.trunc(value / divisor % 256);
              divisor /= 256;
            }
            value = 0;
          }
        }
        return dest;
      };
      var s2a = function(s, _options) {
        var options = { ibits: 8, obits: 8, obigendian: true };
        for (var opt in _options)
          if (typeof options[opt] !== "undefined")
            options[opt] = _options[opt];
        var a = [];
        var i = 0;
        var c, C;
        var ck = 0;
        var w;
        var wk = 0;
        var sl = s.length;
        for (; ; ) {
          if (ck === 0)
            C = s.charCodeAt(i++);
          c = C >> options.ibits - (ck + 8) & 255;
          ck = (ck + 8) % options.ibits;
          if (options.obigendian) {
            if (wk === 0)
              w = c << options.obits - 8;
            else
              w |= c << options.obits - 8 - wk;
          } else {
            if (wk === 0)
              w = c;
            else
              w |= c << wk;
          }
          wk = (wk + 8) % options.obits;
          if (wk === 0) {
            a.push(w);
            if (i >= sl)
              break;
          }
        }
        return a;
      };
      var a2s = function(a, _options) {
        var options = { ibits: 32, ibigendian: true };
        for (var opt in _options)
          if (typeof options[opt] !== "undefined")
            options[opt] = _options[opt];
        var s = "";
        var imask = 4294967295;
        if (options.ibits < 32)
          imask = (1 << options.ibits) - 1;
        var al = a.length;
        for (var i = 0; i < al; i++) {
          var w = a[i] & imask;
          for (var j = 0; j < options.ibits; j += 8) {
            if (options.ibigendian)
              s += String.fromCharCode(w >> options.ibits - 8 - j & 255);
            else
              s += String.fromCharCode(w >> j & 255);
          }
        }
        return s;
      };
      var UI64_DIGITS = 8;
      var UI64_DIGIT_BITS = 8;
      var UI64_DIGIT_BASE = 256;
      var ui64_d2i = function(d7, d6, d5, d4, d3, d2, d1, d0) {
        return [d0, d1, d2, d3, d4, d5, d6, d7];
      };
      var ui64_zero = function() {
        return ui64_d2i(0, 0, 0, 0, 0, 0, 0, 0);
      };
      var ui64_clone = function(x) {
        return x.slice(0);
      };
      var ui64_n2i = function(n) {
        var ui64 = ui64_zero();
        for (var i = 0; i < UI64_DIGITS; i++) {
          ui64[i] = Math.floor(n % UI64_DIGIT_BASE);
          n /= UI64_DIGIT_BASE;
        }
        return ui64;
      };
      var ui64_i2n = function(x) {
        var n = 0;
        for (var i = UI64_DIGITS - 1; i >= 0; i--) {
          n *= UI64_DIGIT_BASE;
          n += x[i];
        }
        return Math.floor(n);
      };
      var ui64_add = function(x, y) {
        var carry = 0;
        for (var i = 0; i < UI64_DIGITS; i++) {
          carry += x[i] + y[i];
          x[i] = Math.floor(carry % UI64_DIGIT_BASE);
          carry = Math.floor(carry / UI64_DIGIT_BASE);
        }
        return carry;
      };
      var ui64_muln = function(x, n) {
        var carry = 0;
        for (var i = 0; i < UI64_DIGITS; i++) {
          carry += x[i] * n;
          x[i] = Math.floor(carry % UI64_DIGIT_BASE);
          carry = Math.floor(carry / UI64_DIGIT_BASE);
        }
        return carry;
      };
      var ui64_mul = function(x, y) {
        var i, j;
        var zx = new Array(UI64_DIGITS + UI64_DIGITS);
        for (i = 0; i < UI64_DIGITS + UI64_DIGITS; i++)
          zx[i] = 0;
        var carry;
        for (i = 0; i < UI64_DIGITS; i++) {
          carry = 0;
          for (j = 0; j < UI64_DIGITS; j++) {
            carry += x[i] * y[j] + zx[i + j];
            zx[i + j] = carry % UI64_DIGIT_BASE;
            carry /= UI64_DIGIT_BASE;
          }
          for (; j < UI64_DIGITS + UI64_DIGITS - i; j++) {
            carry += zx[i + j];
            zx[i + j] = carry % UI64_DIGIT_BASE;
            carry /= UI64_DIGIT_BASE;
          }
        }
        for (i = 0; i < UI64_DIGITS; i++)
          x[i] = zx[i];
        return zx.slice(UI64_DIGITS, UI64_DIGITS);
      };
      var ui64_and = function(x, y) {
        for (var i = 0; i < UI64_DIGITS; i++)
          x[i] &= y[i];
        return x;
      };
      var ui64_or = function(x, y) {
        for (var i = 0; i < UI64_DIGITS; i++)
          x[i] |= y[i];
        return x;
      };
      var ui64_rorn = function(x, s) {
        var ov = ui64_zero();
        if (s % UI64_DIGIT_BITS !== 0)
          throw new Error("ui64_rorn: only bit rotations supported with a multiple of digit bits");
        var k = Math.floor(s / UI64_DIGIT_BITS);
        for (var i = 0; i < k; i++) {
          for (var j = UI64_DIGITS - 1 - 1; j >= 0; j--)
            ov[j + 1] = ov[j];
          ov[0] = x[0];
          for (j = 0; j < UI64_DIGITS - 1; j++)
            x[j] = x[j + 1];
          x[j] = 0;
        }
        return ui64_i2n(ov);
      };
      var ui64_ror = function(x, s) {
        if (s > UI64_DIGITS * UI64_DIGIT_BITS)
          throw new Error("ui64_ror: invalid number of bits to shift");
        var zx = new Array(UI64_DIGITS + UI64_DIGITS);
        var i;
        for (i = 0; i < UI64_DIGITS; i++) {
          zx[i + UI64_DIGITS] = x[i];
          zx[i] = 0;
        }
        var k1 = Math.floor(s / UI64_DIGIT_BITS);
        var k2 = s % UI64_DIGIT_BITS;
        for (i = k1; i < UI64_DIGITS + UI64_DIGITS - 1; i++) {
          zx[i - k1] = (zx[i] >>> k2 | zx[i + 1] << UI64_DIGIT_BITS - k2) & (1 << UI64_DIGIT_BITS) - 1;
        }
        zx[UI64_DIGITS + UI64_DIGITS - 1 - k1] = zx[UI64_DIGITS + UI64_DIGITS - 1] >>> k2 & (1 << UI64_DIGIT_BITS) - 1;
        for (i = UI64_DIGITS + UI64_DIGITS - 1 - k1 + 1; i < UI64_DIGITS + UI64_DIGITS; i++)
          zx[i] = 0;
        for (i = 0; i < UI64_DIGITS; i++)
          x[i] = zx[i + UI64_DIGITS];
        return zx.slice(0, UI64_DIGITS);
      };
      var ui64_rol = function(x, s) {
        if (s > UI64_DIGITS * UI64_DIGIT_BITS)
          throw new Error("ui64_rol: invalid number of bits to shift");
        var zx = new Array(UI64_DIGITS + UI64_DIGITS);
        var i;
        for (i = 0; i < UI64_DIGITS; i++) {
          zx[i + UI64_DIGITS] = 0;
          zx[i] = x[i];
        }
        var k1 = Math.floor(s / UI64_DIGIT_BITS);
        var k2 = s % UI64_DIGIT_BITS;
        for (i = UI64_DIGITS - 1 - k1; i > 0; i--) {
          zx[i + k1] = (zx[i] << k2 | zx[i - 1] >>> UI64_DIGIT_BITS - k2) & (1 << UI64_DIGIT_BITS) - 1;
        }
        zx[0 + k1] = zx[0] << k2 & (1 << UI64_DIGIT_BITS) - 1;
        for (i = 0 + k1 - 1; i >= 0; i--)
          zx[i] = 0;
        for (i = 0; i < UI64_DIGITS; i++)
          x[i] = zx[i];
        return zx.slice(UI64_DIGITS, UI64_DIGITS);
      };
      var ui64_xor = function(x, y) {
        for (var i = 0; i < UI64_DIGITS; i++)
          x[i] ^= y[i];
      };
      var ui32_add = function(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      };
      var ui32_rol = function(num, cnt) {
        return num << cnt & 4294967295 | num >>> 32 - cnt & 4294967295;
      };
      var sha1_core = function(x, len) {
        function sha1_ft(t2, b2, c2, d2) {
          if (t2 < 20)
            return b2 & c2 | ~b2 & d2;
          if (t2 < 40)
            return b2 ^ c2 ^ d2;
          if (t2 < 60)
            return b2 & c2 | b2 & d2 | c2 & d2;
          return b2 ^ c2 ^ d2;
        }
        function sha1_kt(t2) {
          return t2 < 20 ? 1518500249 : t2 < 40 ? 1859775393 : t2 < 60 ? -1894007588 : -899497514;
        }
        x[len >> 5] |= 128 << 24 - len % 32;
        x[(len + 64 >> 9 << 4) + 15] = len;
        var w = Array(80);
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        var e = -1009589776;
        for (var i = 0; i < x.length; i += 16) {
          var olda = a;
          var oldb = b;
          var oldc = c;
          var oldd = d;
          var olde = e;
          for (var j = 0; j < 80; j++) {
            if (j < 16)
              w[j] = x[i + j];
            else
              w[j] = ui32_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            var t = ui32_add(
              ui32_add(ui32_rol(a, 5), sha1_ft(j, b, c, d)),
              ui32_add(ui32_add(e, w[j]), sha1_kt(j))
            );
            e = d;
            d = c;
            c = ui32_rol(b, 30);
            b = a;
            a = t;
          }
          a = ui32_add(a, olda);
          b = ui32_add(b, oldb);
          c = ui32_add(c, oldc);
          d = ui32_add(d, oldd);
          e = ui32_add(e, olde);
        }
        return [a, b, c, d, e];
      };
      var sha1 = function(s) {
        return a2s(
          sha1_core(
            s2a(s, { ibits: 8, obits: 32, obigendian: true }),
            s.length * 8
          ),
          { ibits: 32, ibigendian: true }
        );
      };
      var md5_core = function(x, len) {
        function md5_cmn(q, a2, b2, x2, s, t) {
          return ui32_add(ui32_rol(ui32_add(ui32_add(a2, q), ui32_add(x2, t)), s), b2);
        }
        function md5_ff(a2, b2, c2, d2, x2, s, t) {
          return md5_cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s, t);
        }
        function md5_gg(a2, b2, c2, d2, x2, s, t) {
          return md5_cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s, t);
        }
        function md5_hh(a2, b2, c2, d2, x2, s, t) {
          return md5_cmn(b2 ^ c2 ^ d2, a2, b2, x2, s, t);
        }
        function md5_ii(a2, b2, c2, d2, x2, s, t) {
          return md5_cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s, t);
        }
        x[len >> 5] |= 128 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (var i = 0; i < x.length; i += 16) {
          var olda = a;
          var oldb = b;
          var oldc = c;
          var oldd = d;
          a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = ui32_add(a, olda);
          b = ui32_add(b, oldb);
          c = ui32_add(c, oldc);
          d = ui32_add(d, oldd);
        }
        return [a, b, c, d];
      };
      var md5 = function(s) {
        return a2s(
          md5_core(
            s2a(s, { ibits: 8, obits: 32, obigendian: false }),
            s.length * 8
          ),
          { ibits: 32, ibigendian: false }
        );
      };
      var PCG = function(seed) {
        this.mul = ui64_d2i(88, 81, 244, 45, 76, 149, 127, 45);
        this.inc = ui64_d2i(20, 5, 123, 126, 247, 103, 129, 79);
        this.mask = ui64_d2i(0, 0, 0, 0, 255, 255, 255, 255);
        this.state = ui64_clone(this.inc);
        this.next();
        ui64_and(this.state, this.mask);
        seed = ui64_n2i(seed !== void 0 ? seed >>> 0 : Math.random() * 4294967295 >>> 0);
        ui64_or(this.state, seed);
        this.next();
      };
      PCG.prototype.next = function() {
        var state = ui64_clone(this.state);
        ui64_mul(this.state, this.mul);
        ui64_add(this.state, this.inc);
        var output = ui64_clone(state);
        ui64_ror(output, 18);
        ui64_xor(output, state);
        ui64_ror(output, 27);
        var rot = ui64_clone(state);
        ui64_ror(rot, 59);
        ui64_and(output, this.mask);
        var k = ui64_i2n(rot);
        var output2 = ui64_clone(output);
        ui64_rol(output2, 32 - k);
        ui64_ror(output, k);
        ui64_xor(output, output2);
        return ui64_i2n(output);
      };
      var pcg = new PCG();
      var prng = function(len, radix) {
        var bytes = [];
        for (var i = 0; i < len; i++)
          bytes[i] = pcg.next() % radix;
        return bytes;
      };
      var time_last = 0;
      var time_seq = 0;
      var UUID = function() {
        if (arguments.length === 1 && typeof arguments[0] === "string")
          this.parse.apply(this, arguments);
        else if (arguments.length >= 1 && typeof arguments[0] === "number")
          this.make.apply(this, arguments);
        else if (arguments.length >= 1)
          throw new Error("UUID: constructor: invalid arguments");
        else
          for (var i = 0; i < 16; i++)
            this[i] = 0;
      };
      if (typeof Uint8Array !== "undefined")
        UUID.prototype = new Uint8Array(16);
      else if (Buffer)
        UUID.prototype = Buffer.alloc(16);
      else
        UUID.prototype = new Array(16);
      UUID.prototype.constructor = UUID;
      UUID.prototype.make = function(version3) {
        var i;
        var uuid = this;
        if (version3 === 1) {
          var date = new Date();
          var time_now = date.getTime();
          if (time_now !== time_last)
            time_seq = 0;
          else
            time_seq++;
          time_last = time_now;
          var t = ui64_n2i(time_now);
          ui64_muln(t, 1e3 * 10);
          ui64_add(t, ui64_d2i(1, 178, 29, 210, 19, 129, 64, 0));
          if (time_seq > 0)
            ui64_add(t, ui64_n2i(time_seq));
          var ov;
          ov = ui64_rorn(t, 8);
          uuid[3] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[2] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[1] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[0] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[5] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[4] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[7] = ov & 255;
          ov = ui64_rorn(t, 8);
          uuid[6] = ov & 15;
          var clock = prng(2, 255);
          uuid[8] = clock[0];
          uuid[9] = clock[1];
          var node = prng(6, 255);
          node[0] |= 1;
          node[0] |= 2;
          for (i = 0; i < 6; i++)
            uuid[10 + i] = node[i];
        } else if (version3 === 4) {
          var data = prng(16, 255);
          for (i = 0; i < 16; i++)
            this[i] = data[i];
        } else if (version3 === 3 || version3 === 5) {
          var input = "";
          var nsUUID = typeof arguments[1] === "object" && arguments[1] instanceof UUID ? arguments[1] : new UUID().parse(arguments[1]);
          for (i = 0; i < 16; i++)
            input += String.fromCharCode(nsUUID[i]);
          input += arguments[2];
          var s = version3 === 3 ? md5(input) : sha1(input);
          for (i = 0; i < 16; i++)
            uuid[i] = s.charCodeAt(i);
        } else
          throw new Error("UUID: make: invalid version");
        uuid[6] &= 15;
        uuid[6] |= version3 << 4;
        uuid[8] &= 63;
        uuid[8] |= 2 << 6;
        return uuid;
      };
      UUID.prototype.format = function(type) {
        var str, arr;
        if (type === "z85")
          str = z85_encode(this, 16);
        else if (type === "b16") {
          arr = Array(32);
          a2hs(this, 0, 15, true, arr, 0);
          str = arr.join("");
        } else if (type === void 0 || type === "std") {
          arr = new Array(36);
          a2hs(this, 0, 3, false, arr, 0);
          arr[8] = "-";
          a2hs(this, 4, 5, false, arr, 9);
          arr[13] = "-";
          a2hs(this, 6, 7, false, arr, 14);
          arr[18] = "-";
          a2hs(this, 8, 9, false, arr, 19);
          arr[23] = "-";
          a2hs(this, 10, 15, false, arr, 24);
          str = arr.join("");
        }
        return str;
      };
      UUID.prototype.toString = function(type) {
        return this.format(type);
      };
      UUID.prototype.toJSON = function() {
        return this.format("std");
      };
      UUID.prototype.parse = function(str, type) {
        if (typeof str !== "string")
          throw new Error("UUID: parse: invalid argument (type string expected)");
        if (type === "z85")
          z85_decode(str, this);
        else if (type === "b16")
          hs2a(str, 0, 35, this, 0);
        else if (type === void 0 || type === "std") {
          var map = {
            "nil": "00000000-0000-0000-0000-000000000000",
            "ns:DNS": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
            "ns:URL": "6ba7b811-9dad-11d1-80b4-00c04fd430c8",
            "ns:OID": "6ba7b812-9dad-11d1-80b4-00c04fd430c8",
            "ns:X500": "6ba7b814-9dad-11d1-80b4-00c04fd430c8"
          };
          if (map[str] !== void 0)
            str = map[str];
          else if (!str.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/))
            throw new Error('UUID: parse: invalid string representation (expected "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")');
          hs2a(str, 0, 7, this, 0);
          hs2a(str, 9, 12, this, 4);
          hs2a(str, 14, 17, this, 6);
          hs2a(str, 19, 22, this, 8);
          hs2a(str, 24, 35, this, 10);
        }
        return this;
      };
      UUID.prototype.export = function() {
        var arr = Array(16);
        for (var i = 0; i < 16; i++)
          arr[i] = this[i];
        return arr;
      };
      UUID.prototype.import = function(arr) {
        if (!(typeof arr === "object" && arr instanceof Array))
          throw new Error("UUID: import: invalid argument (type Array expected)");
        if (arr.length !== 16)
          throw new Error("UUID: import: invalid argument (Array of length 16 expected)");
        for (var i = 0; i < 16; i++) {
          if (typeof arr[i] !== "number")
            throw new Error("UUID: import: invalid array element #" + i + " (type Number expected)");
          if (!(isFinite(arr[i]) && Math.floor(arr[i]) === arr[i]))
            throw new Error("UUID: import: invalid array element #" + i + " (Number with integer value expected)");
          if (!(arr[i] >= 0 && arr[i] <= 255))
            throw new Error("UUID: import: invalid array element #" + i + " (Number with integer value in range 0...255 expected)");
          this[i] = arr[i];
        }
        return this;
      };
      UUID.prototype.compare = function(other) {
        if (typeof other !== "object")
          throw new Error("UUID: compare: invalid argument (type UUID expected)");
        if (!(other instanceof UUID))
          throw new Error("UUID: compare: invalid argument (type UUID expected)");
        for (var i = 0; i < 16; i++) {
          if (this[i] < other[i])
            return -1;
          else if (this[i] > other[i])
            return 1;
        }
        return 0;
      };
      UUID.prototype.equal = function(other) {
        return this.compare(other) === 0;
      };
      UUID.prototype.fold = function(k) {
        if (typeof k === "undefined")
          throw new Error("UUID: fold: invalid argument (number of fold operations expected)");
        if (k < 1 || k > 4)
          throw new Error("UUID: fold: invalid argument (1-4 fold operations expected)");
        var n = 16 / Math.pow(2, k);
        var hash = new Array(n);
        for (var i = 0; i < n; i++) {
          var h = 0;
          for (var j = 0; i + j < 16; j += n)
            h ^= this[i + j];
          hash[i] = h;
        }
        return hash;
      };
      UUID.PCG = PCG;
      return UUID;
    });
  }
});

// node_modules/btoa/index.js
var require_btoa = __commonJS({
  "node_modules/btoa/index.js"(exports, module) {
    init_process();
    init_buffer();
    (function() {
      "use strict";
      function btoa(str) {
        var buffer;
        if (str instanceof Buffer) {
          buffer = str;
        } else {
          buffer = Buffer.from(str.toString(), "binary");
        }
        return buffer.toString("base64");
      }
      module.exports = btoa;
    })();
  }
});

// node_modules/proskomma-core/src/util/generateId.cjs
var require_generateId = __commonJS({
  "node_modules/proskomma-core/src/util/generateId.cjs"(exports, module) {
    init_process();
    init_buffer();
    var UUID = require_uuid();
    var btoa = require_btoa();
    var generateId = () => btoa(new UUID(4)).substring(0, 12);
    module.exports = { generateId };
  }
});

// node_modules/proskomma-core/src/util/graftDefs.cjs
var require_graftDefs = __commonJS({
  "node_modules/proskomma-core/src/util/graftDefs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var graftLocation = {
      heading: "block",
      title: "block",
      endTitle: "block",
      remark: "block",
      footnote: "inline",
      xref: "inline",
      noteCaller: "inline",
      esbCat: "inline",
      table: "block",
      tree: "block",
      kv: "block"
    };
    module.exports = { graftLocation };
  }
});

// node_modules/proskomma-core/src/util/tokenDefs.cjs
var require_tokenDefs = __commonJS({
  "node_modules/proskomma-core/src/util/tokenDefs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var tokenEnum = {
      wordLike: 0,
      punctuation: 1,
      lineSpace: 2,
      eol: 3,
      softLineBreak: 4,
      noBreakSpace: 5,
      bareSlash: 6,
      unknown: 7
    };
    var tokenEnumLabels = Object.entries(tokenEnum).sort((a, b) => a[1] - b[1]).map((kv) => kv[0]);
    var tokenCategory = {
      wordLike: "wordLike",
      punctuation: "notWordLike",
      lineSpace: "notWordLike",
      eol: "notWordLike",
      softLineBreak: "notWordLike",
      noBreakSpace: "notWordLike",
      bareSlash: "notWordLike",
      unknown: "notWordLike"
    };
    module.exports = {
      tokenEnum,
      tokenEnumLabels,
      tokenCategory
    };
  }
});

// node_modules/proskomma-core/src/util/scopeDefs.cjs
var require_scopeDefs = __commonJS({
  "node_modules/proskomma-core/src/util/scopeDefs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var scopeEnum = {
      "blockTag": 0,
      "inline": 1,
      "chapter": 2,
      "pubChapter": 3,
      "altChapter": 4,
      "verses": 5,
      "verse": 6,
      "pubVerse": 7,
      "altVerse": 8,
      "esbCat": 9,
      "span": 10,
      "table": 11,
      "cell": 12,
      "milestone": 13,
      "spanWithAtts": 14,
      "attribute": 15,
      "hangingGraft": 16,
      "orphanTokens": 17,
      "tTableRow": 18,
      "tTableCol": 19,
      "tTreeNode": 20,
      "tTreeParent": 21,
      "tTreeChild": 22,
      "tTreeContent": 23,
      "kvPrimary": 24,
      "kvSecondary": 25,
      "kvField": 26
    };
    var scopeEnumLabels = Object.entries(scopeEnum).sort((a, b) => a[1] - b[1]).map((kv) => kv[0]);
    var splitTagNumber = (fullTagName) => {
      const tagBits = xre.exec(fullTagName, xre("([^1-9]+)(.*)"));
      const tagName = tagBits[1];
      const tagNo = tagBits[2].length > 0 ? tagBits[2] : "1";
      return [tagName, tagNo];
    };
    var cellScope = (fullTagName) => {
      const tagProps = {
        "th": {
          type: "colHeading",
          align: "left"
        },
        "thr": {
          type: "colHeading",
          align: "right"
        },
        "tc": {
          type: "body",
          align: "left"
        },
        "tcr": {
          type: "body",
          align: "right"
        }
      };
      const [tagName, tagNo] = splitTagNumber(fullTagName);
      let tagField = "1";
      if (tagNo.includes("-")) {
        const [fromN, toN] = tagNo.split("-");
        tagField = `${parseInt(toN) - parseInt(fromN) + 1}`;
      }
      return `cell/${tagProps[tagName].type}/${tagProps[tagName].align}/${tagField}`;
    };
    var labelForScope = (scopeType, scopeFields) => {
      switch (scopeType) {
        case "blockTag":
          return `blockTag/${scopeFields[0]}`;
        case "inline":
          return `inline/${scopeFields[0]}`;
        case "chapter":
          return `chapter/${scopeFields[0]}`;
        case "verses":
          return `verses/${scopeFields[0]}`;
        case "verse":
          return `verse/${scopeFields[0]}`;
        case "span":
          return `span/${scopeFields[0]}`;
        case "table":
          return "table";
        case "cell":
          return cellScope(scopeFields[0]);
        case "milestone":
          return `milestone/${scopeFields[0]}`;
        case "spanWithAtts":
          return `spanWithAtts/${scopeFields[0]}`;
        case "attribute":
          return `attribute/${scopeFields[0]}/${scopeFields[1]}/${scopeFields[2]}/${scopeFields[3]}`;
        case "orphanTokens":
          return `orphanTokens`;
        case "hangingGraft":
          return `hangingGraft`;
        case "pubChapter":
          return `pubChapter/${scopeFields[0]}`;
        case "pubVerse":
          return `pubVerse/${scopeFields[0]}`;
        case "altChapter":
          return `altChapter/${scopeFields[0]}`;
        case "altVerse":
          return `altVerse/${scopeFields[0]}`;
        case "esbCat":
          return `esbCat/${scopeFields[0]}`;
        case "tTableRow":
          return `tTableRow/${scopeFields[0]}`;
        case "tTableCol":
          return `tTableCol/${scopeFields[0]}`;
        case "tTreeNode":
          return `tTreeNode/${scopeFields[0]}`;
        case "tTreeParent":
          return `tTreeParent/${scopeFields[0]}`;
        case "tTreeChild":
          return `tTreeChild/${scopeFields[0]}/${scopeFields[1]}`;
        case "tTreeContent":
          return `tTreeContent/${scopeFields[0]}`;
        case "kvPrimary":
          return `kvPrimary/${scopeFields[0]}`;
        case "kvSecondary":
          return `kvSecondary/${scopeFields[0]}/${scopeFields[1]}`;
        case "kvField":
          return `kvField/${scopeFields[0]}`;
        default:
          throw new Error(`Unknown scope type '${scopeType}' in labelForScope`);
      }
    };
    var nComponentsForScope = (scopeType) => {
      switch (scopeType) {
        case "orphanTokens":
        case "hangingGraft":
        case "table":
          return 1;
        case "blockTag":
        case "inline":
        case "chapter":
        case "verses":
        case "verse":
        case "span":
        case "milestone":
        case "spanWithAtts":
        case "pubChapter":
        case "altChapter":
        case "pubVerse":
        case "altVerse":
        case "esbCat":
        case "tTableRow":
        case "tTableCol":
        case "tTreeNode":
        case "tTreeParent":
        case "tTreeContent":
        case "kvPrimary":
        case "kvField":
          return 2;
        case "tTreeChild":
        case "kvSecondary":
          return 3;
        case "cell":
          return 4;
        case "attribute":
          return 6;
        default:
          throw new Error(`Unknown scope type '${scopeType}' in nComponentsForScope`);
      }
    };
    module.exports = {
      scopeEnum,
      scopeEnumLabels,
      labelForScope,
      nComponentsForScope
    };
  }
});

// node_modules/proskomma-core/src/util/itemDefs.cjs
var require_itemDefs = __commonJS({
  "node_modules/proskomma-core/src/util/itemDefs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var itemEnum = {
      token: 0,
      graft: 1,
      startScope: 2,
      endScope: 3
    };
    var itemEnumLabels = Object.entries(itemEnum).sort((a, b) => a[1] - b[1]).map((kv) => kv[0]);
    var itemArray2Object = (a) => ({
      type: a[0],
      subType: a[1],
      payload: a[2]
    });
    var itemObject2Array = (ob) => [
      ob.type,
      ob.subType,
      ob.payload
    ];
    var itemArrays2Objects = (aa) => aa.map((a) => itemArray2Object(a));
    var itemObjects2Arrays = (obs) => obs.map((ob) => itemObject2Array(ob));
    module.exports = {
      itemEnum,
      itemEnumLabels,
      itemArray2Object,
      itemObject2Array,
      itemArrays2Objects,
      itemObjects2Arrays
    };
  }
});

// node_modules/proskomma-core/src/util/succinct.cjs
var require_succinct = __commonJS({
  "node_modules/proskomma-core/src/util/succinct.cjs"(exports, module) {
    init_process();
    init_buffer();
    var tokenDefs = require_tokenDefs();
    var scopeDefs = require_scopeDefs();
    var itemDefs = require_itemDefs();
    var headerBytes = (succinct, pos) => {
      const headerByte = succinct.byte(pos);
      const itemType = headerByte >> 6;
      const itemLength = headerByte & 63;
      const itemSubtype = succinct.byte(pos + 1);
      return [itemLength, itemType, itemSubtype];
    };
    var succinctTokenChars = (enums, enumIndexes2, succinct, itemSubtype, pos) => {
      const itemCategory = tokenDefs.tokenCategory[tokenDefs.tokenEnumLabels[itemSubtype]];
      const itemIndex = enumIndexes2[itemCategory][succinct.nByte(pos + 2)];
      return enums[itemCategory].countedString(itemIndex);
    };
    var succinctScopeLabel = (enums, enumIndexes2, succinct, itemSubtype, pos) => {
      const scopeType = scopeDefs.scopeEnumLabels[itemSubtype];
      let nScopeBits = scopeDefs.nComponentsForScope(scopeType);
      let offset = 2;
      let scopeBits = "";
      while (nScopeBits > 1) {
        const itemIndexIndex = succinct.nByte(pos + offset);
        const itemIndex = enumIndexes2.scopeBits[itemIndexIndex];
        const scopeBitString = enums.scopeBits.countedString(itemIndex);
        scopeBits += `/${scopeBitString}`;
        offset += succinct.nByteLength(itemIndexIndex);
        nScopeBits--;
      }
      return `${scopeType}${scopeBits}`;
    };
    var succinctGraftName = (enums, enumIndexes2, itemSubtype) => {
      const graftIndex = enumIndexes2.graftTypes[itemSubtype];
      return enums.graftTypes.countedString(graftIndex);
    };
    var succinctGraftSeqId = (enums, enumIndexes2, succinct, pos) => {
      const seqIndex = enumIndexes2.ids[succinct.nByte(pos + 2)];
      return enums.ids.countedString(seqIndex);
    };
    var enumIndexes = (enums) => {
      const ret = {};
      for (const [category, succinct] of Object.entries(enums)) {
        ret[category] = enumIndex(category, succinct);
      }
      return ret;
    };
    var enumIndex = (category, enumSuccinct) => {
      const indexSuccinct = new Uint32Array(enumSuccinct.length);
      let pos = 0;
      let count = 0;
      while (pos < enumSuccinct.length) {
        indexSuccinct[count] = pos;
        const stringLength = enumSuccinct.byte(pos);
        pos += stringLength + 1;
        count += 1;
      }
      return indexSuccinct;
    };
    var unpackEnum = (succinct, includeIndex) => {
      if (!includeIndex) {
        includeIndex = false;
      }
      let pos = 0;
      let count = 0;
      const ret = [];
      while (pos < succinct.length) {
        const stringLength = succinct.byte(pos);
        const unpacked = succinct.countedString(pos);
        ret.push(includeIndex ? [count, unpacked] : unpacked);
        pos += stringLength + 1;
        count++;
      }
      return ret;
    };
    var undefinedArgError = (func, field) => {
      throw new Error(`Undefined or null argument '${field}' in '${func}'`);
    };
    var pushSuccinctTokenBytes = (bA, tokenEnumIndex, charsEnumIndex) => {
      if (tokenEnumIndex === void 0 || tokenEnumIndex === null) {
        undefinedArgError("pushSuccinctTokenBytes", "tokenEnumIndex");
      }
      if (charsEnumIndex === void 0 || charsEnumIndex === null) {
        undefinedArgError("pushSuccinctTokenBytes", "charsEnumIndex");
      }
      const lengthPos = bA.length;
      bA.pushByte(0);
      bA.pushByte(tokenEnumIndex);
      bA.pushNByte(charsEnumIndex);
      bA.setByte(lengthPos, bA.length - lengthPos | itemDefs.itemEnum.token << 6);
    };
    var pushSuccinctGraftBytes = (bA, graftTypeEnumIndex, seqEnumIndex) => {
      if (graftTypeEnumIndex === void 0 || graftTypeEnumIndex === null) {
        undefinedArgError("pushSuccinctGraftBytes", "graftTypeEnumIndex");
      }
      if (seqEnumIndex === void 0 || seqEnumIndex === null) {
        undefinedArgError("pushSuccinctGraftBytes", "seqEnumIndex");
      }
      const lengthPos = bA.length;
      bA.pushByte(0);
      bA.pushByte(graftTypeEnumIndex);
      bA.pushNByte(seqEnumIndex);
      bA.setByte(lengthPos, bA.length - lengthPos | itemDefs.itemEnum.graft << 6);
    };
    var pushSuccinctScopeBytes = (bA, itemTypeByte, scopeTypeByte, scopeBitBytes) => {
      if (itemTypeByte === void 0 || itemTypeByte === null) {
        undefinedArgError("pushSuccinctScopeBytes", "itemTypeByte");
      }
      if (scopeTypeByte === void 0 || scopeTypeByte === null) {
        undefinedArgError("pushSuccinctScopeBytes", "scopeTypeByte");
      }
      if (scopeBitBytes === void 0 || scopeBitBytes === null) {
        undefinedArgError("pushSuccinctScopeBytes", "scopeBitBytes");
      }
      const lengthPos = bA.length;
      bA.pushByte(0);
      bA.pushByte(scopeTypeByte);
      for (const sbb of scopeBitBytes) {
        bA.pushNByte(sbb);
      }
      bA.setByte(lengthPos, bA.length - lengthPos | itemTypeByte << 6);
    };
    module.exports = {
      enumIndex,
      enumIndexes,
      headerBytes,
      pushSuccinctTokenBytes,
      pushSuccinctGraftBytes,
      pushSuccinctScopeBytes,
      succinctTokenChars,
      succinctScopeLabel,
      succinctGraftName,
      succinctGraftSeqId,
      unpackEnum
    };
  }
});

// node_modules/proskomma-core/src/util/inspectSuccinct.cjs
var require_inspectSuccinct = __commonJS({
  "node_modules/proskomma-core/src/util/inspectSuccinct.cjs"(exports, module) {
    init_process();
    init_buffer();
    var ByteArray = require_byteArray();
    var succinct = require_succinct();
    var itemDefs = require_itemDefs();
    var tokenDefs = require_tokenDefs();
    var scopeDefs = require_scopeDefs();
    var inspectEnum = (enumString) => {
      const ba = new ByteArray();
      ba.fromBase64(enumString);
      const ret = [];
      ret.push(`* Char length ${ba.length} *`);
      for (const [count, text] of succinct.unpackEnum(ba, true)) {
        ret.push(`${count}	"${text}"`);
      }
      return ret.join("\n");
    };
    var inspectSuccinct = (succinctdoc, enumStrings) => {
      const ba = new ByteArray();
      ba.fromBase64(succinctdoc);
      const enums = {};
      for (const [category, enumString] of Object.entries(enumStrings)) {
        enums[category] = new ByteArray();
        enums[category].fromBase64(enumString);
      }
      const indexes = succinct.enumIndexes(enums);
      const ret = [];
      ret.push(`* Char length ${ba.length} *`);
      let pos = 0;
      while (pos < ba.length) {
        const [itemLength, itemType, itemSubtype] = succinct.headerBytes(ba, pos);
        let subtypeLabel = itemSubtype;
        let extra = "";
        switch (itemDefs.itemEnumLabels[itemType]) {
          case "token":
            subtypeLabel = tokenDefs.tokenEnumLabels[itemSubtype];
            extra = `"${succinct.succinctTokenChars(enums, indexes, ba, itemSubtype, pos)}"`;
            break;
          case "startScope":
          case "endScope":
            subtypeLabel = scopeDefs.scopeEnumLabels[itemSubtype];
            extra = succinct.succinctScopeLabel(enums, indexes, ba, itemSubtype, pos);
            break;
          case "graft":
            subtypeLabel = succinct.succinctGraftName(enums, indexes, itemSubtype);
            extra = succinct.succinctGraftSeqId(enums, indexes, ba, pos);
        }
        ret.push(`${itemDefs.itemEnumLabels[itemType]}	${subtypeLabel}	(${itemLength})	${extra}`);
        pos += itemLength;
      }
      return ret.join("\n");
    };
    module.exports = { inspectEnum, inspectSuccinct };
  }
});

// node_modules/proskomma-core/src/util/parserConstantDefs.cjs
var require_parserConstantDefs = __commonJS({
  "node_modules/proskomma-core/src/util/parserConstantDefs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = {
      usfm: {
        baseSequenceTypes: {
          main: "1",
          introduction: "*",
          introTitle: "?",
          introEndTitle: "?",
          title: "?",
          endTitle: "?",
          heading: "*",
          header: "*",
          remark: "*",
          sidebar: "*",
          table: "*",
          tree: "*",
          kv: "*"
        },
        inlineSequenceTypes: {
          footnote: "*",
          noteCaller: "*",
          xref: "*",
          pubNumber: "*",
          altNumber: "*",
          esbCat: "*",
          fig: "*",
          temp: "?"
        }
      }
    };
  }
});

// node_modules/proskomma-core/src/util/tags.cjs
var require_tags = __commonJS({
  "node_modules/proskomma-core/src/util/tags.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var validateTags = (tags) => {
      for (const tag of tags) {
        validateTag(tag);
      }
    };
    var validateTag = (tag) => {
      if (!xre.exec(tag, /^[a-z][A-za-z0-9]*(:.+)?$/)) {
        throw new Error(`Tag '${tag}' is not valid (should be [a-z][A-za-z0-9]*(:.+)?)`);
      }
    };
    var addTag = (tags, tag) => {
      validateTag(tag);
      tags.add(tag);
    };
    var removeTag = (tags, tag) => {
      validateTag(tag);
      tags.delete(tag);
    };
    module.exports = {
      validateTags,
      validateTag,
      addTag,
      removeTag
    };
  }
});

// node_modules/proskomma-core/src/util/versification.cjs
var require_versification = __commonJS({
  "node_modules/proskomma-core/src/util/versification.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var ByteArray = require_byteArray();
    var cvMappingType = 2;
    var bcvMappingType = 3;
    var bookCodes = [
      // From Paratext via Scripture Burrito
      "GEN",
      "EXO",
      "LEV",
      "NUM",
      "DEU",
      "JOS",
      "JDG",
      "RUT",
      "1SA",
      "2SA",
      "1KI",
      "2KI",
      "1CH",
      "2CH",
      "EZR",
      "NEH",
      "EST",
      "JOB",
      "PSA",
      "PRO",
      "ECC",
      "SNG",
      "ISA",
      "JER",
      "LAM",
      "EZK",
      "DAN",
      "HOS",
      "JOL",
      "AMO",
      "OBA",
      "JON",
      "MIC",
      "NAM",
      "HAB",
      "ZEP",
      "HAG",
      "ZEC",
      "MAL",
      "MAT",
      "MRK",
      "LUK",
      "JHN",
      "ACT",
      "ROM",
      "1CO",
      "2CO",
      "GAL",
      "EPH",
      "PHP",
      "COL",
      "1TH",
      "2TH",
      "1TI",
      "2TI",
      "TIT",
      "PHM",
      "HEB",
      "JAS",
      "1PE",
      "2PE",
      "1JN",
      "2JN",
      "3JN",
      "JUD",
      "REV",
      "TOB",
      "JDT",
      "ESG",
      "WIS",
      "SIR",
      "BAR",
      "LJE",
      "S3Y",
      "SUS",
      "BEL",
      "1MA",
      "2MA",
      "3MA",
      "4MA",
      "1ES",
      "2ES",
      "MAN",
      "PS2",
      "ODA",
      "PSS",
      "JSA",
      "JDB",
      "TBS",
      "SST",
      "DNT",
      "BLT",
      "EZA",
      "5EZ",
      "6EZ",
      "DAG",
      "PS3",
      "2BA",
      "LBA",
      "JUB",
      "ENO",
      "1MQ",
      "2MQ",
      "3MQ",
      "REP",
      "4BA",
      "LAO"
    ];
    var bookCodeIndex = () => {
      const ret = {};
      for (const [bookN, book] of Object.entries(bookCodes)) {
        ret[book] = parseInt(bookN);
      }
      return ret;
    };
    var vrs2json = (vrsString) => {
      const ret = {};
      for (const vrsLineBits of vrsString.split(/[\n\r]+/).map((l) => l.trim()).map((l) => xre.exec(l, xre("^([A-Z1-6]{3} [0-9]+:[0-9]+(-[0-9]+)?) = ([A-Z1-6]{3} [0-9]+:[0-9]+[a-z]?(-[0-9]+)?)$")))) {
        if (!vrsLineBits) {
          continue;
        }
        if (!(vrsLineBits[1] in ret)) {
          ret[vrsLineBits[1]] = [];
        }
        ret[vrsLineBits[1]].push(vrsLineBits[3]);
      }
      return { mappedVerses: ret };
    };
    var reverseVersification = (vrsJson) => {
      const ret = {};
      for (const [fromSpec, toSpecs] of Object.entries(vrsJson.mappedVerses)) {
        for (const toSpec of toSpecs) {
          if (toSpec in ret) {
            ret[toSpec].push(fromSpec);
          } else {
            ret[toSpec] = [fromSpec];
          }
        }
      }
      return { reverseMappedVerses: ret };
    };
    var preSuccinctVerseMapping = (mappingJson) => {
      const ret = {};
      for (let [fromSpec, toSpecs] of Object.entries(mappingJson)) {
        if (typeof toSpecs === "string") {
          toSpecs = [toSpecs];
        }
        const [fromBook, fromCVV] = fromSpec.split(" ");
        const toBook = toSpecs[0].split(" ")[0];
        const record = toBook === fromBook ? ["cv"] : ["bcv"];
        let [fromCh, fromV] = fromCVV.split(":");
        let toV = fromV;
        if (fromV.includes("-")) {
          const vBits = fromV.split("-");
          fromV = vBits[0];
          toV = vBits[1];
        }
        record.push([parseInt(fromV), parseInt(toV)]);
        record.push([]);
        for (const toCVV of toSpecs.map((ts) => ts.split(" ")[1])) {
          let [toCh, fromV2] = toCVV.split(":");
          let toV2 = fromV2;
          if (fromV2.includes("-")) {
            const vBits = fromV2.split("-");
            fromV2 = vBits[0];
            toV2 = vBits[1];
          }
          if (record[0] === "cv") {
            record[2].push([parseInt(toCh), parseInt(fromV2), parseInt(toV2)]);
          } else {
            record[2].push([parseInt(toCh), parseInt(fromV2), parseInt(toV2), toBook]);
          }
        }
        if (!(fromBook in ret)) {
          ret[fromBook] = {};
        }
        if (!(fromCh in ret[fromBook])) {
          ret[fromBook][fromCh] = [];
        }
        ret[fromBook][fromCh].push(record);
      }
      return ret;
    };
    var succinctifyVerseMappings = (preSuccinct) => {
      const ret = {};
      const bci = bookCodeIndex();
      for (const [book, chapters] of Object.entries(preSuccinctVerseMapping(preSuccinct))) {
        ret[book] = {};
        for (const [chapter, mappings] of Object.entries(chapters)) {
          ret[book][chapter] = succinctifyVerseMapping(mappings, bci);
        }
      }
      return ret;
    };
    var succinctifyVerseMapping = (preSuccinctBC, bci) => {
      const makeMappingLengthByte = (recordType, length) => length + recordType * 64;
      const ret = new ByteArray(64);
      for (const [recordTypeStr, [fromVerseStart, fromVerseEnd], mappings] of preSuccinctBC) {
        const pos = ret.length;
        const recordType = recordTypeStr === "bcv" ? bcvMappingType : cvMappingType;
        ret.pushNBytes([0, fromVerseStart, fromVerseEnd]);
        if (recordType === bcvMappingType) {
          const bookIndex = bci[mappings[0][3]];
          ret.pushNByte(bookIndex);
        }
        ret.pushNByte(mappings.length);
        for (const [ch, fromV] of mappings) {
          ret.pushNBytes([ch, fromV]);
        }
        const recordLength = ret.length - pos;
        if (recordLength > 63) {
          throw new Error(`Mapping in succinctifyVerseMapping ${JSON.stringify(mappings)} is too long (${recordLength} bytes)`);
        }
        ret.setByte(pos, makeMappingLengthByte(recordType, recordLength));
      }
      ret.trim();
      return ret;
    };
    var mappingLengthByte = (succinct, pos) => {
      const sByte = succinct.byte(pos);
      return [
        sByte >> 6,
        sByte % 64
      ];
    };
    var unsuccinctifyVerseMapping = (succinctBC, fromBookCode, bci) => {
      const ret = [];
      let pos = 0;
      while (pos < succinctBC.length) {
        let recordPos = pos;
        const unsuccinctRecord = {};
        const [recordType, recordLength] = mappingLengthByte(succinctBC, pos);
        recordPos++;
        unsuccinctRecord.fromVerseStart = succinctBC.nByte(recordPos);
        recordPos += succinctBC.nByteLength(unsuccinctRecord.fromVerseStart);
        unsuccinctRecord.fromVerseEnd = succinctBC.nByte(recordPos);
        recordPos += succinctBC.nByteLength(unsuccinctRecord.fromVerseEnd);
        unsuccinctRecord.bookCode = fromBookCode;
        if (recordType === bcvMappingType) {
          const bookIndex = succinctBC.nByte(recordPos);
          unsuccinctRecord.bookCode = bookCodes[bookIndex];
          recordPos += succinctBC.nByteLength(bookIndex);
        }
        const nMappings = succinctBC.nByte(recordPos);
        recordPos += succinctBC.nByteLength(nMappings);
        const mappings = [];
        while (mappings.length < nMappings) {
          const mapping = {};
          mapping.ch = succinctBC.nByte(recordPos);
          recordPos += succinctBC.nByteLength(mapping.ch);
          mapping.verseStart = succinctBC.nByte(recordPos);
          recordPos += succinctBC.nByteLength(mapping.verseStart);
          mappings.push(mapping);
        }
        unsuccinctRecord.mapping = mappings;
        ret.push(unsuccinctRecord);
        pos += recordLength;
      }
      return ret;
    };
    var mapVerse = (succinct, b, c, v) => {
      let ret = null;
      let pos = 0;
      while (pos < succinct.length) {
        let recordPos = pos;
        const [recordType, recordLength] = mappingLengthByte(succinct, pos);
        recordPos++;
        const fromVerseStart = succinct.nByte(recordPos);
        recordPos += succinct.nByteLength(fromVerseStart);
        const fromVerseEnd = succinct.nByte(recordPos);
        recordPos += succinct.nByteLength(fromVerseEnd);
        if (v < fromVerseStart || v > fromVerseEnd) {
          pos += recordLength;
          continue;
        }
        let bookCode = b;
        if (recordType === bcvMappingType) {
          const bookIndex = succinct.nByte(recordPos);
          bookCode = bookCodes[bookIndex];
          recordPos += succinct.nByteLength(bookIndex);
        }
        ret = [bookCode, []];
        const nMappings = succinct.nByte(recordPos);
        recordPos += succinct.nByteLength(nMappings);
        while (ret[1].length < nMappings) {
          const ch = succinct.nByte(recordPos);
          recordPos += succinct.nByteLength(ch);
          const verseStart = succinct.nByte(recordPos);
          recordPos += succinct.nByteLength(verseStart);
          ret[1].push([ch, v - fromVerseStart + verseStart]);
        }
        break;
      }
      return ret || [b, [[c, v]]];
    };
    module.exports = {
      vrs2json,
      reverseVersification,
      preSuccinctVerseMapping,
      bookCodes,
      succinctifyVerseMapping,
      succinctifyVerseMappings,
      unsuccinctifyVerseMapping,
      bookCodeIndex,
      mapVerse
    };
  }
});

// node_modules/proskomma-core/src/util/index.cjs
var require_util = __commonJS({
  "node_modules/proskomma-core/src/util/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var ByteArray = require_byteArray();
    var canons = require_canons();
    var enums = require_enums();
    var { generateId } = require_generateId();
    var graftDefs = require_graftDefs();
    var inspect4 = require_inspectSuccinct();
    var itemDefs = require_itemDefs();
    var parserConstants = require_parserConstantDefs();
    var scopeDefs = require_scopeDefs();
    var succinct = require_succinct();
    var tags = require_tags();
    var tokenDefs = require_tokenDefs();
    var versification = require_versification();
    module.exports = {
      ByteArray,
      canons,
      enums,
      generateId,
      graftDefs,
      inspect: inspect4,
      itemDefs,
      parserConstants,
      scopeDefs,
      succinct,
      tags,
      tokenDefs,
      versification
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/selectors.cjs
var require_selectors = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/selectors.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var validateSelectors = (docSet, selectors) => {
      if (typeof selectors !== "object") {
        throw new Error(`DocSet constructor expects selectors to be object, found ${typeof docSet.selectors}`);
      }
      const expectedSelectors = {};
      for (const selector of docSet.processor.selectors) {
        expectedSelectors[selector.name] = selector;
      }
      for (const [name, value] of Object.entries(selectors)) {
        if (!(name in expectedSelectors)) {
          throw new Error(`Unexpected selector '${name}' (expected one of [${Object.keys(expectedSelectors).join(", ")}])`);
        }
        if (typeof value === "string" && expectedSelectors[name].type !== "string" || typeof value === "number" && expectedSelectors[name].type !== "integer") {
          throw new Error(`Selector '${name}' is of type ${typeof value} (expected ${expectedSelectors[name].type})`);
        }
        if (typeof value === "number") {
          if (!Number.isInteger(value)) {
            throw new Error(`Value '${value}' of integer selector '${name}' is not an integer`);
          }
          if ("min" in expectedSelectors[name] && value < expectedSelectors[name].min) {
            throw new Error(`Value '${value}' is less than ${expectedSelectors[name].min}`);
          }
          if ("max" in expectedSelectors[name] && value > expectedSelectors[name].max) {
            throw new Error(`Value '${value}' is greater than ${expectedSelectors[name].max}`);
          }
        } else {
          if ("regex" in expectedSelectors[name] && !xre.exec(value, xre(expectedSelectors[name].regex), 0)) {
            throw new Error(`Value '${value}' does not match regex '${expectedSelectors[name].regex}'`);
          }
        }
        if ("enum" in expectedSelectors[name] && !expectedSelectors[name].enum.includes(value)) {
          throw new Error(`Value '${value}' of selector '${name}' is not in enum`);
        }
      }
      for (const name of Object.keys(expectedSelectors)) {
        if (!(name in selectors)) {
          throw new Error(`Expected selector '${name}' not found`);
        }
      }
      return selectors;
    };
    module.exports = { validateSelectors };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/block.cjs
var require_block = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/block.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var utils = require_util();
    var blocksWithScriptureCV = (docSet, blocks, cv) => {
      const hasMiddleChapter = (b, fromC, toC) => {
        const blockChapterScopes = [
          ...docSet.unsuccinctifyScopes(b.os).map((s) => s[2]),
          ...docSet.unsuccinctifyScopes(b.is).map((s) => s[2])
        ].filter((s) => s.startsWith("chapter/"));
        return blockChapterScopes.map((s) => parseInt(s.split("/")[1])).filter((n) => n > fromC && n < toC).length > 0;
      };
      const hasFirstChapter = (b, fromC, fromV) => {
        const hasFirstChapterScope = [
          ...docSet.unsuccinctifyScopes(b.os).map((s) => s[2]),
          ...docSet.unsuccinctifyScopes(b.is).map((s) => s[2])
        ].includes(`chapter/${fromC}`);
        return hasFirstChapterScope && docSet.blockHasMatchingItem(
          b,
          (item, openScopes) => {
            if (!openScopes.has(`chapter/${fromC}`)) {
              return false;
            }
            return Array.from(openScopes).filter((s) => s.startsWith("verse/")).filter((s) => parseInt(s.split("/")[1]) >= fromV).length > 0 || fromV === 0 && item[0] === "token" && item[2] && Array.from(openScopes).filter((s) => s.startsWith("verse")).length === 0;
          },
          {}
        );
      };
      const hasLastChapter = (b, toC, toV) => {
        const hasLastChapterScope = [
          ...docSet.unsuccinctifyScopes(b.os).map((s) => s[2]),
          ...docSet.unsuccinctifyScopes(b.is).map((s) => s[2])
        ].includes(`chapter/${toC}`);
        return hasLastChapterScope && docSet.blockHasMatchingItem(
          b,
          (item, openScopes) => {
            if (!openScopes.has(`chapter/${toC}`)) {
              return false;
            }
            return Array.from(openScopes).filter((s) => s.startsWith("verse/")).filter((s) => parseInt(s.split("/")[1]) <= toV).length > 0 || toV === 0 && item[0] === "token" && item[2] && Array.from(openScopes).filter((s) => s.startsWith("verse")).length === 0;
          },
          {}
        );
      };
      if (xre.exec(cv, xre("^[1-9][0-9]*$"))) {
        const scopes = [`chapter/${cv}`];
        return blocks.filter((b) => docSet.allScopesInBlock(b, scopes));
      } else if (xre.exec(cv, xre("^[1-9][0-9]*-[1-9][0-9]*$"))) {
        const [fromC, toC] = cv.split("-").map((v) => parseInt(v));
        if (fromC > toC) {
          throw new Error(`Chapter range must be from min to max, not '${cv}'`);
        }
        const scopes = [...Array(toC - fromC + 1).keys()].map((n) => `chapter/${n + fromC}`);
        return blocks.filter((b) => docSet.anyScopeInBlock(b, scopes));
      } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+$"))) {
        const [fromC, fromV] = cv.split(":").map((v) => parseInt(v));
        if (fromV === 0) {
          const scopes = [`chapter/${fromC}`];
          return blocks.filter((b) => docSet.allScopesInBlock(b, scopes)).filter(
            (b) => [...docSet.allBlockScopes(b)].filter((s) => s.startsWith("verse")).length === 0
          );
        } else {
          const scopes = [`chapter/${fromC}`, `verse/${fromV}`];
          return blocks.filter((b) => docSet.allScopesInBlock(b, scopes));
        }
      } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+-[1-9][0-9]*$"))) {
        const [fromC, vs] = cv.split(":");
        const [fromV, toV] = vs.split("-").map((v) => parseInt(v));
        if (fromV > toV) {
          throw new Error(`Verse range must be from min to max, not '${vs}'`);
        }
        const chapterScopes = [`chapter/${fromC}`];
        const verseScopes = [...Array(toV - fromV + 1).keys()].map((n) => `verse/${n + fromV}`);
        return blocks.filter((b) => docSet.allScopesInBlock(b, chapterScopes)).filter(
          (b) => docSet.anyScopeInBlock(b, verseScopes) || fromV === 0 && [...docSet.allBlockScopes(b)].filter((s) => s.startsWith("verse")).length === 0
        );
      } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+-[1-9][0-9]*:[0-9]+$"))) {
        const [fromCV, toCV] = cv.split("-");
        const [fromC, fromV] = fromCV.split(":").map((c) => parseInt(c));
        const [toC, toV] = toCV.split(":").map((v) => parseInt(v));
        if (fromC > toC) {
          throw new Error(`Chapter range must be from min to max, not '${fromC}-${toV}'`);
        }
        const chapterScopes = [...Array(toC - fromC + 1).keys()].map((n) => `chapter/${n + fromC}`);
        const chapterBlocks = blocks.filter((b) => docSet.anyScopeInBlock(b, chapterScopes));
        return chapterBlocks.filter((b) => hasMiddleChapter(b, fromC, toC) || hasFirstChapter(b, fromC, fromV) || hasLastChapter(b, toC, toV));
      } else {
        throw new Error(`Bad cv reference '${cv}'`);
      }
    };
    var allBlockScopes = (docSet, block2) => {
      const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bs, 0);
      const blockScope = docSet.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0);
      return /* @__PURE__ */ new Set(
        [
          ...docSet.unsuccinctifyScopes(block2.os).map((s) => s[2]),
          ...docSet.unsuccinctifyScopes(block2.is).map((s) => s[2]),
          blockScope[2]
        ]
      );
    };
    var allScopesInBlock = (docSet, block2, scopes) => {
      const allBlockScopes2 = docSet.allBlockScopes(block2);
      for (const scope of scopes) {
        if (!allBlockScopes2.has(scope)) {
          return false;
        }
      }
      return true;
    };
    var anyScopeInBlock = (docSet, block2, scopes) => {
      const allBlockScopes2 = docSet.allBlockScopes(block2);
      for (const scope of scopes) {
        if (allBlockScopes2.has(scope)) {
          return true;
        }
      }
      return false;
    };
    var blockHasBlockScope = (docSet, block2, scope) => {
      const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bs, 0);
      const blockScope = docSet.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0);
      return blockScope[2] === scope;
    };
    var blockHasChars = (docSet, block2, charsIndexes) => {
      let ret = false;
      let pos = 0;
      const succinct = block2.c;
      if (charsIndexes.includes(-1)) {
        return false;
      }
      while (!ret && pos < succinct.length) {
        const [itemLength, itemType] = utils.succinct.headerBytes(succinct, pos);
        if (itemType === utils.itemDefs.itemEnum["token"]) {
          if (charsIndexes.includes(succinct.nByte(pos + 2))) {
            ret = true;
          }
        }
        pos += itemLength;
      }
      return ret;
    };
    var blockHasMatchingItem = (docSet, block2, testFunction, options) => {
      const openScopes = new Set(docSet.unsuccinctifyScopes(block2.os).map((ri) => ri[2]));
      for (const item of docSet.unsuccinctifyItems(block2.c, options, 0)) {
        if (item[0] === "scope" && item[1] === "start") {
          openScopes.add(item[2]);
        }
        if (testFunction(item, openScopes)) {
          return true;
        }
        if (item[0] === "scope" && item[1] === "end") {
          openScopes.delete(item[2]);
        }
      }
      return false;
    };
    module.exports = {
      blocksWithScriptureCV,
      allBlockScopes,
      anyScopeInBlock,
      allScopesInBlock,
      blockHasBlockScope,
      blockHasChars,
      blockHasMatchingItem
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/unsuccinctify.cjs
var require_unsuccinctify = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/unsuccinctify.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var utils = require_util();
    var unsuccinctifyBlock = (docSet, block2, options) => {
      docSet.maybeBuildEnumIndexes();
      const succinctBlockScope = block2.bs;
      const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(succinctBlockScope, 0);
      const blockScope = docSet.unsuccinctifyScope(succinctBlockScope, itemType, itemSubtype, 0);
      const blockGrafts = docSet.unsuccinctifyGrafts(block2.bg);
      const openScopes = docSet.unsuccinctifyScopes(block2.os);
      const includedScopes = docSet.unsuccinctifyScopes(block2.is);
      const nextToken = block2.nt.nByte(0);
      const blockItems = docSet.unsuccinctifyItems(block2.c, options || {}, nextToken);
      return {
        bs: blockScope,
        bg: blockGrafts,
        c: blockItems,
        os: openScopes,
        is: includedScopes,
        nt: nextToken
      };
    };
    var unsuccinctifyItems = (docSet, succinct, options, nextToken, openScopes) => {
      if (nextToken === void 0) {
        throw new Error("nextToken (previously includeContext) must now be provided to unsuccinctifyItems");
      }
      if (nextToken !== null && typeof nextToken !== "number") {
        throw new Error(`nextToken (previously includeContext) must be null or an integer, not ${typeof nextToken} '${JSON.stringify(nextToken)}' in unsuccinctifyItems`);
      }
      const ret = [];
      let pos = 0;
      let tokenCount = nextToken || 0;
      const scopes = new Set(openScopes || []);
      while (pos < succinct.length) {
        const [item, itemLength] = docSet.unsuccinctifyItem(succinct, pos, {});
        if (item[0] === "token") {
          if (Object.keys(options).length === 0 || options.tokens) {
            if (nextToken !== null) {
              item.push(item[0] === "token" && item[1] === "wordLike" ? tokenCount++ : null);
              item.push([...scopes]);
            }
            ret.push(item);
          }
        } else if (item[0] === "scope" && item[1] === "start") {
          scopes.add(item[2]);
          if (Object.keys(options).length === 0 || options.scopes) {
            ret.push(item);
          }
        } else if (item[0] === "scope" && item[1] === "end") {
          scopes.delete(item[2]);
          if (Object.keys(options).length === 0 || options.scopes) {
            ret.push(item);
          }
        } else if (item[0] === "graft") {
          if (Object.keys(options).length === 0 || options.grafts) {
            ret.push(item);
          }
        }
        pos += itemLength;
      }
      return ret;
    };
    var unsuccinctifyItem = (docSet, succinct, pos, options) => {
      let item = null;
      const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(succinct, pos);
      switch (itemType) {
        case utils.itemDefs.itemEnum.token:
          if (Object.keys(options).length === 0 || options.tokens) {
            item = docSet.unsuccinctifyToken(succinct, itemSubtype, pos);
          }
          break;
        case utils.itemDefs.itemEnum.startScope:
        case utils.itemDefs.itemEnum.endScope:
          if (Object.keys(options).length === 0 || options.scopes) {
            item = docSet.unsuccinctifyScope(succinct, itemType, itemSubtype, pos);
          }
          break;
        case utils.itemDefs.itemEnum.graft:
          if (Object.keys(options).length === 0 || options.grafts) {
            item = docSet.unsuccinctifyGraft(succinct, itemSubtype, pos);
          }
          break;
      }
      return [item, itemLength];
    };
    var unsuccinctifyPrunedItems = (docSet, block2, options) => {
      const openScopes = new Set(docSet.unsuccinctifyScopes(block2.os).map((ri) => ri[2]));
      const requiredScopes = options.requiredScopes || [];
      const anyScope = options.anyScope || false;
      const allScopesInItem = () => {
        for (const scope of requiredScopes) {
          if (!openScopes.has(scope)) {
            return false;
          }
        }
        return true;
      };
      const anyScopeInItem = () => {
        for (const scope of requiredScopes) {
          if (openScopes.has(scope)) {
            return true;
          }
        }
        return requiredScopes.length === 0;
      };
      const scopeTest = anyScope ? anyScopeInItem : allScopesInItem;
      const charsTest = (item) => !options.withChars || options.withChars.length === 0 || item[0] === "token" && options.withChars.includes(item[2]);
      const ret = [];
      for (const item of docSet.unsuccinctifyItems(block2.c, options, block2.nt.nByte(0), openScopes)) {
        if (item[0] === "scope" && item[1] === "start") {
          openScopes.add(item[2]);
        }
        if (scopeTest() && charsTest(item)) {
          ret.push(item);
        }
        if (item[0] === "scope" && item[1] === "end") {
          openScopes.delete(item[2]);
        }
      }
      return ret;
    };
    var unsuccinctifyItemsWithScriptureCV = (docSet, block2, cv, options) => {
      options = options || {};
      const openScopes = new Set(docSet.unsuccinctifyScopes(block2.os).map((ri) => ri[2]));
      const cvMatchFunction = () => {
        if (xre.exec(cv, xre("^[1-9][0-9]*$"))) {
          return () => openScopes.has(`chapter/${cv}`);
        } else if (xre.exec(cv, xre("^[1-9][0-9]*-[1-9][0-9]*$"))) {
          return () => {
            const [fromC, toC] = cv.split("-").map((v) => parseInt(v));
            if (fromC > toC) {
              throw new Error(`Chapter range must be from min to max, not '${cv}'`);
            }
            for (const scope of [...Array(toC - fromC + 1).keys()].map((n) => `chapter/${n + fromC}`)) {
              if (openScopes.has(scope)) {
                return true;
              }
            }
            return false;
          };
        } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+$"))) {
          return () => {
            const [fromC, fromV] = cv.split(":").map((v) => parseInt(v));
            if (fromV === 0) {
              return openScopes.has(`chapter/${fromC}`) && [...openScopes].filter((s) => s.startsWith("verse")).length === 0;
            } else {
              for (const scope of [`chapter/${fromC}`, `verse/${fromV}`]) {
                if (!openScopes.has(scope)) {
                  return false;
                }
              }
              return true;
            }
          };
        } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+-[1-9][0-9]*$"))) {
          return () => {
            const [fromC, vs] = cv.split(":");
            const [fromV, toV] = vs.split("-").map((v) => parseInt(v));
            if (fromV > toV) {
              throw new Error(`Verse range must be from min to max, not '${vs}'`);
            }
            const chapterScope = `chapter/${fromC}`;
            const verseScopes = [...Array(toV - fromV + 1).keys()].map((n) => `verse/${n + fromV}`);
            if (!openScopes.has(chapterScope)) {
              return false;
            }
            for (const scope of verseScopes) {
              if (openScopes.has(scope)) {
                return true;
              }
            }
            return fromV === 0 && [...openScopes].filter((s) => s.startsWith("verse")).length === 0;
          };
        } else if (xre.exec(cv, xre("^[1-9][0-9]*:[0-9]+-[1-9][0-9]*:[0-9]+$"))) {
          return () => {
            const [fromCV, toCV] = cv.split("-");
            const [fromC, fromV] = fromCV.split(":").map((c) => parseInt(c));
            const [toC, toV] = toCV.split(":").map((v) => parseInt(v));
            if (fromC > toC) {
              throw new Error(`Chapter range must be from min to max, not '${fromC}-${toV}'`);
            }
            const scopeArray = [...openScopes];
            const chapterScopes = scopeArray.filter((s) => s.startsWith("chapter/"));
            if (chapterScopes.length > 1) {
              throw new Error(`Expected zero or one chapter for item, found ${chapterScopes.length}`);
            }
            const chapterNo = parseInt(chapterScopes[0].split("/")[1]);
            if (chapterNo < fromC || chapterNo > toC) {
              return false;
            } else if (chapterNo === fromC) {
              return scopeArray.filter(
                (s) => s.startsWith("verse/") && parseInt(s.split("/")[1]) >= fromV
              ).length > 0 || fromV === 0 && scopeArray.filter((s) => s.startsWith("verse")).length === 0;
            } else if (chapterNo === toC) {
              return scopeArray.filter(
                (s) => s.startsWith("verse/") && parseInt(s.split("/")[1]) <= toV
              ).length > 0 || toV === 0 && scopeArray.filter((s) => s.startsWith("verse")).length === 0;
            } else {
              return true;
            }
          };
        } else {
          throw new Error(`Bad cv reference '${cv}'`);
        }
      };
      const itemMatchesCV = cvMatchFunction();
      const itemInOptions = (item) => {
        if (!options || Object.keys(options).length === 0) {
          return true;
        } else {
          const itemType = item[0];
          return itemType === "token" && "tokens" in options || itemType === "graft" && "grafts" in options || itemType === "scope" && "scopes" in options;
        }
      };
      const ret = [];
      for (const item of docSet.unsuccinctifyItems(block2.c, {}, block2.nt.nByte(0))) {
        if (item[0] === "scope" && item[1] === "start") {
          openScopes.add(item[2]);
        }
        if (itemMatchesCV() && itemInOptions(item)) {
          ret.push(item);
        }
        if (item[0] === "scope" && item[1] === "end") {
          openScopes.delete(item[2]);
        }
      }
      return ret;
    };
    module.exports = {
      unsuccinctifyBlock,
      unsuccinctifyItem,
      unsuccinctifyItems,
      unsuccinctifyItemsWithScriptureCV,
      unsuccinctifyPrunedItems
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/enum.cjs
var require_enum2 = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/enum.cjs"(exports, module) {
    init_process();
    init_buffer();
    var buildPreEnum = (docSet, succinct) => {
      const ret = /* @__PURE__ */ new Map();
      let pos = 0;
      let enumCount = 0;
      while (pos < succinct.length) {
        ret.set(
          succinct.countedString(pos),
          {
            "enum": enumCount++,
            "frequency": 0
          }
        );
        pos += succinct.byte(pos) + 1;
      }
      return ret;
    };
    var recordPreEnum = (docSet, category, value) => {
      if (!(category in docSet.preEnums)) {
        throw new Error(`Unknown category ${category} in recordPreEnum. Maybe call buildPreEnums()?`);
      }
      if (value.length > 255) {
        console.log("Value length of", value.length, "in recordPreEnum");
      }
      if (!docSet.preEnums[category].has(value)) {
        docSet.preEnums[category].set(
          value,
          {
            "enum": docSet.preEnums[category].size,
            "frequency": 1
          }
        );
      } else {
        docSet.preEnums[category].get(value).frequency++;
      }
    };
    var buildEnum = (docSet, category, preEnumOb) => {
      const sortedPreEnums = new Map([...preEnumOb.entries()]);
      for (const enumText of sortedPreEnums.keys()) {
        if (enumText.length > 255) {
          console.log("enum text for", category, "has length", enumText.length, "in buildEnum - truncating");
        }
        docSet.enums[category].pushCountedString(enumText.substring(0, 255));
      }
      docSet.enums[category].trim();
    };
    var enumForCategoryValue = (docSet, category, value, addUnknown) => {
      if (!addUnknown) {
        addUnknown = false;
      }
      if (!(category in docSet.preEnums)) {
        throw new Error(`Unknown category ${category} in preEnums. Maybe call buildPreEnums()?`);
      }
      if (docSet.preEnums[category].has(value)) {
        return docSet.preEnums[category].get(value).enum;
      } else if (addUnknown) {
        docSet.preEnums[category].set(
          value,
          {
            "enum": docSet.preEnums[category].size,
            "frequency": 1
          }
        );
        docSet.enums[category].pushCountedString(value);
        docSet.buildEnumIndex(category);
        return docSet.preEnums[category].get(value).enum;
      } else {
        throw new Error(`Unknown value '${value}' for category ${category} in enumForCategoryValue. Maybe call buildPreEnums()?`);
      }
    };
    module.exports = {
      buildPreEnum,
      recordPreEnum,
      buildEnum,
      enumForCategoryValue
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/item.cjs
var require_item = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/item.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var countItems = (docSet, succinct) => {
      let count = 0;
      let pos = 0;
      while (pos < succinct.length) {
        count++;
        const headerByte = succinct.byte(pos);
        const itemLength = headerByte & 63;
        pos += itemLength;
      }
      return count;
    };
    var itemsByIndex = (docSet, mainSequence, index, includeContext) => {
      let ret = [];
      if (!index) {
        return ret;
      }
      let currentBlock = index.startBlock;
      let nextToken = index.nextToken;
      while (currentBlock <= index.endBlock) {
        let blockItems = docSet.unsuccinctifyItems(mainSequence.blocks[currentBlock].c, {}, nextToken);
        const blockScope = docSet.unsuccinctifyScopes(mainSequence.blocks[currentBlock].bs)[0];
        const blockGrafts = docSet.unsuccinctifyGrafts(mainSequence.blocks[currentBlock].bg);
        if (currentBlock === index.startBlock && currentBlock === index.endBlock) {
          blockItems = blockItems.slice(index.startItem, index.endItem + 1);
        } else if (currentBlock === index.startBlock) {
          blockItems = blockItems.slice(index.startItem);
        } else if (currentBlock === index.endBlock) {
          blockItems = blockItems.slice(0, index.endItem + 1);
        }
        if (includeContext) {
          let extendedBlockItems = [];
          for (const bi of blockItems) {
            extendedBlockItems.push(bi.concat([bi[0] === "token" && bi[1] === "wordLike" ? nextToken++ : null]));
          }
          blockItems = extendedBlockItems;
        }
        ret.push([...blockGrafts, ["scope", "start", blockScope[2]], ...blockItems, ["scope", "end", blockScope[2]]]);
        currentBlock++;
      }
      return ret;
    };
    var sequenceItemsByScopes = (docSet, blocks, byScopes) => {
      let allBlockScopes = [];
      const allScopesPresent = () => {
        for (const requiredScope of byScopes) {
          if (!matchingScope(requiredScope)) {
            return false;
          }
        }
        return true;
      };
      const matchingScope = (scopeToMatch) => {
        for (const blockScope of allBlockScopes) {
          if (blockScope.startsWith(scopeToMatch)) {
            return blockScope;
          }
        }
        return null;
      };
      docSet.maybeBuildEnumIndexes();
      const ret = [];
      let waitingScopes = /* @__PURE__ */ new Set([]);
      let scopeMatchEnded = true;
      for (const [blockN, block2] of blocks.entries()) {
        const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bs, 0);
        const blockScope = docSet.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0)[2];
        const startBlockScope = ["scope", "start", blockScope];
        const endBlockScope = ["scope", "end", blockScope];
        const blockGrafts = docSet.unsuccinctifyGrafts(block2.bg);
        allBlockScopes = new Set(
          docSet.unsuccinctifyScopes(block2.os).map((s) => s[2]).concat([blockScope])
        );
        for (const item of blockGrafts.concat(
          [
            startBlockScope,
            ...docSet.unsuccinctifyItems(block2.c, {}, block2.nt.nByte(0), allBlockScopes),
            endBlockScope
          ]
        ).concat(
          blockN !== blocks.length - 1 ? [["token", "lineSpace", " "]] : []
        )) {
          if (item[0] === "scope" && item[1] === "start") {
            waitingScopes.add(item[2]);
          }
          if (item[0] === "token" && waitingScopes.size > 0) {
            for (const waiting of Array.from(waitingScopes)) {
              allBlockScopes.add(waiting);
            }
            waitingScopes.clear();
          }
          if (allScopesPresent()) {
            if (scopeMatchEnded) {
              ret.push([[...allBlockScopes], []]);
            }
            ret[ret.length - 1][1].push(item);
            scopeMatchEnded = false;
          } else {
            scopeMatchEnded = true;
          }
          if (item[0] === "scope" && item[1] === "end") {
            allBlockScopes.delete(item[2]);
            waitingScopes.delete(item[2]);
          }
        }
      }
      return ret;
    };
    var sequenceItemsByMilestones = (docSet, blocks, byMilestones) => {
      let allBlockScopes = /* @__PURE__ */ new Set([]);
      const milestoneFound = (item) => item[0] === "scope" && item[1] === "start" && byMilestones.includes(item[2]);
      docSet.maybeBuildEnumIndexes();
      const ret = [[[], []]];
      for (const block2 of blocks) {
        const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bs, 0);
        const blockScope = docSet.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0)[2];
        const blockGrafts = docSet.unsuccinctifyGrafts(block2.bg);
        allBlockScopes.add(blockScope);
        docSet.unsuccinctifyScopes(block2.os).forEach((s) => allBlockScopes.add(s[2]));
        const items = blockGrafts.concat(
          [blockScope].concat(
            docSet.unsuccinctifyItems(block2.c, {}, block2.nt.nByte(0))
          )
        );
        for (const item of items) {
          if (item[0] === "scope" && item[1] === "start") {
            allBlockScopes.add(item[2]);
          }
          if (milestoneFound(item)) {
            ret[ret.length - 1][0] = [...allBlockScopes].sort();
            ret.push([[], []]);
            for (const bs of [...allBlockScopes].filter(
              (s) => {
                const excludes = ["blockTag", "verse", "verses", "chapter"];
                return excludes.includes(s.split("/")[0]) || byMilestones.includes(s);
              }
            )) {
              allBlockScopes.delete(bs);
            }
            allBlockScopes.add(blockScope);
          }
          ret[ret.length - 1][1].push(item);
        }
        ret[ret.length - 1][1].push(["scope", "end", blockScope]);
        ret[ret.length - 1][1].push(["token", "punctuation", "\n"]);
      }
      ret[ret.length - 1][0] = [...allBlockScopes].sort();
      return ret;
    };
    module.exports = {
      countItems,
      itemsByIndex,
      sequenceItemsByMilestones,
      sequenceItemsByScopes
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/rehash.cjs
var require_rehash = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/rehash.cjs"(exports, module) {
    init_process();
    init_buffer();
    var rehash = (docSet) => {
      docSet.preEnums = {};
      for (const category of Object.keys(docSet.enums)) {
        docSet.preEnums[category] = /* @__PURE__ */ new Map();
      }
      docSet.maybeBuildEnumIndexes();
      for (const document2 of docSet.documents()) {
        for (const sequence of Object.values(document2.sequences)) {
          document2.rerecordPreEnums(docSet, sequence);
        }
      }
      docSet.sortPreEnums();
      const oldToNew = docSet.makeRehashEnumMap();
      for (const document2 of docSet.documents()) {
        for (const sequence of Object.values(document2.sequences)) {
          document2.rewriteSequenceBlocks(sequence.id, oldToNew);
        }
      }
      docSet.buildEnums();
      docSet.buildEnumIndexes();
      return true;
    };
    var makeRehashEnumMap = (docSet) => {
      const ret = {};
      for (const [category, enumSuccinct] of Object.entries(docSet.enums)) {
        ret[category] = [];
        let pos = 0;
        while (pos < enumSuccinct.length) {
          const stringLength = enumSuccinct.byte(pos);
          const enumString = enumSuccinct.countedString(pos);
          if (docSet.preEnums[category].has(enumString)) {
            ret[category].push(docSet.preEnums[category].get(enumString).enum);
          } else {
            ret[category].push(null);
          }
          pos += stringLength + 1;
        }
      }
      return ret;
    };
    module.exports = {
      rehash,
      makeRehashEnumMap
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/update.cjs
var require_update = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/update.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var {
      pushSuccinctGraftBytes,
      pushSuccinctScopeBytes,
      pushSuccinctTokenBytes
    } = utils.succinct;
    var { itemEnum } = utils.itemDefs;
    var { scopeEnum } = utils.scopeDefs;
    var { tokenCategory, tokenEnum } = utils.tokenDefs;
    var updateItems1 = (docSet, documentId, sequenceId, blockPosition, typedArrayName, itemObjects) => {
      const document2 = docSet.processor.documents[documentId];
      if (!document2) {
        throw new Error(`Document '${documentId}' not found`);
      }
      let sequence;
      if (sequenceId) {
        sequence = document2.sequences[sequenceId];
        if (!sequence) {
          throw new Error(`Sequence '${sequenceId}' not found`);
        }
      } else {
        sequence = document2.sequences[document2.mainId];
      }
      if (sequence.blocks.length <= blockPosition) {
        throw new Error(`Could not find block ${blockPosition} (length=${sequence.blocks.length})`);
      }
      const block2 = sequence.blocks[blockPosition];
      const newItemsBA = new ByteArray(itemObjects.length);
      docSet.maybeBuildPreEnums();
      let nextToken = 0;
      if (blockPosition < 0) {
        nextToken = sequence.blocks[blockPosition - 1].nt.nByte(0);
      }
      let charsEnumIndex, graftTypeEnumIndex, seqEnumIndex, scopeBits, scopeTypeByte, scopeBitBytes = null;
      for (const item of itemObjects) {
        switch (item.type) {
          case "token":
            charsEnumIndex = docSet.enumForCategoryValue(tokenCategory[item.subType], item.payload, true);
            pushSuccinctTokenBytes(newItemsBA, tokenEnum[item.subType], charsEnumIndex);
            nextToken++;
            break;
          case "graft":
            graftTypeEnumIndex = docSet.enumForCategoryValue("graftTypes", item.subType, true);
            seqEnumIndex = docSet.enumForCategoryValue("ids", item.payload, true);
            pushSuccinctGraftBytes(newItemsBA, graftTypeEnumIndex, seqEnumIndex);
            break;
          case "scope":
            scopeBits = item.payload.split("/");
            scopeTypeByte = scopeEnum[scopeBits[0]];
            if (!scopeTypeByte && scopeTypeByte !== 0) {
              throw new Error(`"${scopeBits[0]}" is not a scope type`);
            }
            scopeBitBytes = scopeBits.slice(1).map((b) => docSet.enumForCategoryValue("scopeBits", b, true));
            pushSuccinctScopeBytes(newItemsBA, itemEnum[`${item.subType}Scope`], scopeTypeByte, scopeBitBytes);
            break;
        }
      }
      newItemsBA.trim();
      block2[typedArrayName] = newItemsBA;
      if (typedArrayName === "c") {
        block2.nt.clear();
        block2.nt.pushNByte(nextToken);
      }
      return true;
    };
    var updateItems = (docSet, documentId, sequenceId, blockPosition, itemObjects) => updateItems1(
      docSet,
      documentId,
      sequenceId,
      blockPosition,
      "c",
      itemObjects
    );
    var updateBlockGrafts = (docSet, documentId, sequenceId, blockPosition, itemObjects) => updateItems1(
      docSet,
      documentId,
      sequenceId,
      blockPosition,
      "bg",
      itemObjects
    );
    var updateBlockScope = (docSet, documentId, sequenceId, blockPosition, bsObject) => updateItems1(
      docSet,
      documentId,
      sequenceId,
      blockPosition,
      "bs",
      [bsObject]
    );
    var updateOpenScopes = (docSet, documentId, sequenceId, blockPosition, osObjects) => updateItems1(
      docSet,
      documentId,
      sequenceId,
      blockPosition,
      "os",
      osObjects
    );
    var updateIncludedScopes = (docSet, documentId, sequenceId, blockPosition, isObjects) => updateItems1(
      docSet,
      documentId,
      sequenceId,
      blockPosition,
      "is",
      isObjects
    );
    var updateBlockIndexesAfterEdit = (docSet, sequence, blockPosition) => {
      const labelsMatch = (firstA, secondA) => {
        for (const first of Array.from(firstA)) {
          if (!secondA.has(first)) {
            return false;
          }
        }
        for (const second of Array.from(secondA)) {
          if (!firstA.has(second)) {
            return false;
          }
        }
        return true;
      };
      const addSuccinctScope = (docSet2, succinct, scopeLabel) => {
        const scopeBits = scopeLabel.split("/");
        const scopeTypeByte = scopeEnum[scopeBits[0]];
        if (!scopeTypeByte && scopeTypeByte !== 0) {
          throw new Error(`"${scopeBits[0]}" is not a scope type`);
        }
        const scopeBitBytes = scopeBits.slice(1).map((b) => docSet2.enumForCategoryValue("scopeBits", b, true));
        pushSuccinctScopeBytes(succinct, itemEnum[`startScope`], scopeTypeByte, scopeBitBytes);
      };
      const block2 = sequence.blocks[blockPosition];
      const includedScopeLabels = /* @__PURE__ */ new Set();
      const openScopeLabels = /* @__PURE__ */ new Set();
      for (const openScope of docSet.unsuccinctifyScopes(block2.os)) {
        openScopeLabels.add(openScope[2]);
      }
      for (const scope of docSet.unsuccinctifyItems(block2.c, { scopes: true }, null)) {
        if (scope[1] === "start") {
          includedScopeLabels.add(scope[2]);
          openScopeLabels.add(scope[2]);
        } else {
          openScopeLabels.delete(scope[2]);
        }
      }
      const isArray3 = Array.from(includedScopeLabels);
      const isBA = new ByteArray(isArray3.length);
      for (const scopeLabel of isArray3) {
        addSuccinctScope(docSet, isBA, scopeLabel);
      }
      isBA.trim();
      block2.is = isBA;
      if (blockPosition < sequence.blocks.length - 1) {
        const nextOsBlock = sequence.blocks[blockPosition + 1];
        const nextOsBA = nextOsBlock.os;
        const nextOSLabels = new Set(docSet.unsuccinctifyScopes(nextOsBA).map((s) => s[2]));
        if (!labelsMatch(openScopeLabels, nextOSLabels)) {
          const osBA = new ByteArray(nextOSLabels.length);
          for (const scopeLabel of Array.from(openScopeLabels)) {
            addSuccinctScope(docSet, osBA, scopeLabel);
          }
          osBA.trim();
          nextOsBlock.os = osBA;
          docSet.updateBlockIndexesAfterEdit(sequence, blockPosition + 1);
        }
      }
    };
    var updateBlockIndexesAfterFilter = (docSet, sequence) => {
      const addSuccinctScope = (docSet2, succinct, scopeLabel) => {
        const scopeBits = scopeLabel.split("/");
        const scopeTypeByte = scopeEnum[scopeBits[0]];
        if (!scopeTypeByte && scopeTypeByte !== 0) {
          throw new Error(`"${scopeBits[0]}" is not a scope type`);
        }
        const scopeBitBytes = scopeBits.slice(1).map((b) => docSet2.enumForCategoryValue("scopeBits", b, true));
        pushSuccinctScopeBytes(succinct, itemEnum[`startScope`], scopeTypeByte, scopeBitBytes);
      };
      const openScopeLabels = /* @__PURE__ */ new Set();
      for (const block2 of sequence.blocks) {
        const osArray = Array.from(openScopeLabels);
        const osBA = new ByteArray(osArray.length);
        for (const scopeLabel of osArray) {
          addSuccinctScope(docSet, osBA, scopeLabel);
        }
        osBA.trim();
        block2.os = osBA;
        const includedScopeLabels = /* @__PURE__ */ new Set();
        for (const scope of docSet.unsuccinctifyItems(block2.c, { scopes: true }, null)) {
          if (scope[1] === "start") {
            includedScopeLabels.add(scope[2]);
            openScopeLabels.add(scope[2]);
          } else {
            openScopeLabels.delete(scope[2]);
          }
        }
        const isArray3 = Array.from(includedScopeLabels);
        const isBA = new ByteArray(isArray3.length);
        for (const scopeLabel of isArray3) {
          addSuccinctScope(docSet, isBA, scopeLabel);
        }
        isBA.trim();
        block2.is = isBA;
      }
    };
    module.exports = {
      updateItems,
      updateBlockGrafts,
      updateBlockScope,
      updateOpenScopes,
      updateIncludedScopes,
      updateBlockIndexesAfterEdit,
      updateBlockIndexesAfterFilter
    };
  }
});

// node_modules/proskomma-core/src/model/doc_set_helpers/serialize.cjs
var require_serialize = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set_helpers/serialize.cjs"(exports, module) {
    init_process();
    init_buffer();
    var serializeSuccinct = (docSet) => {
      const ret = {
        id: docSet.id,
        metadata: { selectors: docSet.selectors },
        enums: {},
        docs: {},
        tags: Array.from(docSet.tags)
      };
      for (const [eK, eV] of Object.entries(docSet.enums)) {
        eV.trim();
        ret.enums[eK] = eV.base64();
      }
      ret.docs = {};
      for (const docId of docSet.docIds) {
        ret.docs[docId] = docSet.processor.documents[docId].serializeSuccinct();
      }
      return ret;
    };
    module.exports = { serializeSuccinct };
  }
});

// node_modules/proskomma-core/src/model/doc_set.cjs
var require_doc_set = __commonJS({
  "node_modules/proskomma-core/src/model/doc_set.cjs"(exports, module) {
    init_process();
    init_buffer();
    var checksum = require_checksum();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var {
      addTag,
      removeTag,
      validateTags
    } = utils.tags;
    var {
      succinctGraftName,
      succinctGraftSeqId,
      succinctScopeLabel,
      succinctTokenChars,
      headerBytes,
      enumIndex,
      enumIndexes
    } = utils.succinct;
    var { itemEnum } = utils.itemDefs;
    var { tokenEnumLabels } = utils.tokenDefs;
    var { validateSelectors } = require_selectors();
    var {
      blocksWithScriptureCV,
      allBlockScopes,
      anyScopeInBlock,
      allScopesInBlock,
      blockHasBlockScope,
      blockHasChars,
      blockHasMatchingItem
    } = require_block();
    var {
      unsuccinctifyBlock,
      unsuccinctifyItems,
      unsuccinctifyItem,
      unsuccinctifyPrunedItems,
      unsuccinctifyItemsWithScriptureCV
    } = require_unsuccinctify();
    var {
      buildPreEnum,
      recordPreEnum,
      buildEnum,
      enumForCategoryValue
    } = require_enum2();
    var {
      countItems,
      itemsByIndex,
      sequenceItemsByScopes,
      sequenceItemsByMilestones
    } = require_item();
    var {
      rehash,
      makeRehashEnumMap
    } = require_rehash();
    var {
      updateItems,
      updateBlockGrafts,
      updateBlockScope,
      updateOpenScopes,
      updateIncludedScopes,
      updateBlockIndexesAfterEdit,
      updateBlockIndexesAfterFilter
    } = require_update();
    var { serializeSuccinct } = require_serialize();
    var DocSet = class {
      constructor(processor, selectors, tags, succinctJson) {
        this.processor = processor;
        this.preEnums = {};
        this.enumIndexes = {};
        this.docIds = [];
        if (succinctJson) {
          this.fromSuccinct(processor, succinctJson);
        } else {
          this.fromScratch(processor, selectors, tags);
        }
        validateTags(this.tags);
      }
      fromScratch(processor, selectors, tags) {
        const defaultedSelectors = selectors || processor.selectors;
        this.selectors = validateSelectors(this, defaultedSelectors);
        this.id = this.selectorString();
        this.tags = new Set(tags || []);
        this.enums = {
          ids: new ByteArray(512),
          wordLike: new ByteArray(8192),
          notWordLike: new ByteArray(256),
          scopeBits: new ByteArray(256),
          graftTypes: new ByteArray(10)
        };
      }
      fromSuccinct(processor, succinctJson) {
        const populatedByteArray = (succinct) => {
          const ret = new ByteArray(256);
          ret.fromBase64(succinct);
          ret.trim();
          return ret;
        };
        this.id = succinctJson.id;
        this.selectors = validateSelectors(this, succinctJson.metadata.selectors);
        this.tags = new Set(succinctJson.tags);
        validateTags(this.tags);
        this.preEnums = {};
        this.enums = {
          ids: populatedByteArray(succinctJson.enums.ids),
          wordLike: populatedByteArray(succinctJson.enums.wordLike),
          notWordLike: populatedByteArray(succinctJson.enums.notWordLike),
          scopeBits: populatedByteArray(succinctJson.enums.scopeBits),
          graftTypes: populatedByteArray(succinctJson.enums.graftTypes)
        };
        this.enumIndexes = {};
        this.docIds = [];
      }
      addTag(tag) {
        addTag(this.tags, tag);
      }
      removeTag(tag) {
        removeTag(this.tags, tag);
      }
      selectorString() {
        return this.processor.selectorString(this.selectors);
      }
      documents() {
        return this.docIds.map((did) => this.processor.documents[did]);
      }
      documentWithBook(bookCode) {
        const docsWithBook = Object.values(this.documents()).filter((doc) => "bookCode" in doc.headers && doc.headers["bookCode"] === bookCode);
        return docsWithBook.length === 1 ? docsWithBook[0] : null;
      }
      maybeBuildPreEnums() {
        if (Object.keys(this.preEnums).length === 0) {
          this.buildPreEnums();
        }
      }
      buildPreEnums() {
        for (const [category, succinct] of Object.entries(this.enums)) {
          this.preEnums[category] = buildPreEnum(this, succinct);
        }
      }
      recordPreEnum(category, value) {
        recordPreEnum(this, category, value);
      }
      sortPreEnums() {
        for (const catKey of Object.keys(this.preEnums)) {
          this.preEnums[catKey] = new Map([...this.preEnums[catKey].entries()].sort((a, b) => b[1].frequency - a[1].frequency));
          let count = 0;
          for (const [k, v] of this.preEnums[catKey]) {
            v.enum = count++;
          }
        }
      }
      enumForCategoryValue(category, value, addUnknown) {
        return enumForCategoryValue(this, category, value, addUnknown);
      }
      buildEnums() {
        for (const [category, catOb] of Object.entries(this.preEnums)) {
          this.enums[category].clear();
          this.buildEnum(category, catOb);
        }
      }
      buildEnum(category, preEnumOb) {
        buildEnum(this, category, preEnumOb);
      }
      maybeBuildEnumIndexes() {
        if (Object.keys(this.enumIndexes).length === 0) {
          this.buildEnumIndexes();
        }
      }
      buildEnumIndexes() {
        this.enumIndexes = enumIndexes(this.enums);
      }
      buildEnumIndex(category) {
        this.enumIndexes[category] = enumIndex(category, this.enums[category]);
      }
      unsuccinctifyBlock(block2, options) {
        return unsuccinctifyBlock(this, block2, options);
      }
      unsuccinctifyItems(succinct, options, nextToken, openScopes) {
        return unsuccinctifyItems(this, succinct, options, nextToken, openScopes);
      }
      unsuccinctifyItem(succinct, pos, options) {
        return unsuccinctifyItem(this, succinct, pos, options);
      }
      unsuccinctifyPrunedItems(block2, options) {
        return unsuccinctifyPrunedItems(this, block2, options);
      }
      unsuccinctifyScopes(succinct) {
        const ret = [];
        let pos = 0;
        while (pos < succinct.length) {
          const [itemLength, itemType, itemSubtype] = headerBytes(succinct, pos);
          ret.push(this.unsuccinctifyScope(succinct, itemType, itemSubtype, pos));
          pos += itemLength;
        }
        return ret;
      }
      unsuccinctifyGrafts(succinct) {
        const ret = [];
        let pos = 0;
        while (pos < succinct.length) {
          const [itemLength, itemType, itemSubtype] = headerBytes(succinct, pos);
          ret.push(this.unsuccinctifyGraft(succinct, itemSubtype, pos));
          pos += itemLength;
        }
        return ret;
      }
      unsuccinctifyToken(succinct, itemSubtype, pos) {
        try {
          return [
            "token",
            tokenEnumLabels[itemSubtype],
            this.succinctTokenChars(succinct, itemSubtype, pos)
          ];
        } catch (err) {
          throw new Error(`Error from unsuccinctifyToken: ${err}`);
        }
      }
      unsuccinctifyScope(succinct, itemType, itemSubtype, pos) {
        try {
          return [
            "scope",
            itemType === itemEnum.startScope ? "start" : "end",
            this.succinctScopeLabel(succinct, itemSubtype, pos)
          ];
        } catch (err) {
          throw new Error(`Error from unsuccinctifyScope: ${err}`);
        }
      }
      unsuccinctifyGraft(succinct, itemSubtype, pos) {
        try {
          return [
            "graft",
            this.succinctGraftName(itemSubtype),
            this.succinctGraftSeqId(succinct, pos)
          ];
        } catch (err) {
          throw new Error(`Error from unsuccinctifyGraft: ${err}`);
        }
      }
      unsuccinctifyBlockScopeLabelsSet(block2) {
        const [itemLength, itemType, itemSubtype] = headerBytes(block2.bs, 0);
        const blockScope = this.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0);
        return new Set(
          this.unsuccinctifyScopes(block2.os).concat(
            this.unsuccinctifyScopes(block2.is)
          ).concat([blockScope]).map((ri) => ri[2])
        );
      }
      unsuccinctifyItemsWithScriptureCV(block2, cv, options) {
        return unsuccinctifyItemsWithScriptureCV(this, block2, cv, options);
      }
      succinctTokenChars(succinct, itemSubtype, pos) {
        return succinctTokenChars(this.enums, this.enumIndexes, succinct, itemSubtype, pos);
      }
      succinctScopeLabel(succinct, itemSubtype, pos) {
        return succinctScopeLabel(this.enums, this.enumIndexes, succinct, itemSubtype, pos);
      }
      succinctGraftName(itemSubtype) {
        return succinctGraftName(this.enums, this.enumIndexes, itemSubtype);
      }
      succinctGraftSeqId(succinct, pos) {
        return succinctGraftSeqId(this.enums, this.enumIndexes, succinct, pos);
      }
      countItems(succinct) {
        return countItems(this, succinct);
      }
      itemsByIndex(mainSequence, index, includeContext) {
        return itemsByIndex(this, mainSequence, index, includeContext);
      }
      blocksWithScriptureCV(blocks, cv) {
        return blocksWithScriptureCV(this, blocks, cv);
      }
      allBlockScopes(block2) {
        return allBlockScopes(this, block2);
      }
      allScopesInBlock(block2, scopes) {
        return allScopesInBlock(this, block2, scopes);
      }
      anyScopeInBlock(block2, scopes) {
        return anyScopeInBlock(this, block2, scopes);
      }
      blockHasBlockScope(block2, scope) {
        return blockHasBlockScope(this, block2, scope);
      }
      blockHasChars(block2, charsIndexes) {
        return blockHasChars(this, block2, charsIndexes);
      }
      blockHasMatchingItem(block2, testFunction, options) {
        return blockHasMatchingItem(this, block2, testFunction, options);
      }
      sequenceItemsByScopes(blocks, byScopes) {
        return sequenceItemsByScopes(this, blocks, byScopes);
      }
      sequenceItemsByMilestones(blocks, byMilestones) {
        return sequenceItemsByMilestones(this, blocks, byMilestones);
      }
      rehash() {
        return rehash(this);
      }
      makeRehashEnumMap() {
        return makeRehashEnumMap(this);
      }
      updateItems(documentId, sequenceId, blockPosition, itemObjects) {
        return updateItems(this, documentId, sequenceId, blockPosition, itemObjects);
      }
      updateBlockGrafts(documentId, sequenceId, blockPosition, itemObjects) {
        return updateBlockGrafts(this, documentId, sequenceId, blockPosition, itemObjects);
      }
      updateBlockScope(documentId, sequenceId, blockPosition, bsObject) {
        return updateBlockScope(this, documentId, sequenceId, blockPosition, bsObject);
      }
      updateOpenScopes(documentId, sequenceId, blockPosition, osObjects) {
        return updateOpenScopes(this, documentId, sequenceId, blockPosition, osObjects);
      }
      updateIncludedScopes(documentId, sequenceId, blockPosition, isObjects) {
        return updateIncludedScopes(this, documentId, sequenceId, blockPosition, isObjects);
      }
      updateBlockIndexesAfterEdit(sequence, blockPosition) {
        updateBlockIndexesAfterEdit(this, sequence, blockPosition);
      }
      updateBlockIndexesAfterFilter(sequence) {
        updateBlockIndexesAfterFilter(this, sequence);
      }
      serializeSuccinct() {
        return serializeSuccinct(this);
      }
      checksum() {
        const docIdsString = [...this.docIds].sort().join(" ");
        return checksum(docIdsString);
      }
    };
    module.exports = { DocSet };
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from2, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from2;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from: from2, to } = this;
        return `for(${varKind} ${name}=${from2}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from2, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from2, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) + (from2[n] || 0);
      return names;
    }
    function addExprNames(names, from2) {
      return from2 instanceof code_1._CodeOrName ? addNames(names, from2.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) - (from2[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from2, to, toName) => {
        const res = to === void 0 ? from2 : to instanceof codegen_1.Name ? (from2 instanceof codegen_1.Name ? mergeNames(gen, from2, to) : mergeToName(gen, from2, to), to) : from2 instanceof codegen_1.Name ? (mergeToName(gen, to, from2), from2) : mergeValues(from2, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from2} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from2})`));
        }),
        mergeToName: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from2 === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from2);
          }
        }),
        mergeValues: (from2, to) => from2 === true ? true : { ...from2, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from2} === true ? true : ${to} > ${from2} ? ${to} : ${from2}`)),
        mergeToName: (gen, from2, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from2 === true ? true : (0, codegen_1._)`${to} > ${from2} ? ${to} : ${from2}`)),
        mergeValues: (from2, to) => from2 === true ? true : Math.max(from2, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber2 = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber2 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      errors: new codegen_1.Name("errors"),
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/errors.js
var require_errors3 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName: validateName2, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName: validateName2 } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors3();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate2 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate2);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/proskomma-core/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/proskomma-core/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util2();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId2 = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          baseId2 = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId2;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(baseId2 ? _resolve(baseId2, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var errors_1 = require_errors3();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName: validateName2, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName2, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName2, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName: validateName2 } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName2}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName: validateName2, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName2}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env2) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env2.schema == "object")
          schema = env2.schema;
        this.schema = env2.schema;
        this.schemaId = env2.schemaId;
        this.root = env2.root || this;
        this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
        this.schemaPath = env2.schemaPath;
        this.localRefs = env2.localRefs;
        this.meta = env2.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName2 = gen.scopeName("validate");
      sch.validateName = validateName2;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName: validateName2,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate2 = makeValidate(this, this.scope.get());
        this.scope.value(validateName2, { ref: validate2 });
        validate2.errors = null;
        validate2.schema = sch.schema;
        validate2.schemaEnv = sch;
        if (sch.$async)
          validate2.$async = true;
        if (this.opts.code.source === true) {
          validate2.source = { validateName: validateName2, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate2.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate2.source)
            validate2.source.evaluated = (0, codegen_1.stringify)(validate2.evaluated);
        }
        sch.validate = validate2;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env2;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env2 = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env2 = env2 || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env2.schema !== env2.root.schema)
        return env2;
      return void 0;
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_uri_all();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util2();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema2 = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema2)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    exports.default = Ajv;
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env2, validateName: validateName2, opts, self: self2 } = it;
        const { root } = env2;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env2 === root)
            return callRef(cxt, validateName2, env2, env2.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env2, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env2.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum3 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum3();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block2) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block2();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format2 = [format_1.default];
    exports.default = format2;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types3 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types3();
    var compile_1 = require_compile();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/proskomma-core/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/proskomma-core/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    module.exports = exports = Ajv;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/succinct/0_2_0/proskomma_succinct.json
var require_proskomma_succinct = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/succinct/0_2_0/proskomma_succinct.json"(exports, module) {
    module.exports = {
      title: "Root",
      type: "object",
      description: "Root Element",
      definitions: {
        base64String: {
          type: "string",
          pattern: "^[A-Za-z0-9/+=]*$"
        },
        tagString: {
          type: "string",
          pattern: "^[a-z][a-z0-9]*(:.+)?$"
        }
      },
      properties: {
        id: {
          type: "string"
        },
        metadata: {
          type: "object",
          properties: {
            selectors: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            }
          },
          required: [
            "selectors"
          ],
          additionalProperties: false
        },
        tags: {
          type: "array",
          items: {
            type: "string",
            $ref: "#/definitions/tagString"
          }
        },
        enums: {
          type: "object",
          properties: {
            ids: {
              $ref: "#/definitions/base64String"
            },
            wordLike: {
              $ref: "#/definitions/base64String"
            },
            notWordLike: {
              $ref: "#/definitions/base64String"
            },
            scopeBits: {
              $ref: "#/definitions/base64String"
            },
            graftTypes: {
              $ref: "#/definitions/base64String"
            }
          },
          required: [
            "ids",
            "wordLike",
            "notWordLike",
            "scopeBits",
            "graftTypes"
          ],
          additionalProperties: false
        },
        docs: {
          type: "object",
          propertyNames: {
            type: "string"
          },
          additionalProperties: {
            type: "object",
            properties: {
              sequences: {
                type: "object",
                additionalProperties: {
                  type: "object",
                  properties: {
                    type: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "object",
                        properties: {
                          bs: {
                            type: "string"
                          },
                          bg: {
                            type: "string"
                          },
                          c: {
                            type: "string"
                          },
                          is: {
                            type: "string"
                          },
                          os: {
                            type: "string"
                          },
                          nt: {
                            type: "string"
                          }
                        },
                        required: [
                          "bs",
                          "bg",
                          "c",
                          "is",
                          "os",
                          "nt"
                        ],
                        additionalProperties: false
                      }
                    },
                    tags: {
                      type: "array",
                      items: {
                        type: "string",
                        $ref: "#/definitions/tagString"
                      }
                    },
                    chapters: {
                      type: "object",
                      additionalProperties: {
                        type: "string"
                      }
                    },
                    chapterVerses: {
                      type: "object",
                      additionalProperties: {
                        type: "string"
                      }
                    },
                    tokensPresent: {
                      type: "string"
                    }
                  },
                  required: [
                    "blocks",
                    "tags"
                  ],
                  additionalProperties: false
                }
              },
              headers: {
                type: "object",
                additionalProperties: {
                  type: "string"
                }
              },
              mainId: {
                type: "string"
              },
              tags: {
                type: "array",
                items: {
                  type: "string",
                  $ref: "#/definitions/tagString"
                }
              }
            },
            required: [
              "sequences",
              "headers",
              "mainId",
              "tags"
            ],
            additionalProperties: false
          }
        },
        additionalProperties: false
      },
      required: [
        "id",
        "enums",
        "docs",
        "tags"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/document_structure.json
var require_document_structure = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/document_structure.json"(exports, module) {
    module.exports = {
      $comment: "version 0.1.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_2_1/document_structure.json",
      title: "Document (Structure)",
      description: "A document, typically corresponding to a single USFM or USX book",
      type: "object",
      properties: {
        schema: {
          type: "object",
          properties: {
            structure: {
              description: "The basic 'shape' of the content",
              type: "string",
              enum: [
                "flat",
                "nested"
              ]
            },
            structure_version: {
              description: "the semantic version of the structure schema",
              type: "string"
            },
            constraints: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string",
                    enum: [
                      "perf",
                      "sofria"
                    ]
                  },
                  version: {
                    description: "the semantic version of the constraint schema",
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: [
                  "name",
                  "version"
                ]
              }
            }
          },
          required: [
            "structure",
            "structure_version",
            "constraints"
          ],
          additionalProperties: false
        },
        metadata: {
          description: "Metadata describing the document and the translation it belongs to",
          type: "object",
          properties: {
            translation: {
              type: "object",
              description: "Metadata concerning the translation to which the document belongs",
              properties: {
                tags: {
                  description: "Tags attached to the translation",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                properties: {
                  type: "object",
                  description: "Key/value properties attached to the translation",
                  additionalProperties: {
                    type: "string"
                  }
                },
                selectors: {
                  type: "object",
                  description: "Proskomma selectors for the translation that, together, provide a primary key in the translation store",
                  additionalProperties: {
                    type: "string"
                  }
                }
              },
              additionalProperties: {
                type: "string"
              },
              required: ["id"]
            },
            document: {
              type: "object",
              description: "Metadata concerning the document itself",
              properties: {
                tags: {
                  type: "array",
                  description: "Tags attached to the document",
                  items: {
                    type: "string"
                  }
                },
                properties: {
                  type: "object",
                  description: "Key/value properties attached to the document",
                  additionalProperties: {
                    type: "string"
                  }
                },
                chapters: {
                  type: "string",
                  pattern: "^[1-9][0-9]*(-[1-9][0-9]*)?$"
                }
              },
              additionalProperties: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        },
        sequences: {
          type: "object",
          propertyNames: {
            pattern: "^\\S+$"
          },
          additionalProperties: {
            $ref: "./sequence_structure.json"
          }
        },
        sequence: {
          $ref: "./sequence_structure.json"
        },
        main_sequence_id: {
          type: "string"
        }
      },
      required: [
        "schema",
        "metadata"
      ],
      additionalProperties: false,
      if: {
        properties: {
          schema: {
            type: "object",
            properties: {
              structure: {
                enum: [
                  "flat"
                ]
              }
            }
          }
        }
      },
      then: {
        required: [
          "sequences",
          "main_sequence_id"
        ],
        not: {
          required: [
            "sequence"
          ]
        }
      },
      else: {
        required: [
          "sequence"
        ],
        allOf: [
          {
            not: {
              required: [
                "sequences"
              ]
            }
          },
          {
            not: {
              required: [
                "main_sequence_id"
              ]
            }
          }
        ]
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/sequence_structure.json
var require_sequence_structure = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/sequence_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_2_1/sequence_structure.json",
      title: "Sequence (Structure)",
      description: "A sequence contains a 'flow' of one or more blocks",
      type: "object",
      properties: {
        type: {
          description: "The type of sequence",
          type: "string"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label",
          type: "string"
        },
        blocks: {
          type: "array",
          description: "The blocks that, together, represent the 'flow' of the sequence",
          items: {
            $ref: "./block_structure.json"
          }
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/block_structure.json
var require_block_structure = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/block_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_2_1/block_structure.json",
      title: "Block (Structure)",
      description: "A block, which represents either a paragraph of text or a graft",
      type: "object",
      properties: {
        type: {
          type: "string",
          description: "The type of block",
          enum: [
            "paragraph",
            "graft"
          ]
        },
        subtype: {
          description: "A type-specific subtype",
          type: "string"
        },
        target: {
          description: "The id of the sequence containing graft content",
          type: "string"
        },
        sequence: {
          description: "The sequence containing graft content",
          $ref: "./sequence_structure.json"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label for a graft",
          type: "string"
        },
        new: {
          description: "If present and true, is interpreted as a request for the server to create a new graft",
          type: "boolean"
        },
        atts: {
          type: "object",
          description: "An object containing USFM attributes or subtype-specific additional information (such as the number of a verse or chapter). The value may be a boolean, a string or an array of strings",
          additionalProperties: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              },
              {
                type: "boolean"
              }
            ]
          }
        },
        content: {
          type: "array",
          description: "The content of the block",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false,
      if: {
        properties: {
          type: {
            enum: [
              "paragraph"
            ]
          }
        }
      },
      then: {
        required: [
          "content"
        ],
        allOf: [
          {
            not: {
              required: [
                "new"
              ]
            }
          },
          {
            not: {
              required: [
                "preview_text"
              ]
            }
          },
          {
            not: {
              required: [
                "target"
              ]
            }
          }
        ]
      },
      else: {
        if: {
          required: [
            "new"
          ],
          properties: {
            new: {
              enum: [
                true
              ]
            }
          }
        },
        then: {
          allOf: [
            {
              oneOf: [
                {
                  required: [
                    "subtype"
                  ]
                },
                {
                  required: [
                    "sequence"
                  ]
                }
              ]
            },
            {
              not: {
                required: [
                  "target"
                ]
              }
            },
            {
              not: {
                required: [
                  "preview_text"
                ]
              }
            },
            {
              not: {
                required: [
                  "content"
                ]
              }
            }
          ]
        },
        else: {
          oneOf: [
            {
              required: [
                "target"
              ]
            },
            {
              required: [
                "sequence"
              ]
            }
          ]
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/contentElement_structure.json
var require_contentElement_structure = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_2_1/contentElement_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_2_1/contentElement_structure.json",
      title: "Content Element (Structure)",
      description: "A content element, ie some form of (possibly nested) markup",
      type: "object",
      properties: {
        type: {
          type: "string",
          description: "The type of element",
          enum: [
            "mark",
            "wrapper",
            "start_milestone",
            "end_milestone",
            "graft"
          ]
        },
        subtype: {
          description: "The subtype of the element, which is context-dependent",
          type: "string"
        },
        atts: {
          type: "object",
          description: "An object containing USFM attributes or subtype-specific additional information (such as the number of a verse or chapter). The value may be a boolean, a string or an array of strings",
          additionalProperties: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              },
              {
                type: "boolean"
              }
            ]
          }
        },
        target: {
          type: "string",
          description: "The id of the sequence containing graft content"
        },
        sequence: {
          description: "The sequence containing graft content",
          $ref: "./sequence_structure.json"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label for a graft",
          type: "string"
        },
        new: {
          type: "boolean",
          description: "If present and true, is interpreted as a request for the server to create a new graft"
        },
        content: {
          type: "array",
          description: "Nested content within the content element",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          description: "Non-Scripture content related to the content element, such as checking data or related resources",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_document_constraint.json
var require_perf_document_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_document_constraint.json"(exports, module) {
    module.exports = {
      $comment: "version 0.2.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/perf_document_constraint.json",
      type: "object",
      properties: {
        sequences: {
          type: "object",
          propertyNames: {
            pattern: "^\\S+$"
          },
          additionalProperties: {
            $ref: "./perf_sequence_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_sequence_constraint.json
var require_perf_sequence_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_sequence_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/perf_sequence_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "main",
            "introduction",
            "intro_title",
            "intro_end_title",
            "title",
            "end_title",
            "heading",
            "remark",
            "sidebar",
            "table",
            "tree",
            "kv",
            "footnote",
            "note_caller",
            "xref",
            "pub_number",
            "alt_number",
            "esb_cat",
            "fig",
            "temp"
          ]
        },
        blocks: {
          type: "array",
          items: {
            $ref: "./perf_block_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_block_constraint.json
var require_perf_block_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_block_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/perf_block_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "paragraph",
            "graft"
          ]
        },
        content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./perf_contentElement_constraint.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./perf_contentElement_constraint.json"
              }
            ]
          }
        }
      },
      if: {
        properties: {
          type: {
            enum: ["graft"]
          }
        }
      },
      then: {
        properties: {
          subtype: {
            enum: [
              "introduction",
              "intro_title",
              "Intro_end_title",
              "title",
              "end_title",
              "heading",
              "remark",
              "sidebar",
              "table",
              "tree",
              "kv"
            ]
          }
        }
      },
      else: {
        properties: {
          subtype: {
            type: "string",
            pattern: "^usfm:"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_contentElement_constraint.json
var require_perf_contentElement_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/perf_contentElement_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/perf_contentElement_constraint.json",
      type: "object",
      allOf: [
        {
          properties: {
            content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./perf_contentElement_constraint.json"
                  }
                ]
              }
            },
            meta_content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./perf_contentElement_constraint.json"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "graft"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                enum: [
                  "footnote",
                  "xref",
                  "note_caller"
                ]
              }
            },
            allOf: [
              {
                not: {
                  required: [
                    "content"
                  ]
                }
              },
              {
                not: {
                  required: [
                    "meta_content"
                  ]
                }
              }
            ],
            if: {
              required: [
                "new"
              ],
              properties: {
                new: {
                  enum: [
                    true
                  ]
                }
              }
            },
            then: {
              not: {
                anyOf: [
                  {
                    required: [
                      "target"
                    ]
                  },
                  {
                    required: [
                      "preview_text"
                    ]
                  }
                ]
              }
            },
            else: {
              required: [
                "target"
              ]
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "mark"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "chapter",
                      "verses"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: [
                    "chapter",
                    "verses"
                  ]
                }
              }
            },
            then: {
              type: "object",
              required: [
                "atts"
              ],
              properties: {
                atts: {
                  type: "object",
                  required: [
                    "number"
                  ],
                  maxProperties: 1
                }
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "wrapper"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "meta_content"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: ["meta_content"]
                }
              }
            },
            then: {
              not: {
                required: ["atts"]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "start_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "end_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            not: {
              required: [
                "atts"
              ]
            }
          }
        }
      ]
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_document_constraint.json
var require_sofria_document_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_document_constraint.json"(exports, module) {
    module.exports = {
      $comment: "version 0.2.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/sofria_document_constraint.json",
      type: "object",
      properties: {
        sequences: {
          type: "object",
          propertyNames: {
            pattern: "^\\S+$"
          },
          additionalProperties: {
            $ref: "./sofria_sequence_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_sequence_constraint.json
var require_sofria_sequence_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_sequence_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/sofria_sequence_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "main",
            "introduction",
            "intro_title",
            "intro_end_title",
            "title",
            "end_title",
            "heading",
            "remark",
            "sidebar",
            "table",
            "tree",
            "kv",
            "footnote",
            "note_caller",
            "xref",
            "pub_number",
            "alt_number",
            "esb_cat",
            "fig",
            "temp"
          ]
        },
        blocks: {
          type: "array",
          items: {
            $ref: "./sofria_block_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_block_constraint.json
var require_sofria_block_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_block_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/sofria_block_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "paragraph",
            "graft"
          ]
        },
        content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./sofria_contentElement_constraint.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./sofria_contentElement_constraint.json"
              }
            ]
          }
        }
      },
      if: {
        properties: {
          type: {
            enum: ["graft"]
          }
        }
      },
      then: {
        properties: {
          subtype: {
            enum: [
              "introduction",
              "intro_title",
              "Intro_end_title",
              "title",
              "end_title",
              "heading",
              "remark",
              "sidebar",
              "table",
              "tree",
              "kv"
            ]
          }
        }
      },
      else: {
        properties: {
          subtype: {
            type: "string",
            pattern: "^usfm:"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_contentElement_constraint.json
var require_sofria_contentElement_constraint = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_2_1/sofria_contentElement_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_2_1/sofria_contentElement_constraint.json",
      type: "object",
      allOf: [
        {
          properties: {
            content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./sofria_contentElement_constraint.json"
                  }
                ]
              }
            },
            meta_content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./sofria_contentElement_constraint.json"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "graft"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                enum: [
                  "footnote",
                  "xref",
                  "note_caller"
                ]
              }
            },
            allOf: [
              {
                not: {
                  required: [
                    "content"
                  ]
                }
              },
              {
                not: {
                  required: [
                    "meta_content"
                  ]
                }
              }
            ],
            if: {
              required: [
                "new"
              ],
              properties: {
                new: {
                  enum: [
                    true
                  ]
                }
              }
            },
            then: {
              not: {
                anyOf: [
                  {
                    required: [
                      "block"
                    ]
                  },
                  {
                    required: [
                      "preview_text"
                    ]
                  }
                ]
              }
            },
            else: {
              required: [
                "block"
              ]
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "mark"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "chapter_label",
                      "verses_label"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: [
                    "chapter",
                    "verses"
                  ]
                }
              }
            },
            then: {
              type: "object",
              required: [
                "atts"
              ],
              properties: {
                atts: {
                  type: "object",
                  required: [
                    "number"
                  ],
                  maxProperties: 1
                }
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "wrapper"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "meta_content",
                      "chapter",
                      "verses"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: ["meta_content"]
                }
              }
            },
            then: {
              not: {
                required: ["atts"]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "start_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "end_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            not: {
              required: [
                "atts"
              ]
            }
          }
        }
      ]
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/document_structure.json
var require_document_structure2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/document_structure.json"(exports, module) {
    module.exports = {
      $comment: "version 0.1.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_3_0/document_structure.json",
      title: "Document (Structure)",
      description: "A document, typically corresponding to a single USFM or USX book",
      type: "object",
      properties: {
        schema: {
          type: "object",
          properties: {
            structure: {
              description: "The basic 'shape' of the content",
              type: "string",
              enum: [
                "flat",
                "nested"
              ]
            },
            structure_version: {
              description: "the semantic version of the structure schema",
              type: "string"
            },
            constraints: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  name: {
                    type: "string",
                    enum: [
                      "perf",
                      "sofria"
                    ]
                  },
                  version: {
                    description: "the semantic version of the constraint schema",
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: [
                  "name",
                  "version"
                ]
              }
            }
          },
          required: [
            "structure",
            "structure_version",
            "constraints"
          ],
          additionalProperties: false
        },
        metadata: {
          description: "Metadata describing the document and the translation it belongs to",
          type: "object",
          properties: {
            translation: {
              type: "object",
              description: "Metadata concerning the translation to which the document belongs",
              properties: {
                tags: {
                  description: "Tags attached to the translation",
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                properties: {
                  type: "object",
                  description: "Key/value properties attached to the translation",
                  additionalProperties: {
                    type: "string"
                  }
                },
                selectors: {
                  type: "object",
                  description: "Proskomma selectors for the translation that, together, provide a primary key in the translation store",
                  additionalProperties: {
                    type: "string"
                  }
                }
              },
              additionalProperties: {
                type: "string"
              },
              required: ["id"]
            },
            document: {
              type: "object",
              description: "Metadata concerning the document itself",
              properties: {
                tags: {
                  type: "array",
                  description: "Tags attached to the document",
                  items: {
                    type: "string"
                  }
                },
                properties: {
                  type: "object",
                  description: "Key/value properties attached to the document",
                  additionalProperties: {
                    type: "string"
                  }
                },
                chapters: {
                  type: "string",
                  pattern: "^[1-9][0-9]*(-[1-9][0-9]*)?$"
                }
              },
              additionalProperties: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        },
        hooks: {
          type: "array",
          $ref: "./hook_structure.json"
        },
        sequences: {
          type: "object",
          propertyNames: {
            pattern: "^\\S+$"
          },
          additionalProperties: {
            $ref: "./sequence_structure.json"
          }
        },
        sequence: {
          $ref: "./sequence_structure.json"
        },
        main_sequence_id: {
          type: "string"
        }
      },
      required: [
        "schema",
        "metadata"
      ],
      additionalProperties: false,
      if: {
        properties: {
          schema: {
            type: "object",
            properties: {
              structure: {
                enum: [
                  "flat"
                ]
              }
            }
          }
        }
      },
      then: {
        required: [
          "sequences",
          "main_sequence_id"
        ],
        not: {
          required: [
            "sequence"
          ]
        }
      },
      else: {
        required: [
          "sequence"
        ],
        allOf: [
          {
            not: {
              required: [
                "sequences"
              ]
            }
          },
          {
            not: {
              required: [
                "main_sequence_id"
              ]
            }
          }
        ]
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/sequence_structure.json
var require_sequence_structure2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/sequence_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_3_0/sequence_structure.json",
      title: "Sequence (Structure)",
      description: "A sequence contains a 'flow' of one or more blocks",
      type: "object",
      properties: {
        type: {
          description: "The type of sequence",
          type: "string"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label",
          type: "string"
        },
        blocks: {
          type: "array",
          description: "The blocks that, together, represent the 'flow' of the sequence",
          items: {
            $ref: "./block_structure.json"
          }
        },
        hooks: {
          type: "array",
          $ref: "./hook_structure.json"
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/block_structure.json
var require_block_structure2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/block_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_3_0/block_structure.json",
      title: "Block (Structure)",
      description: "A block, which represents either a paragraph of text or a graft",
      type: "object",
      properties: {
        type: {
          type: "string",
          description: "The type of block",
          enum: [
            "paragraph",
            "row",
            "node",
            "lookup",
            "graft"
          ]
        },
        subtype: {
          description: "A type-specific subtype",
          type: "string"
        },
        target: {
          description: "The id of the sequence containing graft content",
          type: "string"
        },
        sequence: {
          description: "The sequence containing graft content",
          $ref: "./sequence_structure.json"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label for a graft",
          type: "string"
        },
        new: {
          description: "If present and true, is interpreted as a request for the server to create a new graft",
          type: "boolean"
        },
        atts: {
          type: "object",
          description: "An object containing USFM attributes or subtype-specific additional information (such as the number of a verse or chapter). The value may be a boolean, a string or an array of strings",
          additionalProperties: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              },
              {
                type: "boolean"
              }
            ]
          }
        },
        content: {
          type: "array",
          description: "The content of the block",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        },
        hooks: {
          type: "array",
          $ref: "./hook_structure.json"
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false,
      if: {
        properties: {
          type: {
            enum: [
              "paragraph",
              "row",
              "node",
              "lookup"
            ]
          }
        }
      },
      then: {
        required: [
          "content"
        ],
        allOf: [
          {
            not: {
              required: [
                "new"
              ]
            }
          },
          {
            not: {
              required: [
                "preview_text"
              ]
            }
          },
          {
            not: {
              required: [
                "target"
              ]
            }
          }
        ]
      },
      else: {
        if: {
          required: [
            "new"
          ],
          properties: {
            new: {
              enum: [
                true
              ]
            }
          }
        },
        then: {
          allOf: [
            {
              oneOf: [
                {
                  required: [
                    "subtype"
                  ]
                },
                {
                  required: [
                    "sequence"
                  ]
                }
              ]
            },
            {
              not: {
                required: [
                  "target"
                ]
              }
            },
            {
              not: {
                required: [
                  "preview_text"
                ]
              }
            },
            {
              not: {
                required: [
                  "content"
                ]
              }
            }
          ]
        },
        else: {
          oneOf: [
            {
              required: [
                "target"
              ]
            },
            {
              required: [
                "sequence"
              ]
            }
          ]
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/contentElement_structure.json
var require_contentElement_structure2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/contentElement_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_3_0/contentElement_structure.json",
      title: "Content Element (Structure)",
      description: "A content element, ie some form of (possibly nested) markup",
      type: "object",
      properties: {
        type: {
          type: "string",
          description: "The type of element",
          enum: [
            "mark",
            "wrapper",
            "start_milestone",
            "end_milestone",
            "graft"
          ]
        },
        subtype: {
          description: "The subtype of the element, which is context-dependent",
          type: "string"
        },
        atts: {
          type: "object",
          description: "An object containing USFM attributes or subtype-specific additional information (such as the number of a verse or chapter). The value may be a boolean, a string or an array of strings",
          additionalProperties: {
            oneOf: [
              {
                type: "array",
                items: {
                  type: "string"
                }
              },
              {
                type: "string"
              },
              {
                type: "boolean"
              }
            ]
          }
        },
        target: {
          type: "string",
          description: "The id of the sequence containing graft content"
        },
        sequence: {
          description: "The sequence containing graft content",
          $ref: "./sequence_structure.json"
        },
        preview_text: {
          description: "An optional field to provide some kind of printable label for a graft",
          type: "string"
        },
        new: {
          type: "boolean",
          description: "If present and true, is interpreted as a request for the server to create a new graft"
        },
        content: {
          type: "array",
          description: "Nested content within the content element",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          description: "Non-Scripture content related to the content element, such as checking data or related resources",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./contentElement_structure.json"
              }
            ]
          }
        },
        hooks: {
          type: "array",
          $ref: "./hook_structure.json"
        }
      },
      required: [
        "type"
      ],
      additionalProperties: false
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/hooks_structure.json
var require_hooks_structure = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/structure/0_3_0/hooks_structure.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/structure/0_3_0/hook_structure.json",
      title: "Hook (Structure)",
      description: "Hooks, ie typed labels that may be used to link documents",
      type: "array",
      items: {
        type: "array",
        items: [
          {
            type: "string",
            oneOf: [
              { enum: [
                "bcv_ref",
                "book_ref"
              ] },
              { pattern: "^x-(app|publisher)-[a-z][a-z0-9]+-\\S{2,256}$" },
              { pattern: "^x-local-\\S{2,256}$" }
            ]
          },
          {
            type: "string",
            oneOf: [
              { enum: [
                "label"
              ] },
              { pattern: "^\\w{1,255}$" }
            ]
          }
        ],
        minItems: 2,
        maxItems: 2
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_document_constraint.json
var require_perf_document_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_document_constraint.json"(exports, module) {
    module.exports = {
      $comment: "version 0.3.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/perf_document_constraint.json",
      type: "object",
      properties: {
        hooks: {
          type: "array"
        },
        sequences: {
          type: "object",
          propertyNames: {
            pattern: "^\\S+$"
          },
          additionalProperties: {
            $ref: "./perf_sequence_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_sequence_constraint.json
var require_perf_sequence_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_sequence_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/perf_sequence_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "main",
            "introduction",
            "intro_title",
            "intro_end_title",
            "title",
            "end_title",
            "heading",
            "remark",
            "sidebar",
            "table",
            "tree",
            "kv",
            "footnote",
            "note_caller",
            "xref",
            "pub_number",
            "alt_number",
            "esb_cat",
            "fig",
            "temp"
          ]
        },
        blocks: {
          type: "array",
          items: {
            $ref: "./perf_block_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_block_constraint.json
var require_perf_block_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_block_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/perf_block_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "paragraph",
            "graft",
            "row",
            "node",
            "lookup"
          ]
        },
        content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./perf_contentElement_constraint.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./perf_contentElement_constraint.json"
              }
            ]
          }
        }
      },
      if: {
        properties: {
          type: {
            enum: [
              "graft"
            ]
          }
        }
      },
      then: {
        properties: {
          subtype: {
            enum: [
              "introduction",
              "intro_title",
              "Intro_end_title",
              "title",
              "end_title",
              "heading",
              "remark",
              "sidebar",
              "table",
              "tree",
              "kv"
            ]
          }
        }
      },
      else: {
        if: {
          properties: {
            type: {
              enum: ["row"]
            }
          }
        },
        then: {
          properties: {
            subtype: {
              type: "string",
              oneOf: [
                {
                  enum: [
                    "row:heading",
                    "row:body"
                  ]
                }
              ]
            }
          }
        },
        else: {
          if: {
            properties: {
              type: { enum: ["node"] }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  { enum: ["node"] },
                  {
                    pattern: "^x-\\S{1,256}$"
                  }
                ]
              },
              atts: {
                type: "object",
                properties: {
                  id: {
                    type: "string"
                  },
                  parent: {
                    type: "string"
                  },
                  children: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                },
                required: [
                  "id"
                ],
                additionalProperties: false
              }
            }
          },
          else: {
            if: {
              properties: {
                type: { enum: ["lookup"] }
              }
            },
            then: {
              properties: {
                subtype: {
                  type: "string",
                  oneOf: [
                    { enum: ["lookup"] },
                    {
                      pattern: "^x-\\S{1,256}$"
                    }
                  ]
                },
                atts: {
                  type: "object",
                  properties: {
                    primary: {
                      type: "string"
                    },
                    secondary: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  },
                  required: [
                    "primary"
                  ],
                  additionalProperties: false
                }
              }
            },
            else: {
              properties: {
                subtype: {
                  type: "string",
                  oneOf: [
                    {
                      pattern: "^usfm:"
                    },
                    {
                      pattern: "^x-\\S{1,256}$"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_contentElement_constraint.json
var require_perf_contentElement_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/perf_contentElement_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/perf_contentElement_constraint.json",
      type: "object",
      allOf: [
        {
          properties: {
            content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./perf_contentElement_constraint.json"
                  }
                ]
              }
            },
            meta_content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./perf_contentElement_constraint.json"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "graft"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                enum: [
                  "footnote",
                  "xref",
                  "note_caller"
                ]
              }
            },
            allOf: [
              {
                not: {
                  required: [
                    "content"
                  ]
                }
              },
              {
                not: {
                  required: [
                    "meta_content"
                  ]
                }
              }
            ],
            if: {
              required: [
                "new"
              ],
              properties: {
                new: {
                  enum: [
                    true
                  ]
                }
              }
            },
            then: {
              not: {
                anyOf: [
                  {
                    required: [
                      "target"
                    ]
                  },
                  {
                    required: [
                      "preview_text"
                    ]
                  }
                ]
              }
            },
            else: {
              required: [
                "target"
              ]
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "mark"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "chapter",
                      "verses",
                      "alt_chapter",
                      "alt_verse",
                      "pub_chapter",
                      "pub_verse"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: [
                    "chapter",
                    "verses"
                  ]
                }
              }
            },
            then: {
              type: "object",
              required: [
                "atts"
              ],
              properties: {
                atts: {
                  type: "object",
                  required: [
                    "number"
                  ],
                  maxProperties: 1
                }
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "wrapper"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "meta_content"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: ["meta_content"]
                }
              }
            },
            then: {
              not: {
                required: ["atts"]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "start_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "end_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            not: {
              required: [
                "atts"
              ]
            }
          }
        }
      ]
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_document_constraint.json
var require_sofria_document_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_document_constraint.json"(exports, module) {
    module.exports = {
      $comment: "version 0.3.0",
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/sofria_document_constraint.json",
      type: "object",
      properties: {
        sequence: {
          $ref: "./sofria_sequence_constraint.json"
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_sequence_constraint.json
var require_sofria_sequence_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_sequence_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/sofria_sequence_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "main",
            "introduction",
            "intro_title",
            "intro_end_title",
            "title",
            "end_title",
            "heading",
            "remark",
            "sidebar",
            "table",
            "tree",
            "kv",
            "footnote",
            "note_caller",
            "xref",
            "pub_number",
            "alt_number",
            "esb_cat",
            "fig",
            "temp"
          ]
        },
        blocks: {
          type: "array",
          items: {
            $ref: "./sofria_block_constraint.json"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_block_constraint.json
var require_sofria_block_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_block_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/sofria_block_constraint.json",
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "paragraph",
            "graft"
          ]
        },
        content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./sofria_contentElement_constraint.json"
              }
            ]
          }
        },
        meta_content: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                $ref: "./sofria_contentElement_constraint.json"
              }
            ]
          }
        }
      },
      if: {
        properties: {
          type: {
            enum: ["graft"]
          }
        }
      },
      then: {
        properties: {
          subtype: {
            enum: [
              "introduction",
              "intro_title",
              "Intro_end_title",
              "title",
              "end_title",
              "heading",
              "remark",
              "sidebar",
              "table",
              "tree",
              "kv"
            ]
          }
        }
      },
      else: {
        properties: {
          subtype: {
            type: "string",
            pattern: "^usfm:"
          }
        }
      }
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_contentElement_constraint.json
var require_sofria_contentElement_constraint2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/schema/constraint/0_3_0/sofria_contentElement_constraint.json"(exports, module) {
    module.exports = {
      $id: "https://github.com/Proskomma/proskomma-json-tools/tree/main/src/schema/constraint/0_3_0/sofria_contentElement_constraint.json",
      type: "object",
      allOf: [
        {
          properties: {
            content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./sofria_contentElement_constraint.json"
                  }
                ]
              }
            },
            meta_content: {
              type: "array",
              items: {
                oneOf: [
                  {
                    type: "string"
                  },
                  {
                    $ref: "./sofria_contentElement_constraint.json"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "graft"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                enum: [
                  "footnote",
                  "xref",
                  "note_caller"
                ]
              }
            },
            allOf: [
              {
                not: {
                  required: [
                    "content"
                  ]
                }
              },
              {
                not: {
                  required: [
                    "meta_content"
                  ]
                }
              }
            ],
            if: {
              required: [
                "new"
              ],
              properties: {
                new: {
                  enum: [
                    true
                  ]
                }
              }
            },
            then: {
              not: {
                anyOf: [
                  {
                    required: [
                      "blocks"
                    ]
                  },
                  {
                    required: [
                      "preview_text"
                    ]
                  }
                ]
              }
            },
            else: {
              required: [
                "sequence"
              ]
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "mark"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "chapter_label",
                      "verses_label",
                      "alt_chapter",
                      "alt_verse",
                      "pub_chapter",
                      "pub_verse"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: [
                    "chapter",
                    "verses"
                  ]
                }
              }
            },
            then: {
              type: "object",
              required: [
                "atts"
              ],
              properties: {
                atts: {
                  type: "object",
                  required: [
                    "number"
                  ],
                  maxProperties: 1
                }
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "wrapper"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    enum: [
                      "meta_content",
                      "chapter",
                      "verses"
                    ]
                  },
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            if: {
              properties: {
                subtype: {
                  enum: ["meta_content"]
                }
              }
            },
            then: {
              not: {
                required: ["atts"]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "start_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            }
          }
        },
        {
          if: {
            properties: {
              type: {
                enum: [
                  "end_milestone"
                ]
              }
            }
          },
          then: {
            properties: {
              subtype: {
                type: "string",
                oneOf: [
                  {
                    pattern: "^[A-Za-z][A-Za-z0-9]*:\\S+$"
                  },
                  {
                    pattern: "^x-\\S+$"
                  }
                ]
              }
            },
            not: {
              required: [
                "atts"
              ]
            }
          }
        }
      ]
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/validator.js
var require_validator = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/validator.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Ajv = require_ajv();
    var succinctSchema_0_2_0 = require_proskomma_succinct();
    var documentStructureSchema_0_2_1 = require_document_structure();
    var sequenceStructureSchema_0_2_1 = require_sequence_structure();
    var blockStructureSchema_0_2_1 = require_block_structure();
    var contentElementStructureSchema_0_2_1 = require_contentElement_structure();
    var perfDocumentConstraintSchema_0_2_1 = require_perf_document_constraint();
    var perfSequenceConstraintSchema_0_2_1 = require_perf_sequence_constraint();
    var perfBlockConstraintSchema_0_2_1 = require_perf_block_constraint();
    var perfContentElementConstraintSchema_0_2_1 = require_perf_contentElement_constraint();
    var sofriaDocumentConstraintSchema_0_2_1 = require_sofria_document_constraint();
    var sofriaSequenceConstraintSchema_0_2_1 = require_sofria_sequence_constraint();
    var sofriaBlockConstraintSchema_0_2_1 = require_sofria_block_constraint();
    var sofriaContentElementConstraintSchema_0_2_1 = require_sofria_contentElement_constraint();
    var documentStructureSchema_0_3_0 = require_document_structure2();
    var sequenceStructureSchema_0_3_0 = require_sequence_structure2();
    var blockStructureSchema_0_3_0 = require_block_structure2();
    var contentElementStructureSchema_0_3_0 = require_contentElement_structure2();
    var hookStructureSchema_0_3_0 = require_hooks_structure();
    var perfDocumentConstraintSchema_0_3_0 = require_perf_document_constraint2();
    var perfSequenceConstraintSchema_0_3_0 = require_perf_sequence_constraint2();
    var perfBlockConstraintSchema_0_3_0 = require_perf_block_constraint2();
    var perfContentElementConstraintSchema_0_3_0 = require_perf_contentElement_constraint2();
    var sofriaDocumentConstraintSchema_0_3_0 = require_sofria_document_constraint2();
    var sofriaSequenceConstraintSchema_0_3_0 = require_sofria_sequence_constraint2();
    var sofriaBlockConstraintSchema_0_3_0 = require_sofria_block_constraint2();
    var sofriaContentElementConstraintSchema_0_3_0 = require_sofria_contentElement_constraint2();
    var Validator = class {
      constructor() {
        this.schema = {
          structure: {},
          constraint: {},
          proskomma: {}
        };
        for (var [key, schemaOb] of [["succinct", {
          "0.2.0": [{
            "name": "Proskomma Serialized Succinct",
            "validator": new Ajv().compile(succinctSchema_0_2_0)
          }]
        }]]) {
          this.schema.proskomma[key] = schemaOb;
        }
        for (var [_key, _schemaOb] of [["document", {
          "0.2.1": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).addSchema(sequenceStructureSchema_0_2_1).compile(documentStructureSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).addSchema(sequenceStructureSchema_0_3_0).compile(documentStructureSchema_0_3_0)
          }]
        }], ["sequence", {
          "0.2.1": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).compile(sequenceStructureSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).compile(sequenceStructureSchema_0_3_0)
          }]
        }]]) {
          this.schema.structure[_key] = _schemaOb;
        }
        for (var [_key2, _schemaOb2] of [["perfDocument", {
          "0.2.1": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).addSchema(sequenceStructureSchema_0_2_1).compile(documentStructureSchema_0_2_1)
          }, {
            "name": "PERF Document",
            "validator": new Ajv().addSchema(perfContentElementConstraintSchema_0_2_1).addSchema(perfBlockConstraintSchema_0_2_1).addSchema(perfSequenceConstraintSchema_0_2_1).compile(perfDocumentConstraintSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).addSchema(sequenceStructureSchema_0_3_0).compile(documentStructureSchema_0_3_0)
          }, {
            "name": "PERF Document",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(perfContentElementConstraintSchema_0_3_0).addSchema(perfBlockConstraintSchema_0_3_0).addSchema(perfSequenceConstraintSchema_0_3_0).compile(perfDocumentConstraintSchema_0_3_0)
          }]
        }], ["perfSequence", {
          "0.2.1": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).compile(sequenceStructureSchema_0_2_1)
          }, {
            "name": "PERF Sequence",
            "validator": new Ajv().addSchema(perfContentElementConstraintSchema_0_2_1).addSchema(perfBlockConstraintSchema_0_2_1).compile(perfSequenceConstraintSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).compile(sequenceStructureSchema_0_3_0)
          }, {
            "name": "PERF Sequence",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(perfContentElementConstraintSchema_0_3_0).addSchema(perfBlockConstraintSchema_0_3_0).compile(perfSequenceConstraintSchema_0_3_0)
          }]
        }], ["sofriaDocument", {
          "0.2.1": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).addSchema(sequenceStructureSchema_0_2_1).compile(documentStructureSchema_0_2_1)
          }, {
            "name": "SOFRIA Document",
            "validator": new Ajv().addSchema(sofriaContentElementConstraintSchema_0_2_1).addSchema(sofriaBlockConstraintSchema_0_2_1).addSchema(sofriaSequenceConstraintSchema_0_2_1).compile(sofriaDocumentConstraintSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Document Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).addSchema(sequenceStructureSchema_0_3_0).compile(documentStructureSchema_0_3_0)
          }, {
            "name": "SOFRIA Document",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(sofriaContentElementConstraintSchema_0_3_0).addSchema(sofriaBlockConstraintSchema_0_3_0).addSchema(sofriaSequenceConstraintSchema_0_3_0).compile(sofriaDocumentConstraintSchema_0_3_0)
          }]
        }], ["sofriaSequence", {
          "0.2.1": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(contentElementStructureSchema_0_2_1).addSchema(blockStructureSchema_0_2_1).compile(sequenceStructureSchema_0_2_1)
          }, {
            "name": "SOFRIA Sequence",
            "validator": new Ajv().addSchema(sofriaContentElementConstraintSchema_0_2_1).addSchema(sofriaBlockConstraintSchema_0_2_1).compile(sofriaSequenceConstraintSchema_0_2_1)
          }],
          "0.3.0": [{
            "name": "Sequence Structure",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(contentElementStructureSchema_0_3_0).addSchema(blockStructureSchema_0_3_0).compile(sequenceStructureSchema_0_3_0)
          }, {
            "name": "SOFRIA Sequence",
            "validator": new Ajv().addSchema(hookStructureSchema_0_3_0).addSchema(sofriaContentElementConstraintSchema_0_3_0).addSchema(sofriaBlockConstraintSchema_0_3_0).compile(sofriaSequenceConstraintSchema_0_3_0)
          }]
        }]]) {
          this.schema.constraint[_key2] = _schemaOb2;
        }
      }
      schemaInfo() {
        var ret = {};
        for (var [schemaType, schemas] of Object.entries(this.schema)) {
          ret[schemaType] = {};
          for (var [schemaLabel, schemaVersions] of Object.entries(schemas)) {
            ret[schemaType][schemaLabel] = {};
            for (var [version3, versionSteps] of Object.entries(schemaVersions)) {
              ret[schemaType][schemaLabel][version3] = versionSteps.map((vs) => vs.name);
            }
          }
        }
        return ret;
      }
      validate(schemaType, schemaKey, schemaVersion, data) {
        if (data === void 0) {
          throw new Error("data argument is missing. Usage: validate(schemaType, schemaKey, schemaVersion, data)");
        }
        if (data === null) {
          throw new Error("Data argument is null");
        }
        var knownSchemaTypes = Object.keys(this.schema);
        if (!knownSchemaTypes.includes(schemaType)) {
          throw new Error("Schema type must be one of ".concat(knownSchemaTypes.map((s) => "'".concat(s, "'")).join(", "), ", not '").concat(schemaType, "'"));
        }
        if (!this.schema[schemaType][schemaKey]) {
          throw new Error("Unknown ".concat(schemaType, " schema key ").concat(schemaKey));
        }
        if (!this.schema[schemaType][schemaKey][schemaVersion]) {
          throw new Error("Unknown version ".concat(schemaVersion, " for ").concat(schemaType, " schema key ").concat(schemaKey));
        }
        var validators = this.schema[schemaType][schemaKey][schemaVersion];
        var result;
        for (var {
          name: validatorName,
          validator
        } of validators) {
          result = {
            validatorName,
            isValid: validator(data),
            errors: validator.errors
          };
          if (!result.isValid) {
            break;
          }
        }
        return {
          requested: {
            schemaType,
            schemaKey,
            schemaVersion
          },
          lastSchema: result.validatorName,
          isValid: result.isValid,
          errors: result.errors
        };
      }
    };
    module.exports = Validator;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/usfmHelps.js
var require_usfmHelps = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/usfmHelps.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var characterTags = ["qs", "qac", "litl", "lik", "liv", "fr", "fq", "fqa", "fk", "fl", "fw", "fp", "fv", "ft", "fdc", "fm", "xo", "xk", "xq", "xt", "xta", "xop", "xot", "xnt", "xdc", "rq", "add", "bk", "dc", "k", "nd", "ord", "pn", "png", "qt", "sig", "sls", "tl", "wj", "em", "bd", "it", "bdit", "no", "sc", "sup", "ior", "iqt", "th", "thr", "tc", "tcr"];
    var headingTags = ["ms", "mr", "s", "sr", "r", "qa", "sp", "sd"];
    var bodyTags = ["cd", "p", "m", "po", "pr", "cls", "pmo", "pm", "pmc", "pmr", "pi", "mi", "nb", "pc", "ph", "b", "q", "qr", "qc", "qa", "qm", "qd", "lh", "li", "lf", "lim", "d"];
    var introHeadingTags = ["imt", "is", "imte"];
    var introBodyTags = ["ip", "ipi", "im", "imi", "ipq", "imq", "ipr", "iq", "ib", "ili", "iot", "io", "iex"];
    module.exports = {
      characterTags,
      bodyTags,
      headingTags,
      introHeadingTags,
      introBodyTags
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/verseWords.js
var require_verseWords = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/verseWords.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _xregexp = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var verseWordsActions = {
      startDocument: [{
        description: "Set up storage",
        test: () => true,
        action: (_ref) => {
          var {
            workspace,
            output
          } = _ref;
          workspace.verseContent = [];
          workspace.chapter = null;
          workspace.verses = null;
          output.cv = {};
        }
      }],
      mark: [{
        description: "Update CV state",
        test: () => true,
        action: (_ref2) => {
          var {
            context,
            workspace,
            output
          } = _ref2;
          var {
            element
          } = context.sequences[0];
          if (element.subType === "chapter") {
            workspace.chapter = element.atts["number"];
            workspace.verses = 0;
            output.cv[workspace.chapter] = {};
            output.cv[workspace.chapter][workspace.verses] = {};
          } else if (element.subType === "verses") {
            workspace.verses = element.atts["number"];
            output.cv[workspace.chapter][workspace.verses] = {};
          }
        }
      }],
      text: [{
        description: "Log occurrences",
        test: () => true,
        action: (_ref3) => {
          var {
            context,
            workspace,
            output
          } = _ref3;
          var {
            chapter,
            verses
          } = workspace;
          var {
            text
          } = context.sequences[0].element;
          var re = (0, _xregexp.default)("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})");
          var words = _xregexp.default.match(text, re, "all");
          for (var word of words) {
            var _output$cv$chapter$ve, _output$cv$chapter$ve2;
            (_output$cv$chapter$ve2 = (_output$cv$chapter$ve = output.cv[chapter][verses])[word]) !== null && _output$cv$chapter$ve2 !== void 0 ? _output$cv$chapter$ve2 : _output$cv$chapter$ve[word] = 0;
            output.cv[chapter][verses][word] += 1;
          }
        }
      }]
    };
    module.exports = {
      verseWordsActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/stripAlignment.js
var require_stripAlignment = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/stripAlignment.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _xregexp = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var stripMarkupActions = {
      startDocument: [{
        description: "Set up",
        test: () => true,
        action: (_ref) => {
          var {
            workspace,
            output
          } = _ref;
          workspace.chapter = null;
          workspace.verses = null;
          workspace.lastWord = "";
          workspace.waitingMarkup = [];
          workspace.currentOccurrences = {};
          workspace.PendingStartMilestones = [];
          output.stripped = {};
          output.unalignedWords = {};
          return true;
        }
      }],
      startMilestone: [{
        description: "Ignore zaln startMilestone events",
        test: (_ref2) => {
          var {
            context
          } = _ref2;
          return context.sequences[0].element.subType === "usfm:zaln";
        },
        action: (_ref3) => {
          var {
            context,
            workspace
          } = _ref3;
          var payload = context.sequences[0].element;
          payload.subtype = payload.subType;
          delete payload.subType;
          workspace.waitingMarkup.push(payload);
          workspace.PendingStartMilestones.push(payload);
        }
      }],
      endMilestone: [{
        description: "Ignore zaln endMilestone events",
        test: (_ref4) => {
          var {
            context
          } = _ref4;
          return context.sequences[0].element.subType === "usfm:zaln";
        },
        action: (_ref5) => {
          var {
            context,
            workspace,
            output,
            config: config2
          } = _ref5;
          var {
            chapter,
            verses,
            lastWord: word
          } = workspace;
          var {
            verseWords: totalOccurrences
          } = config2;
          var strippedKey = ["after", word, workspace.currentOccurrences[word], totalOccurrences[chapter][verses][word]].join("--");
          var payload = _objectSpread({}, context.sequences[0].element);
          payload.subtype = payload.subType;
          delete payload.subType;
          var record = {
            chapter,
            verses,
            occurrence: workspace.currentOccurrences[word],
            occurrences: totalOccurrences[chapter][verses][word],
            position: "after",
            word,
            payload,
            startMilestone: workspace.PendingStartMilestones.shift()
          };
          if (!output.stripped[workspace.chapter][workspace.verses][strippedKey]) {
            output.stripped[workspace.chapter][workspace.verses][strippedKey] = [record];
          } else {
            output.stripped[workspace.chapter][workspace.verses][strippedKey].push(record);
          }
          return false;
        }
      }],
      startWrapper: [{
        description: "Ignore w startWrapper events",
        test: (_ref6) => {
          var {
            context
          } = _ref6;
          return context.sequences[0].element.subType === "usfm:w";
        },
        action: (_ref7) => {
          var {
            context,
            workspace
          } = _ref7;
          var payload = _objectSpread({}, context.sequences[0].element);
          payload.subtype = payload.subType;
          delete payload.subType;
          workspace.waitingMarkup.push(payload);
        }
      }],
      endWrapper: [{
        description: "Ignore w endWrapper events",
        test: (_ref8) => {
          var {
            context
          } = _ref8;
          return context.sequences[0].element.subType === "usfm:w";
        },
        action: (_ref9) => {
          var {
            context
          } = _ref9;
        }
      }],
      text: [{
        description: "Log occurrences",
        test: () => true,
        action: (_ref10) => {
          var {
            context,
            workspace,
            output,
            config: config2
          } = _ref10;
          try {
            var sequence = context.sequences[0];
            if (sequence.type !== "main")
              return true;
            var text = sequence.element.text;
            var re = (0, _xregexp.default)("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})");
            var words = _xregexp.default.match(text, re, "all");
            var {
              chapter,
              verses
            } = workspace;
            var {
              verseWords: totalOccurrences
            } = config2;
            for (var word of words) {
              var _workspace$currentOcc, _workspace$currentOcc2;
              (_workspace$currentOcc2 = (_workspace$currentOcc = workspace.currentOccurrences)[word]) !== null && _workspace$currentOcc2 !== void 0 ? _workspace$currentOcc2 : _workspace$currentOcc[word] = 0;
              workspace.currentOccurrences[word]++;
              if (!workspace.PendingStartMilestones.length && workspace.waitingMarkup.length) {
                var _output$unalignedWord, _output$unalignedWord2, _output$unalignedWord3, _output$unalignedWord4;
                (_output$unalignedWord2 = (_output$unalignedWord = output.unalignedWords)[chapter]) !== null && _output$unalignedWord2 !== void 0 ? _output$unalignedWord2 : _output$unalignedWord[chapter] = {};
                (_output$unalignedWord4 = (_output$unalignedWord3 = output.unalignedWords[chapter])[verses]) !== null && _output$unalignedWord4 !== void 0 ? _output$unalignedWord4 : _output$unalignedWord3[verses] = [];
                output.unalignedWords[chapter][verses].push({
                  word,
                  occurrence: workspace.currentOccurrences[word],
                  totalOccurrences: totalOccurrences[chapter][verses][word]
                });
              }
              while (workspace.waitingMarkup.length) {
                var payload = workspace.waitingMarkup.shift();
                var strippedKey = ["before", word, workspace.currentOccurrences[word], totalOccurrences[chapter][verses][word]].join("--");
                var record = {
                  chapter,
                  verses,
                  occurrence: workspace.currentOccurrences[word],
                  occurrences: totalOccurrences[chapter][verses][word],
                  position: "before",
                  word,
                  payload: _objectSpread(_objectSpread({}, payload), payload.subtype === "usfm:w" && {
                    content: [word]
                  })
                };
                if (!output.stripped[workspace.chapter][workspace.verses][strippedKey]) {
                  output.stripped[workspace.chapter][workspace.verses][strippedKey] = [record];
                } else {
                  output.stripped[workspace.chapter][workspace.verses][strippedKey].push(record);
                }
              }
              workspace.lastWord = word;
            }
          } catch (err) {
            console.error(err);
            throw err;
          }
          return true;
        }
      }],
      mark: [{
        description: "Update CV state",
        test: () => true,
        action: (_ref11) => {
          var {
            context,
            workspace,
            output
          } = _ref11;
          try {
            var element = context.sequences[0].element;
            if (element.subType === "chapter") {
              workspace.chapter = element.atts["number"];
              workspace.verses = 0;
              workspace.lastWord = "";
              workspace.currentOccurrences = {};
              output.stripped[workspace.chapter] = {};
              output.stripped[workspace.chapter][workspace.verses] = {};
            } else if (element.subType === "verses") {
              workspace.verses = element.atts["number"];
              workspace.lastWord = "";
              workspace.currentOccurrences = {};
              output.stripped[workspace.chapter][workspace.verses] = {};
            }
          } catch (err) {
            console.error(err);
            throw err;
          }
          return true;
        }
      }]
    };
    module.exports = {
      stripMarkupActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/mergeAlignement.js
var require_mergeAlignement = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/mergeAlignement.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _xregexp = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lexingRegexes2 = [["printable", "wordLike", (0, _xregexp.default)("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})")], ["printable", "lineSpace", (0, _xregexp.default)("([\\p{Separator}	]{1,127})")], ["printable", "punctuation", (0, _xregexp.default)("([\\p{Punctuation}\\p{Math_Symbol}\\p{Currency_Symbol}\\p{Modifier_Symbol}\\p{Other_Symbol}])")], ["bad", "unknown", (0, _xregexp.default)("(.)")]];
    var re = _xregexp.default.union(lexingRegexes2.map((x) => x[2]));
    var endMilestone = {
      type: "end_milestone",
      subtype: "usfm:zaln"
    };
    var mergeAlignmentActions = {
      startDocument: [{
        description: "setup",
        test: () => true,
        action: (_ref) => {
          var {
            workspace,
            output
          } = _ref;
          workspace.chapter = null;
          workspace.verses = null;
          workspace.currentOccurrences = {};
          output.unalignedWords = {};
          return true;
        }
      }],
      text: [{
        description: "add-to-text",
        test: () => true,
        action: (_ref2) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref2;
          try {
            let pushOnHoldChars = function() {
              while (onHoldChars.length) {
                workspace.outputContentStack[0].push(onHoldChars.shift());
              }
            };
            var sequence = context.sequences[0];
            if (sequence.type !== "main")
              return true;
            var text = context.sequences[0].element.text;
            var words = _xregexp.default.match(text, re, "all");
            var {
              chapter,
              verses
            } = workspace;
            if (!verses)
              return true;
            var {
              totalOccurrences,
              strippedAlignment
            } = config2;
            var alignments = {
              opened: null
            };
            var addWrappers = (_ref3) => {
              var {
                subtype,
                content = [],
                atts = {}
              } = _ref3;
              if (Object.keys(atts).length > 0) {
                return {
                  type: "wrapper",
                  subtype,
                  content,
                  atts
                };
              }
              return {
                type: "wrapper",
                subtype,
                content
              };
            };
            var onHoldChars = [];
            var _loop = function _loop2(word2) {
              var _xre$match, _workspace$currentOcc, _workspace$currentOcc2;
              var isWord = (_xre$match = _xregexp.default.match(word2, lexingRegexes2[0][2], "all")) === null || _xre$match === void 0 ? void 0 : _xre$match.length;
              if (!isWord) {
                onHoldChars.push(word2);
                return "continue";
              }
              (_workspace$currentOcc2 = (_workspace$currentOcc = workspace.currentOccurrences)[word2]) !== null && _workspace$currentOcc2 !== void 0 ? _workspace$currentOcc2 : _workspace$currentOcc[word2] = 0;
              workspace.currentOccurrences[word2]++;
              var strippedKey = (position) => [position, word2, workspace.currentOccurrences[word2], totalOccurrences[chapter][verses][word2]].join("--");
              var markup = strippedAlignment[chapter][verses];
              var skipStartMilestone = false;
              var afterWord = markup[strippedKey("after")];
              var beforeWord = markup[strippedKey("before")];
              if (beforeWord !== null && beforeWord !== void 0 && beforeWord.length)
                pushOnHoldChars();
              if (afterWord !== null && afterWord !== void 0 && afterWord.length && !alignments.opened) {
                afterWord.map((_ref4) => {
                  var {
                    startMilestone
                  } = _ref4;
                  return workspace.outputContentStack[0].push(startMilestone);
                });
                skipStartMilestone = true;
              }
              beforeWord === null || beforeWord === void 0 ? void 0 : beforeWord.forEach((_ref5) => {
                var {
                  payload
                } = _ref5;
                if (payload.type !== "start_milestone") {
                  workspace.outputContentStack[0].push(payload);
                }
                if (payload.type === "start_milestone" && !skipStartMilestone) {
                  workspace.outputContentStack[0].push(payload);
                  alignments.opened = true;
                }
              });
              afterWord === null || afterWord === void 0 ? void 0 : afterWord.forEach((_ref6) => {
                var {
                  payload
                } = _ref6;
                alignments.opened = false;
                workspace.outputContentStack[0].push(payload);
              });
              if (!(beforeWord !== null && beforeWord !== void 0 && beforeWord.length)) {
                var _output$unalignedWord, _output$unalignedWord2, _output$unalignedWord3, _output$unalignedWord4;
                if (alignments.opened) {
                  workspace.outputContentStack[0].push(endMilestone);
                  alignments.opened = false;
                }
                pushOnHoldChars();
                (_output$unalignedWord2 = (_output$unalignedWord = output.unalignedWords)[chapter]) !== null && _output$unalignedWord2 !== void 0 ? _output$unalignedWord2 : _output$unalignedWord[chapter] = {};
                (_output$unalignedWord4 = (_output$unalignedWord3 = output.unalignedWords[chapter])[verses]) !== null && _output$unalignedWord4 !== void 0 ? _output$unalignedWord4 : _output$unalignedWord3[verses] = [];
                output.unalignedWords[workspace.chapter][workspace.verses].push({
                  word: word2,
                  occurrence: workspace.currentOccurrences[word2],
                  totalOccurrences: totalOccurrences[chapter][verses][word2]
                });
                var wrappedWord = addWrappers({
                  subtype: "usfm:w",
                  content: [word2]
                });
                workspace.outputContentStack[0].push(wrappedWord);
              }
            };
            for (var word of words) {
              var _ret = _loop(word);
              if (_ret === "continue")
                continue;
            }
            pushOnHoldChars();
            return false;
          } catch (err) {
            console.error(err);
            throw err;
          }
        }
      }],
      mark: [{
        description: "mark-chapters",
        test: (_ref7) => {
          var {
            context
          } = _ref7;
          return context.sequences[0].element.subType === "chapter";
        },
        action: (_ref8) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref8;
          var element = context.sequences[0].element;
          workspace.chapter = element.atts["number"];
          workspace.verses = 0;
          return true;
        }
      }, {
        description: "mark-verses",
        test: (_ref9) => {
          var {
            context
          } = _ref9;
          return context.sequences[0].element.subType === "verses";
        },
        action: (_ref10) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref10;
          var element = context.sequences[0].element;
          workspace.verses = element.atts["number"];
          workspace.currentOccurrences = {};
          return true;
        }
      }]
    };
    module.exports = {
      mergeAlignmentActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/index.js
var require_renderActions = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/renderActions/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      verseWordsActions
    } = require_verseWords();
    var {
      stripMarkupActions
    } = require_stripAlignment();
    var {
      mergeAlignmentActions
    } = require_mergeAlignement();
    module.exports = {
      verseWordsActions,
      stripMarkupActions,
      mergeAlignmentActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/ProskommaRenderAction.js
var require_ProskommaRenderAction = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/ProskommaRenderAction.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var ProskommaRenderAction = class {
      constructor(ob) {
        if (!ob) {
          throw new Error("Must provide a constructor object to constructor");
        }
        this.description = ob.description || function(e) {
          throw e;
        }(new Error("Must provide a description in constructor object"));
        this.test = ob.test || (() => true);
        this.action = ob.action || (() => null);
      }
    };
    module.exports = ProskommaRenderAction;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/ProskommaRender.js
var require_ProskommaRender = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/ProskommaRender.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var ProskommaRenderAction = require_ProskommaRenderAction();
    var ProskommaRender = class {
      constructor(spec) {
        if (this.constructor === ProskommaRender) {
          throw new Error("Abstract class ProskommaRender cannot be instantiated - make as subclass!");
        }
        var actions = spec.actions || {};
        this.debugLevel = spec.debugLevel || 0;
        this.actions = {};
        for (var event of ["startDocument", "endDocument", "startSequence", "endSequence", "unresolvedBlockGraft", "blockGraft", "startParagraph", "endParagraph", "metaContent", "mark", "unresolvedInlineGraft", "inlineGraft", "startWrapper", "endWrapper", "startMilestone", "endMilestone", "text"]) {
          if (actions[event]) {
            this.actions[event] = actions[event].map((a) => new ProskommaRenderAction(a));
          } else {
            this.actions[event] = [];
          }
        }
      }
      addRenderActionObject(event, actionOb) {
        if (!this.actions[event]) {
          throw new Error("Unknown event '".concat(event));
        }
        this.actions[event].push(actionOb);
      }
      addRenderAction(event, actionSpec) {
        this.addRenderActionObject(event, new ProskommaRenderAction(actionSpec));
      }
      describeRenderActions(event) {
        if (!this.actions[event]) {
          throw new Error("Unknown event '".concat(event));
        }
        var ret = ["**Actions for ".concat(event, "**\n")];
        for (var actionOb of this.actions[event]) {
          ret.push("IF ".concat(actionOb.test.toString(), ":"));
          ret.push("    DO ".concat(actionOb.description));
        }
        return ret.join("\n");
      }
      renderDocument(_ref) {
        var {
          docId,
          config: config2,
          output
        } = _ref;
        var context = {};
        var workspace = {};
        this.renderDocument1({
          docId,
          config: config2,
          context,
          workspace,
          output
        });
        return output;
      }
      renderDocument1(_ref2) {
        var {
          docId,
          config: config2,
          context,
          workspace,
          output
        } = _ref2;
        throw new Error("Define renderDocument1() in subclass");
      }
      // renderEnvironment => {config, context, workspace, output}
      renderEvent(event, renderEnvironment) {
        var context = renderEnvironment.context;
        if (this.debugLevel > 1) {
          console.log("".concat("    ".repeat(context.sequences.length), "EVENT ").concat(event));
        }
        if (!this.actions[event]) {
          throw new Error("Unknown event '".concat(event));
        }
        var found = false;
        for (var actionOb of this.actions[event]) {
          var testResult = false;
          try {
            testResult = actionOb.test(renderEnvironment);
          } catch (err) {
            var msg = "Exception from test of action '".concat(actionOb.description, "' for event ").concat(event, " in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: ").concat(err);
            throw new Error(msg);
          }
          if (testResult) {
            found = true;
            if (this.debugLevel > 0) {
              console.log("".concat("    ".repeat(context.sequences.length), "    ").concat(event, " action: ").concat(actionOb.description));
            }
            var actionResult = false;
            try {
              actionResult = actionOb.action(renderEnvironment);
            } catch (err) {
              throw new Error("Exception from action '".concat(actionOb.description, "' for event ").concat(event, " in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: ").concat(err));
            }
            if (!actionResult) {
              break;
            }
          }
        }
        if (["unresolvedBlockGraft", "unresolvedInlineGraft"].includes(event) && this.actions[event].length === 0) {
          throw new Error("No action for ".concat(event, " graft event in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: add an action or fix your data!"));
        }
        if (!found && this.debugLevel > 1) {
          console.log("".concat("    ".repeat(context.sequences.length), "    No matching action"));
        }
      }
    };
    module.exports = ProskommaRender;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/PerfRenderFromJson.js
var require_PerfRenderFromJson = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/PerfRenderFromJson.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var ProskommaRender = require_ProskommaRender();
    var PerfRenderFromJson2 = class extends ProskommaRender {
      constructor(spec) {
        super(spec);
        if (!spec.srcJson) {
          throw new Error("Must provide srcJson");
        }
        this.srcJson = spec.srcJson;
      }
      renderDocument1(_ref) {
        var {
          docId,
          config: config2,
          context,
          workspace,
          output
        } = _ref;
        var environment = {
          config: config2,
          context,
          workspace,
          output
        };
        context.renderer = this;
        context.document = {
          id: docId,
          schema: this.srcJson.schema,
          metadata: this.srcJson.metadata,
          mainSequenceId: this.srcJson.main_sequence_id,
          nSequences: Object.keys(this.srcJson.sequences).length
        };
        context.sequences = [];
        this.renderEvent("startDocument", environment);
        this.renderSequenceId(environment, this.srcJson.main_sequence_id);
        this.renderEvent("endDocument", environment);
      }
      sequenceContext(sequence, sequenceId) {
        return {
          id: sequenceId,
          type: sequence.type,
          nBlocks: sequence.blocks.length,
          milestones: /* @__PURE__ */ new Set([])
        };
      }
      renderSequenceId(environment, sequenceId) {
        var context = environment.context;
        var sequence = this.srcJson.sequences[sequenceId];
        if (!sequence) {
          throw new Error("Sequence '".concat(sequenceId, "' not found in renderSequenceId()"));
        }
        context.sequences.unshift(this.sequenceContext(sequence, sequenceId));
        this.renderEvent("startSequence", environment);
        for (var [blockN, block2] of sequence.blocks.entries()) {
          context.sequences[0].block = {
            type: block2.type,
            subType: block2.subtype,
            blockN,
            wrappers: []
          };
          if (block2.type === "graft") {
            if (block2.target && !this.srcJson.sequences[block2.target]) {
              context.sequences[0].block.target = block2.target;
              this.renderEvent("unresolvedBlockGraft", environment);
            } else {
              context.sequences[0].block.target = block2.target;
              context.sequences[0].block.isNew = block2.new || false;
              this.renderEvent("blockGraft", environment);
            }
          } else {
            this.renderEvent("startParagraph", environment);
            this.renderContent(block2.content, environment);
            this.renderEvent("endParagraph", environment);
          }
          delete context.sequences[0].block;
        }
        this.renderEvent("endSequence", environment);
        context.sequences.shift();
      }
      renderContent(content, environment) {
        for (var element of content) {
          this.renderElement(element, environment);
        }
      }
      renderElement(element, environment) {
        var maybeRenderMetaContent = (elementContext2) => {
          if (element.meta_content) {
            elementContext2.metaContent = element.meta_content;
            this.renderEvent("metaContent", environment);
          }
        };
        var context = environment.context;
        var elementContext = {
          type: element.type || "text"
        };
        if (element.subtype) {
          elementContext.subType = element.subtype;
        }
        if (element.atts) {
          elementContext.atts = element.atts;
        } else if (elementContext.type !== "end_milestone" && elementContext.type !== "meta_content") {
          elementContext.atts = {};
        }
        if (element.target) {
          elementContext.target = element.target;
        }
        if (element.type === "graft") {
          elementContext.isNew = element.new || false;
        }
        if (elementContext.type === "text") {
          elementContext.text = element;
        }
        context.sequences[0].element = elementContext;
        if (elementContext.type === "text") {
          this.renderEvent("text", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "mark") {
          this.renderEvent("mark", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "start_milestone") {
          this.renderEvent("startMilestone", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "end_milestone") {
          this.renderEvent("endMilestone", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "graft") {
          if (element.target) {
            if (element.target && !this.srcJson.sequences[element.target]) {
              this.renderEvent("unresolvedInlineGraft", environment);
              return;
            }
          }
          this.renderEvent("inlineGraft", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "wrapper") {
          context.sequences[0].block.wrappers.unshift(elementContext.subType);
          this.renderEvent("startWrapper", environment);
          this.renderContent(element.content, environment);
          context.sequences[0].element = elementContext;
          maybeRenderMetaContent(elementContext);
          this.renderEvent("endWrapper", environment);
          context.sequences[0].block.wrappers.shift();
        } else {
          throw new Error("Unexpected element type '".concat(elementContext.type));
        }
        delete context.sequences[0].element;
      }
    };
    module.exports = PerfRenderFromJson2;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/verseWords.js
var require_verseWords2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/verseWords.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      verseWordsActions
    } = require_verseWords();
    var verseWordsCode = function verseWordsCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: verseWordsActions
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return {
        verseWords: output.cv
      };
    };
    var verseWords = {
      name: "verseWords",
      type: "Transform",
      description: "PERF=>JSON: Counts words occurrences",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "verseWords",
        type: "json"
      }],
      code: verseWordsCode
    };
    module.exports = {
      verseWords
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/mergeActions.js
var require_mergeActions = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/mergeActions.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var mergeActions = (actionList) => {
      var ret = {};
      for (var action of actionList) {
        for (var key of Object.keys(action)) {
          if (ret[key]) {
            ret[key].push(...action[key]);
          } else {
            ret[key] = action[key];
          }
        }
      }
      return ret;
    };
    module.exports = mergeActions;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/identity.js
var require_identity = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/identity.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var identityActions = {
      startDocument: [{
        description: "identity",
        test: () => true,
        action: (_ref) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref;
          output.perf = {};
          output.perf.schema = context.document.schema;
          output.perf.metadata = context.document.metadata;
          output.perf.sequences = {};
        }
      }],
      endDocument: [{
        description: "identity",
        test: () => true,
        action: (_ref2) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref2;
        }
      }],
      startSequence: [{
        description: "identity",
        test: () => true,
        action: (_ref3) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref3;
          output.perf.sequences[context.sequences[0].id] = {
            type: context.sequences[0].type,
            blocks: []
          };
          workspace.outputSequence = output.perf.sequences[context.sequences[0].id];
          if (context.sequences[0].type === "main") {
            output.perf.main_sequence_id = context.sequences[0].id;
          }
        }
      }],
      endSequence: [{
        description: "identity",
        test: () => true,
        action: (_ref4) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref4;
          if (context.sequences.length > 1) {
            workspace.outputSequence = output.perf.sequences[context.sequences[1].id];
          }
        }
      }],
      blockGraft: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var currentBlock = environment.context.sequences[0].block;
          var graftRecord = {
            type: currentBlock.type,
            subtype: currentBlock.subType
          };
          if (currentBlock.target) {
            graftRecord.target = currentBlock.target;
            environment.context.renderer.renderSequenceId(environment, graftRecord.target);
          }
          if (currentBlock.isNew) {
            graftRecord.new = currentBlock.isNew;
          }
          environment.workspace.outputSequence.blocks.push(graftRecord);
        }
      }],
      startParagraph: [{
        description: "identity",
        test: () => true,
        action: (_ref5) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref5;
          var currentBlock = context.sequences[0].block;
          var paraRecord = {
            type: currentBlock.type,
            subtype: currentBlock.subType,
            content: []
          };
          workspace.outputSequence.blocks.push(paraRecord);
          workspace.currentContent = paraRecord.content;
          workspace.outputBlock = workspace.outputSequence.blocks[workspace.outputSequence.blocks.length - 1];
          workspace.outputContentStack = [workspace.outputBlock.content];
        }
      }],
      endParagraph: [{
        description: "identity",
        test: () => true,
        action: (_ref6) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref6;
        }
      }],
      metaContent: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = environment;
          var element = context.sequences[0].element;
          workspace.currentContent = element.metaContent;
          var lastOutputItem = workspace.outputContentStack[1][workspace.outputContentStack[1].length - 1];
          lastOutputItem.meta_content = [];
          workspace.outputContentStack.unshift(lastOutputItem.meta_content);
          context.renderer.renderContent(workspace.currentContent, environment);
          workspace.outputContentStack.shift();
        }
      }],
      mark: [{
        description: "identity",
        test: () => true,
        action: (_ref7) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref7;
          var element = context.sequences[0].element;
          var markRecord = {
            type: element.type,
            subtype: element.subType
          };
          if (element.atts && typeof element.atts === "object" && Object.keys(element.atts).length !== 0) {
            markRecord.atts = element.atts;
          }
          workspace.outputContentStack[0].push(markRecord);
        }
      }],
      inlineGraft: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var element = environment.context.sequences[0].element;
          var graftRecord = {
            type: element.type,
            subtype: element.subType
          };
          if (element.target) {
            graftRecord.target = element.target;
            var currentContent = environment.workspace.outputContentStack[0];
            environment.context.renderer.renderSequenceId(environment, element.target);
            environment.workspace.outputContentStack[0] = currentContent;
          }
          if (element.isNew) {
            graftRecord.new = element.isNew;
          }
          environment.workspace.outputContentStack[0].push(graftRecord);
        }
      }],
      startWrapper: [{
        description: "identity",
        test: () => true,
        action: (_ref8) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref8;
          var element = context.sequences[0].element;
          var wrapperRecord = {
            type: element.type,
            subtype: element.subType,
            content: []
          };
          if ("atts" in element && typeof element.atts === "object" && Object.keys(element.atts).length !== 0) {
            wrapperRecord.atts = element.atts;
          }
          workspace.outputContentStack[0].push(wrapperRecord);
          workspace.outputContentStack.unshift(wrapperRecord.content);
        }
      }],
      endWrapper: [{
        description: "identity",
        test: () => true,
        action: (_ref9) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref9;
          workspace.outputContentStack.shift();
        }
      }],
      startMilestone: [{
        description: "identity",
        test: () => true,
        action: (_ref10) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref10;
          var element = context.sequences[0].element;
          var milestoneRecord = {
            type: element.type,
            subtype: element.subType
          };
          if (element.atts && typeof element.atts === "object" && Object.keys(element.atts).length !== 0) {
            milestoneRecord.atts = element.atts;
          }
          workspace.outputContentStack[0].push(milestoneRecord);
        }
      }],
      endMilestone: [{
        description: "identity",
        test: () => true,
        action: (_ref11) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref11;
          var element = context.sequences[0].element;
          var milestoneRecord = {
            type: element.type,
            subtype: element.subType
          };
          workspace.outputContentStack[0].push(milestoneRecord);
        }
      }],
      text: [{
        description: "identity",
        test: () => true,
        action: (_ref12) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref12;
          var element = context.sequences[0].element;
          workspace.outputContentStack[0].push(element.text);
        }
      }]
    };
    module.exports = {
      identityActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/stripAlignment.js
var require_stripAlignment2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/stripAlignment.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    var _mergeActions = _interopRequireDefault(require_mergeActions());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      identityActions
    } = require_identity();
    var {
      stripMarkupActions
    } = require_stripAlignment();
    var stripMarkupCode = function stripMarkupCode2(_ref) {
      var {
        perf,
        verseWords
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: (0, _mergeActions.default)([stripMarkupActions, identityActions])
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {
          verseWords
        },
        output
      });
      return {
        perf: output.perf,
        strippedAlignment: output.stripped,
        unalignedWords: output.unalignedWords
      };
    };
    var stripAlignment = {
      name: "stripAlignment",
      type: "Transform",
      description: "PERF=>PERF: Strips alignment markup",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }, {
        name: "verseWords",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }, {
        name: "strippedAlignment",
        type: "json"
      }, {
        name: "unalignedWords",
        type: "json"
      }],
      code: stripMarkupCode
    };
    module.exports = {
      stripAlignment
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/mergeAlignment.js
var require_mergeAlignment = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/mergeAlignment.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    var _mergeActions = _interopRequireDefault(require_mergeActions());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      identityActions
    } = require_identity();
    var {
      mergeAlignmentActions
    } = require_mergeAlignement();
    var mergeAlignmentCode = function mergeAlignmentCode2(_ref) {
      var {
        perf,
        verseWords: totalOccurrences,
        strippedAlignment
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: (0, _mergeActions.default)([mergeAlignmentActions, identityActions])
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {
          totalOccurrences,
          strippedAlignment
        },
        output
      });
      return {
        perf: output.perf,
        unalignedWords: output.unalignedWords
      };
    };
    var mergeAlignment = {
      name: "mergeAlignment",
      type: "Transform",
      description: "PERF=>PERF adds report to verses",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }, {
        name: "strippedAlignment",
        type: "json",
        source: ""
      }, {
        name: "verseWords",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }, {
        name: "unalignedWords",
        type: "json"
      }],
      code: mergeAlignmentCode
    };
    module.exports = {
      mergeAlignment
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/index.js
var require_transforms = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/transforms/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      verseWords
    } = require_verseWords2();
    var {
      stripAlignment
    } = require_stripAlignment2();
    var {
      mergeAlignment
    } = require_mergeAlignment();
    module.exports = {
      verseWords,
      stripAlignment,
      mergeAlignment
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/index.js
var require_alignment = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/alignment/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var renderActions = require_renderActions();
    var transforms = require_transforms();
    module.exports = {
      transforms,
      renderActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/renderActions/index.js
var require_renderActions2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/renderActions/index.js"() {
    "use strict";
    init_process();
    init_buffer();
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/transforms/usfmToPerf.js
var require_usfmToPerf = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/transforms/usfmToPerf.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var usfmToPerfCode = function usfmToPerfCode2(_ref) {
      var {
        usfm,
        selectors,
        proskomma
      } = _ref;
      proskomma.importDocuments(selectors, "usfm", [usfm]);
      var perfResultDocument = proskomma.gqlQuerySync("{documents {id docSetId perf} }").data.documents[0];
      var docId = perfResultDocument.id;
      var docSetId = perfResultDocument.docSetId;
      proskomma.gqlQuerySync('mutation { deleteDocument(docSetId: "'.concat(docSetId, '", documentId: "').concat(docId, '") }'));
      var perf = JSON.parse(perfResultDocument.perf);
      return {
        perf
      };
    };
    var usfmToPerf = {
      name: "usfmToPerf",
      type: "Transform",
      description: "USFM=>PERF: Conversion via Proskomma",
      inputs: [{
        name: "usfm",
        type: "text",
        source: ""
      }, {
        name: "selectors",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }],
      code: usfmToPerfCode
    };
    module.exports = {
      usfmToPerf,
      usfmToPerfCode
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/transforms/index.js
var require_transforms2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/transforms/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      usfmToPerf,
      usfmToPerfCode
    } = require_usfmToPerf();
    module.exports = {
      usfmToPerf,
      usfmToPerfCode
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/index.js
var require_xToPerf = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/xToPerf/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var renderActions = require_renderActions2();
    var transforms = require_transforms2();
    module.exports = {
      transforms,
      renderActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/renderActions/identity.js
var require_identity2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/renderActions/identity.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var identityActions = {
      startDocument: [{
        description: "identity",
        test: () => true,
        action: (_ref) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref;
          output.sofria = {};
          output.sofria.schema = context.document.schema;
          output.sofria.metadata = context.document.metadata;
          output.sofria.sequence = {};
          workspace.currentSequence = output.sofria.sequence;
          workspace.chapter = null;
          workspace.verses = null;
          workspace.cachedChapter = null;
          workspace.cachedVerses = null;
        }
      }],
      endDocument: [{
        description: "identity",
        test: () => true,
        action: (_ref2) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref2;
        }
      }],
      startSequence: [{
        description: "identity",
        test: () => true,
        action: (_ref3) => {
          var {
            context,
            workspace
          } = _ref3;
          workspace.currentSequence.type = context.sequences[0].type;
          workspace.currentSequence.blocks = [];
        }
      }],
      endSequence: [{
        description: "identity",
        test: () => true,
        action: (_ref4) => {
          var {
            workspace
          } = _ref4;
          if (workspace.currentSequence.type === "main") {
            workspace.chapter = null;
            workspace.verses = null;
          }
          workspace.currentSequence = null;
        }
      }],
      blockGraft: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var currentBlock = environment.context.sequences[0].block;
          var graftRecord = {
            type: currentBlock.type
          };
          if (currentBlock.sequence) {
            graftRecord.sequence = {};
            var cachedSequencePointer = environment.workspace.currentSequence;
            environment.workspace.currentSequence = graftRecord.sequence;
            environment.context.renderer.renderSequence(environment);
            environment.workspace.currentSequence = cachedSequencePointer;
          }
          environment.workspace.currentSequence.blocks.push(graftRecord);
        }
      }],
      startParagraph: [{
        description: "identity",
        test: () => true,
        action: (_ref5) => {
          var {
            context,
            workspace
          } = _ref5;
          var currentBlock = context.sequences[0].block;
          var paraRecord = {
            type: currentBlock.type,
            subtype: currentBlock.subType,
            content: []
          };
          workspace.currentSequence.blocks.push(paraRecord);
          workspace.currentContent = paraRecord.content;
          workspace.outputBlock = workspace.currentSequence.blocks[workspace.currentSequence.blocks.length - 1];
          workspace.outputContentStack = [workspace.outputBlock.content];
          if (workspace.currentSequence.type === "main") {
            for (var cv of ["chapter", "verses"]) {
              if (workspace[cv]) {
                var wrapperRecord = {
                  type: "wrapper",
                  subtype: cv,
                  content: [],
                  atts: {
                    number: workspace[cv]
                  }
                };
                workspace.outputContentStack[0].push(wrapperRecord);
                workspace.outputContentStack.unshift(wrapperRecord.content);
              }
            }
          }
        }
      }],
      endParagraph: [{
        description: "identity",
        test: () => true,
        action: (_ref6) => {
          var {
            workspace
          } = _ref6;
        }
      }],
      metaContent: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var {
            context,
            workspace
          } = environment;
          var element = context.sequences[0].element;
          workspace.currentContent = element.metaContent;
          var lastOutputItem = workspace.outputContentStack[1][workspace.outputContentStack[1].length - 1];
          lastOutputItem.meta_content = [];
          workspace.outputContentStack.unshift(lastOutputItem.meta_content);
          context.renderer.renderContent(workspace.currentContent, environment);
          workspace.outputContentStack.shift();
        }
      }],
      mark: [{
        description: "identity",
        test: () => true,
        action: (_ref7) => {
          var {
            context,
            workspace
          } = _ref7;
          var element = context.sequences[0].element;
          var markRecord = {
            type: element.type,
            subtype: element.subType
          };
          if (element.atts) {
            markRecord.atts = element.atts;
          }
          workspace.outputContentStack[0].push(markRecord);
        }
      }],
      inlineGraft: [{
        description: "identity",
        test: () => true,
        action: (environment) => {
          var element = environment.context.sequences[0].element;
          var graftRecord = {
            type: element.type,
            subtype: element.subType,
            sequence: {}
          };
          var cachedSequencePointer = environment.workspace.currentSequence;
          var cachedOutputContentStack = [...environment.workspace.outputContentStack];
          environment.workspace.currentSequence = graftRecord.sequence;
          environment.context.renderer.renderSequence(environment);
          environment.workspace.outputContentStack = cachedOutputContentStack;
          environment.workspace.currentSequence = cachedSequencePointer;
          environment.workspace.outputContentStack[0].push(graftRecord);
        }
      }],
      startWrapper: [{
        description: "identity",
        test: () => true,
        action: (_ref8) => {
          var {
            context,
            workspace
          } = _ref8;
          var element = context.sequences[0].element;
          if (element.subType === "chapter") {
            workspace.chapter = element.atts.number;
            workspace.cachedChapter = workspace.chapter;
          } else if (element.subType === "verses") {
            workspace.verses = element.atts.number;
            workspace.cachedVerses = workspace.verses;
          }
          var wrapperRecord = {
            type: element.type,
            subtype: element.subType,
            content: []
          };
          if ("atts" in element) {
            wrapperRecord.atts = _objectSpread({}, element.atts);
          }
          if (workspace.outputContentStack.length === 0) {
            throw new Error("outputContentStack is empty before pushing to its first element, near ".concat(context.document.metadata.document.bookCode, " ").concat(workspace.cachedChapter, ":").concat(workspace.cachedVerses));
          }
          workspace.outputContentStack[0].push(wrapperRecord);
          workspace.outputContentStack.unshift(wrapperRecord.content);
        }
      }],
      endWrapper: [{
        description: "identity",
        test: () => true,
        action: (_ref9) => {
          var {
            context,
            workspace
          } = _ref9;
          var element = context.sequences[0].element;
          if (element.subType === "chapter") {
            workspace.chapter = null;
          } else if (element.subType === "verses") {
            workspace.verses = null;
          }
          workspace.outputContentStack.shift();
        }
      }],
      startMilestone: [{
        description: "identity",
        test: () => true,
        action: (_ref10) => {
          var {
            context,
            workspace
          } = _ref10;
          var element = context.sequences[0].element;
          var milestoneRecord = {
            type: element.type,
            subtype: element.subType
          };
          if (element.atts) {
            milestoneRecord.atts = element.atts;
          }
          workspace.outputContentStack[0].push(milestoneRecord);
        }
      }],
      endMilestone: [{
        description: "identity",
        test: () => true,
        action: (_ref11) => {
          var {
            context,
            workspace
          } = _ref11;
          var element = context.sequences[0].element;
          var milestoneRecord = {
            type: element.type,
            subtype: element.subType
          };
          workspace.outputContentStack[0].push(milestoneRecord);
        }
      }],
      text: [{
        description: "identity",
        test: () => true,
        action: (_ref12) => {
          var {
            context,
            workspace
          } = _ref12;
          var element = context.sequences[0].element;
          workspace.outputContentStack[0].push(element.text);
        }
      }]
    };
    module.exports = {
      identityActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/renderActions/index.js
var require_renderActions3 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/renderActions/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identityActions
    } = require_identity2();
    module.exports = {
      identityActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/transforms/identity.js
var require_identity3 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/transforms/identity.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identityActions
    } = require_identity2();
    var identityActionsCode = function identityActionsCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new PerfRenderFromJson({
        srcJson: perf,
        actions: identityAction
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return {
        verseWords: output.cv
      };
    };
    var identity = {
      name: "identity",
      type: "Transform",
      description: "identity operation",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }],
      code: identityActionsCode
    };
    module.exports = {
      identity
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/transforms/index.js
var require_transforms3 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/transforms/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identity
    } = require_identity3();
    module.exports = {
      identity
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/index.js
var require_sofriaToSofria = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/sofriaToSofria/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var renderActions = require_renderActions3();
    var transforms = require_transforms3();
    module.exports = {
      transforms,
      renderActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/wordCount.js
var require_wordCount = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/wordCount.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var wordCountActions = {
      startDocument: [{
        description: "Set up word object",
        test: () => true,
        action: (_ref) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref;
          workspace.words = {};
        }
      }],
      text: [{
        description: "Split strings and add words to word object",
        test: () => true,
        action: (_ref2) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref2;
          for (var word of context.sequences[0].element.text.split(/[\s:;,.]+/).filter((w) => w.length > 0)) {
            word = word.toLowerCase();
            if (word in workspace.words) {
              workspace.words[word] += 1;
            } else {
              workspace.words[word] = 1;
            }
          }
        }
      }],
      endDocument: [{
        description: "Sort words",
        test: () => true,
        action: (_ref3) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref3;
          output.words = [...Object.entries(workspace.words)].sort((a, b) => b[1] - a[1]);
        }
      }]
    };
    module.exports = {
      wordCountActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/calculateUsfmChapterPositions.js
var require_calculateUsfmChapterPositions = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/calculateUsfmChapterPositions.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var initialBlockRecord = (ct) => ({
      type: ct.sequences[0].block.type,
      subType: ct.sequences[0].block.subType,
      pos: ct.sequences[0].block.blockN,
      perfChapter: null
    });
    var calculateUsfmChapterPositionsActions = {
      startDocument: [{
        description: "Set up storage",
        test: () => true,
        action: (_ref) => {
          var {
            workspace,
            output
          } = _ref;
          workspace.blockRecords = [];
          output.report = {};
        }
      }],
      startParagraph: [{
        description: "Set up block record",
        test: () => true,
        action: (_ref2) => {
          var {
            context,
            workspace,
            output
          } = _ref2;
          workspace.blockRecords.push(initialBlockRecord(context));
        }
      }],
      blockGraft: [{
        description: "Set up block record",
        test: () => true,
        action: (_ref3) => {
          var {
            context,
            workspace,
            output
          } = _ref3;
          workspace.blockRecords.push(initialBlockRecord(context));
        }
      }],
      mark: [{
        description: "Add chapter number to block record",
        test: (_ref4) => {
          var {
            context
          } = _ref4;
          return context.sequences[0].element.subType === "chapter";
        },
        action: (_ref5) => {
          var {
            config: config2,
            context,
            workspace,
            output
          } = _ref5;
          workspace.blockRecords[workspace.blockRecords.length - 1].perfChapter = context.sequences[0].element.atts["number"];
        }
      }],
      endDocument: [{
        description: "Populate report",
        test: () => true,
        action: (_ref6) => {
          var {
            workspace,
            output
          } = _ref6;
          for (var [recordN, record] of Object.entries(workspace.blockRecords)) {
            if (!record.perfChapter) {
              continue;
            }
            var usfmChapterPos = recordN;
            var found = false;
            while (usfmChapterPos > 0 && !found) {
              if (workspace.blockRecords[usfmChapterPos - 1].type === "paragraph" || workspace.blockRecords[usfmChapterPos - 1].subType === "title") {
                found = true;
              } else {
                usfmChapterPos--;
              }
            }
            output.report[usfmChapterPos.toString()] = record.perfChapter;
          }
        }
      }]
    };
    module.exports = {
      calculateUsfmChapterPositionsActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/perfToUsfm.js
var require_perfToUsfm = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/perfToUsfm.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var oneifyTag = (t) => {
      if (["toc", "toca", "mt", "imt", "s", "ms", "mte", "sd"].includes(t)) {
        return t + "1";
      }
      return t;
    };
    var buildMilestone = function buildMilestone2(type) {
      var atts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (atts == null)
        atts = {};
      var str = "\\".concat(type, "-s |");
      for (var [key, value] of Object.entries(atts)) {
        if (key === "x-morph" && typeof value !== "string") {
          str = str + oneifyTag(key) + '="' + value.join(",") + '" ';
        } else {
          str = str + oneifyTag(key) + '="' + value + '" ';
        }
      }
      ;
      return str + "\\*";
    };
    var buildEndWrapper = function buildEndWrapper2(type) {
      var atts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var isnested = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (atts == null)
        atts = {};
      var str = "|";
      for (var [key, value] of Object.entries(atts)) {
        str = str + oneifyTag(key) + '="' + value + '" ';
      }
      ;
      str = str + "\\";
      if (isnested) {
        str = str + "+";
      }
      return str + type + "*";
    };
    var perfToUsfmActions = {
      startDocument: [{
        description: "Set up environment",
        test: () => true,
        action: (_ref) => {
          var {
            context,
            workspace
          } = _ref;
          workspace.usfmBits = [""];
          workspace.nestedWrapper = 0;
          for (var [key, value] of Object.entries(context.document.metadata.document).filter((kv) => !["tags", "properties", "bookCode", "cl"].includes(kv[0]))) {
            workspace.usfmBits.push("\\".concat(oneifyTag(key), " ").concat(value, "\n"));
          }
          ;
        }
      }],
      blockGraft: [{
        description: "Follow block grafts",
        test: (_ref2) => {
          var {
            context
          } = _ref2;
          return ["title", "heading", "introduction"].includes(context.sequences[0].block.subType);
        },
        action: (environment) => {
          var contextSequence = environment.context.sequences[0];
          var chapterValue = environment.config.report[contextSequence.block.blockN.toString()];
          var target = contextSequence.block.target;
          if (chapterValue && contextSequence.type === "main") {
            environment.workspace.usfmBits.push("\n\\c ".concat(chapterValue, "\n"));
          }
          if (target) {
            environment.context.renderer.renderSequenceId(environment, target);
          }
        }
      }],
      inlineGraft: [{
        description: "Follow inline grafts",
        test: () => true,
        action: (environment) => {
          var target = environment.context.sequences[0].element.target;
          if (target) {
            environment.context.renderer.renderSequenceId(environment, target);
          }
        }
      }],
      startParagraph: [{
        description: "Output footnote paragraph tag (footnote)",
        test: (_ref3) => {
          var {
            context
          } = _ref3;
          return context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref";
        },
        action: (_ref4) => {
          var {
            context,
            workspace,
            config: config2
          } = _ref4;
          workspace.nestedWrapper = 0;
          var contextSequence = context.sequences[0];
          workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.block.subType.split(":")[1]), " "));
        }
      }, {
        description: "Output footnote note_caller tag (footnote)",
        test: (_ref5) => {
          var {
            context
          } = _ref5;
          return context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x";
        },
        action: (_ref6) => {
          var {
            context,
            workspace,
            config: config2
          } = _ref6;
          workspace.nestedWrapper = 0;
        }
      }, {
        description: "Output paragraph tag (main)",
        test: () => true,
        action: (_ref7) => {
          var {
            context,
            workspace,
            config: config2
          } = _ref7;
          workspace.nestedWrapper = 0;
          var contextSequence = context.sequences[0];
          var chapterValue = config2.report[contextSequence.block.blockN.toString()];
          if (chapterValue && contextSequence.type === "main") {
            workspace.usfmBits.push("\n\\c ".concat(chapterValue, "\n"));
          }
          workspace.usfmBits.push("\n\\".concat(oneifyTag(contextSequence.block.subType.split(":")[1]), "\n"));
        }
      }],
      endParagraph: [{
        description: "Output footnote paragraph tag (footnote)",
        test: (_ref8) => {
          var {
            context
          } = _ref8;
          return context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref";
        },
        action: (_ref9) => {
          var {
            context,
            workspace,
            config: config2
          } = _ref9;
          var contextSequence = context.sequences[0];
          workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.block.subType.split(":")[1]), "*"));
        }
      }, {
        description: "Output footnote note_caller tag (footnote)",
        test: (_ref10) => {
          var {
            context
          } = _ref10;
          return context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x";
        },
        action: (_ref11) => {
          var {
            context,
            workspace,
            config: config2
          } = _ref11;
        }
      }, {
        description: "Output nl",
        test: () => true,
        action: (_ref12) => {
          var {
            workspace
          } = _ref12;
          workspace.usfmBits.push("\n");
        }
      }],
      startMilestone: [{
        description: "Output start milestone",
        test: () => true,
        action: (_ref13) => {
          var {
            context,
            workspace
          } = _ref13;
          var contextSequenceElement = context.sequences[0].element;
          var newStartMileStone = buildMilestone(oneifyTag(contextSequenceElement.subType.split(":")[1]), contextSequenceElement.atts);
          workspace.usfmBits.push(newStartMileStone);
        }
      }],
      endMilestone: [{
        description: "Output end milestone",
        test: () => true,
        action: (_ref14) => {
          var {
            context,
            workspace
          } = _ref14;
          workspace.usfmBits.push("\\".concat(oneifyTag(context.sequences[0].element.subType.split(":")[1]), "-e\\*"));
        }
      }],
      text: [{
        description: "Output text",
        test: () => true,
        action: (_ref15) => {
          var {
            context,
            workspace
          } = _ref15;
          var text = context.sequences[0].element.text;
          workspace.usfmBits.push(text);
        }
      }],
      mark: [{
        description: "Output chapter or verses",
        test: () => true,
        action: (_ref16) => {
          var {
            context,
            workspace
          } = _ref16;
          var element = context.sequences[0].element;
          if (element.subType === "verses") {
            workspace.usfmBits.push("\n\\v ".concat(element.atts["number"], "\n"));
          }
        }
      }],
      endSequence: [{
        description: "Output \\cl",
        test: (_ref17) => {
          var {
            context
          } = _ref17;
          return context.document.metadata.document.cl && context.sequences[0].type === "title";
        },
        action: (_ref18) => {
          var {
            context,
            workspace
          } = _ref18;
          workspace.usfmBits.push("\n\\cl ".concat(context.document.metadata.document.cl, "\n"));
        }
      }],
      startWrapper: [{
        description: "Output start tag",
        test: () => true,
        action: (_ref19) => {
          var {
            workspace,
            context
          } = _ref19;
          var contextSequence = context.sequences[0];
          if (workspace.nestedWrapper > 0) {
            workspace.usfmBits.push("\\+".concat(oneifyTag(contextSequence.element.subType.split(":")[1]), " "));
          } else {
            workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.element.subType.split(":")[1]), " "));
          }
          workspace.nestedWrapper += 1;
        }
      }],
      endWrapper: [{
        description: "Output end tag",
        test: (_ref20) => {
          var {
            context
          } = _ref20;
          return !["fr", "fq", "fqa", "fk", "fl", "fw", "fp", "ft", "xo", "xk", "xq", "xt", "xta"].includes(context.sequences[0].element.subType.split(":")[1]);
        },
        action: (_ref21) => {
          var {
            workspace,
            context
          } = _ref21;
          workspace.nestedWrapper -= 1;
          var contextSequence = context.sequences[0];
          var subType = contextSequence.element.subType.split(":")[1];
          var isNested = workspace.nestedWrapper > 0;
          if (subType === "w") {
            var newEndW = buildEndWrapper(oneifyTag(subType), contextSequence.element.atts, isNested);
            workspace.usfmBits.push(newEndW);
          } else {
            if (isNested) {
              workspace.usfmBits.push("\\+".concat(oneifyTag(contextSequence.element.subType.split(":")[1]), "*"));
            } else {
              workspace.usfmBits.push("\\".concat(oneifyTag(contextSequence.element.subType.split(":")[1]), "*"));
            }
          }
        }
      }, {
        description: "Do NOT output end tag",
        test: () => true,
        action: (_ref22) => {
          var {
            workspace
          } = _ref22;
          workspace.nestedWrapper -= 1;
        }
      }],
      endDocument: [{
        description: "Build output",
        test: () => true,
        action: (_ref23) => {
          var {
            workspace,
            output
          } = _ref23;
          output.usfm = workspace.usfmBits.join("").replace(/(\s*)\n(\s*)/gm, "\n");
        }
      }]
    };
    module.exports = {
      perfToUsfmActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/index.js
var require_renderActions4 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/renderActions/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      wordCountActions
    } = require_wordCount();
    var {
      calculateUsfmChapterPositionsActions
    } = require_calculateUsfmChapterPositions();
    var {
      perfToUsfmActions
    } = require_perfToUsfm();
    module.exports = {
      wordCountActions,
      perfToUsfmActions,
      calculateUsfmChapterPositionsActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/wordCount.js
var require_wordCount2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/wordCount.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      wordCountActions
    } = require_wordCount();
    var wordCountCode = function wordCountCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: wordCountActions
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return {
        report: output.report
      };
    };
    var wordCount = {
      name: "wordCount",
      type: "Transform",
      description: "PERF=>JSON: Generates positions for inserting chapter numbers into USFM",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "report",
        type: "json"
      }],
      code: wordCountCode
    };
    module.exports = {
      wordCount
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/calculateUsfmChapterPositions.js
var require_calculateUsfmChapterPositions2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/calculateUsfmChapterPositions.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      calculateUsfmChapterPositionsActions
    } = require_calculateUsfmChapterPositions();
    var calculateUsfmChapterPositionsCode = function calculateUsfmChapterPositionsCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: calculateUsfmChapterPositionsActions
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {
          maxLength: 60
        },
        output
      });
      return {
        report: output.report
      };
    };
    var calculateUsfmChapterPositions = {
      name: "calculateUsfmChapterPositions",
      type: "Transform",
      description: "PERF=>JSON: Generates positions for inserting chapter numbers into USFM",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "report",
        type: "json"
      }],
      code: calculateUsfmChapterPositionsCode
    };
    module.exports = {
      calculateUsfmChapterPositions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/perfToUsfm.js
var require_perfToUsfm2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/perfToUsfm.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      perfToUsfmActions
    } = require_perfToUsfm();
    var perfToUsfmCode = function perfToUsfmCode2(_ref) {
      var {
        perf,
        report
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: perfToUsfmActions
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {
          report
        },
        output
      });
      return {
        usfm: output.usfm
      };
    };
    var perfToUsfm = {
      name: "perfToUsfm",
      type: "Transform",
      description: "PERF=>USFM",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }, {
        name: "report",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "usfm",
        type: "text"
      }],
      code: perfToUsfmCode
    };
    module.exports = {
      perfToUsfm
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/index.js
var require_transforms4 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/transforms/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      wordCount
    } = require_wordCount2();
    var {
      calculateUsfmChapterPositions
    } = require_calculateUsfmChapterPositions2();
    var {
      perfToUsfm
    } = require_perfToUsfm2();
    module.exports = {
      wordCount,
      perfToUsfm,
      calculateUsfmChapterPositions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/index.js
var require_perfToX = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToX/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var renderActions = require_renderActions4();
    var transforms = require_transforms4();
    module.exports = {
      transforms,
      renderActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/justTheBible.js
var require_justTheBible = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/justTheBible.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var justTheBibleActions = {
      startMilestone: [{
        description: "Ignore startMilestone events",
        test: () => true,
        action: () => {
        }
      }],
      endMilestone: [{
        description: "Ignore endMilestone events",
        test: () => true,
        action: () => {
        }
      }],
      startWrapper: [{
        description: "Ignore startWrapper events",
        test: () => true,
        action: () => {
        }
      }],
      endWrapper: [{
        description: "Ignore endWrapper events",
        test: () => true,
        action: () => {
        }
      }],
      blockGraft: [{
        description: "Ignore blockGraft events, except for title (\\mt)",
        test: (environment) => environment.context.sequences[0].block.subType !== "title",
        action: (environment) => {
        }
      }],
      inlineGraft: [{
        description: "Ignore inlineGraft events",
        test: () => true,
        action: () => {
        }
      }],
      mark: [{
        description: "Ignore mark events, except for chapter and verses",
        test: (_ref) => {
          var {
            context
          } = _ref;
          return !["chapter", "verses"].includes(context.sequences[0].element.subType);
        },
        action: () => {
        }
      }]
    };
    module.exports = {
      justTheBibleActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/index.js
var require_renderActions5 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/renderActions/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identityActions
    } = require_identity();
    var {
      justTheBibleActions
    } = require_justTheBible();
    module.exports = {
      identityActions,
      justTheBibleActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/identity.js
var require_identity4 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/identity.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identityActions
    } = require_identity();
    var identityActionsCode = function identityActionsCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new PerfRenderFromJson({
        srcJson: perf,
        actions: identityActions
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return {
        verseWords: output.cv
      };
    };
    var identity = {
      name: "identityTransform",
      type: "Transform",
      description: "identity operation",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }],
      code: identityActionsCode
    };
    module.exports = {
      identity
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/justTheBible.js
var require_justTheBible2 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/justTheBible.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _PerfRenderFromJson = _interopRequireDefault(require_PerfRenderFromJson());
    var _mergeActions = _interopRequireDefault(require_mergeActions());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      identityActions
    } = require_identity();
    var {
      justTheBibleActions
    } = require_justTheBible();
    var justTheBibleCode = function justTheBibleCode2(_ref) {
      var {
        perf
      } = _ref;
      var cl = new _PerfRenderFromJson.default({
        srcJson: perf,
        actions: (0, _mergeActions.default)([justTheBibleActions, identityActions])
      });
      var output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return {
        perf: output.perf
      };
    };
    var justTheBible = {
      name: "justTheBible",
      type: "Transform",
      description: "PERF=>PERF: Strips most markup",
      documentation: "This transform removes milestones, wrappers and most marks. It has been used in several pipelines. It may also be stripping metaContent.",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }],
      code: justTheBibleCode
    };
    module.exports = {
      justTheBible
    };
  }
});

// node_modules/deep-copy-all/dist/dca-library.js
var require_dca_library = __commonJS({
  "node_modules/deep-copy-all/dist/dca-library.js"(exports, module) {
    init_process();
    init_buffer();
    var objectBehaviors = {};
    var isPrimitive = (item) => {
      let type = typeof item;
      return type === "number" || type === "string" || type === "boolean" || type === "undefined" || type === "bigint" || type === "symbol" || item === null;
    };
    var objectType = (obj) => {
      if (isPrimitive(obj) || !(obj instanceof Object)) {
        return "primitive";
      }
      const consName = obj.constructor && obj.constructor.name && obj.constructor.name.toLowerCase();
      if (typeof consName === "string" && consName.length && objectBehaviors[consName]) {
        return consName;
      }
      let typeTry;
      for (const name in objectBehaviors) {
        typeTry = objectBehaviors[name].type;
        if (!typeTry || obj instanceof typeTry) {
          return name;
        }
      }
      return "unknown";
    };
    var arrayAddElement = (array, key, value) => Array.prototype.push.call(array, value);
    var arrayMakeEmpty = (source) => {
      const newArray = [];
      Object.setPrototypeOf(newArray, Object.getPrototypeOf(source));
      return newArray;
    };
    var arrayMakeShallow = (source) => {
      const dest = [...source];
      Object.setPrototypeOf(dest, Object.getPrototypeOf(source));
      return dest;
    };
    var arrayIterate = (array, copyNonEnumerables, callback) => {
      const len = array.length;
      for (let i = 0; i < len; i++) {
        const val = array[i];
        const elInfo = {
          key: i,
          value: val,
          type: objectType(val)
        };
        callback(elInfo);
      }
    };
    var addArrayBehavior = () => {
      Object.assign(objectBehaviors, {
        "array": {
          type: Array,
          mayDeepCopy: true,
          addElement: arrayAddElement,
          makeEmpty: arrayMakeEmpty,
          makeShallow: arrayMakeShallow,
          iterate: arrayIterate
        }
      });
    };
    var addDateBehavior = () => {
      Object.assign(objectBehaviors, {
        "date": {
          type: Date,
          makeShallow: (date) => new Date(date.getTime())
        }
      });
    };
    var addRegExpBehavior = () => {
      Object.assign(objectBehaviors, {
        "regexp": {
          type: RegExp,
          makeShallow: (src) => new RegExp(src)
        }
      });
    };
    var addFunctionBehavior = () => {
      Object.assign(objectBehaviors, {
        "function": {
          type: Function,
          makeShallow: (fn) => fn
        }
      });
    };
    var addErrorBehavior = () => {
      Object.assign(objectBehaviors, {
        "error": {
          type: Error,
          makeShallow: (err) => {
            const errCopy = new Error(err.message);
            errCopy.stack = err.stack;
            return errCopy;
          }
        }
      });
    };
    var addTypedArrayBehavior = (name) => {
      let type = typeof globalThis !== "undefined" && globalThis[name] || typeof window !== "undefined" && window[name] || typeof WorkerGlobalScope !== "undefined" && WorkerGlobalScope[name];
      if (typeof type !== "undefined") {
        objectBehaviors[name.toLowerCase()] = {
          type,
          makeShallow: (source) => type.from(source)
        };
      }
    };
    var addAllTypedArrayBehaviors = () => {
      const typedArrayNames = [
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array"
      ];
      typedArrayNames.forEach((name) => addTypedArrayBehavior(name));
    };
    var addArrayBufferBehavior = () => {
      if (typeof ArrayBuffer !== "undefined") {
        Object.assign(objectBehaviors, {
          "arraybuffer": {
            type: ArrayBuffer,
            makeShallow: (buffer) => buffer.slice(0)
          }
        });
      }
    };
    var addMapBehavior = () => {
      if (typeof Map === "undefined") {
        return;
      }
      Object.assign(objectBehaviors, {
        "map": {
          type: Map,
          mayDeepCopy: true,
          addElement: (map, key, value) => map.set(key, value),
          makeEmpty: () => /* @__PURE__ */ new Map(),
          makeShallow: (sourceMap) => new Map(sourceMap),
          iterate: (map, copyNonEnumerables, callback) => {
            map.forEach((val, key) => {
              const elInfo = {
                key,
                value: val,
                type: objectType(val)
              };
              callback(elInfo);
            });
          }
        }
      });
    };
    var addSetBehavior = () => {
      if (typeof Set === "undefined") {
        return;
      }
      Object.assign(objectBehaviors, {
        "set": {
          type: Set,
          mayDeepCopy: true,
          addElement: (set, key, value) => set.add(value),
          makeEmpty: () => /* @__PURE__ */ new Set(),
          makeShallow: (set) => new Set(set),
          iterate: (set, copyNonEnumerables, callback) => {
            set.forEach((val) => {
              const elInfo = {
                key: null,
                value: val,
                type: objectType(val)
              };
              callback(elInfo);
            });
          }
        }
      });
    };
    var addWeakSetBehavior = () => {
      if (typeof WeakSet === "undefined") {
        return;
      }
      Object.assign(objectBehaviors, {
        "weakset": {
          type: WeakSet,
          makeShallow: (wset) => wset
        }
      });
    };
    var addWeakMapBehavior = () => {
      if (typeof WeakMap === "undefined") {
        return;
      }
      Object.assign(objectBehaviors, {
        "weakmap": {
          type: WeakMap,
          makeShallow: (wmap) => wmap
        }
      });
    };
    var addBufferBehavior = () => {
      if (typeof Buffer === "undefined") {
        return;
      }
      Object.assign(objectBehaviors, {
        "buffer": {
          type: Buffer,
          makeShallow: (buf) => Buffer.from(buf)
        }
      });
    };
    var objectAddElement = (obj, key, value, descriptor = void 0) => {
      if (!descriptor) {
        obj[key] = value;
      } else {
        Object.defineProperty(obj, key, descriptor);
      }
    };
    var objectMakeEmpty = (source) => {
      const newObj = {};
      Object.setPrototypeOf(newObj, Object.getPrototypeOf(source));
      return newObj;
    };
    var objectMakeShallow = (source) => {
      const dest = Object.assign({}, source);
      Object.setPrototypeOf(dest, Object.getPrototypeOf(source));
      return dest;
    };
    var objectIterate = (obj, copyNonEnumerables, callback) => {
      const keys2 = copyNonEnumerables ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      for (let i = 0; i < len; i++) {
        const key = keys2[i], value = obj[key], elInfo = {
          key,
          value,
          type: objectType(value)
        };
        if (copyNonEnumerables && !obj.propertyIsEnumerable(key)) {
          elInfo.descriptor = Object.getOwnPropertyDescriptor(obj, key);
        }
        callback(elInfo);
      }
    };
    var addObjectBehavior = () => {
      Object.assign(objectBehaviors, {
        "object": {
          type: Object,
          mayDeepCopy: true,
          addElement: objectAddElement,
          makeEmpty: objectMakeEmpty,
          makeShallow: objectMakeShallow,
          iterate: objectIterate
        }
      });
    };
    var addUnknownAndPrimitive = () => {
      Object.assign(objectBehaviors, {
        "unknown": {
          makeShallow: (source) => source
        },
        "primitive": {
          makeShallow: (source) => source
        }
      });
    };
    addArrayBehavior();
    addDateBehavior();
    addRegExpBehavior();
    addFunctionBehavior();
    addErrorBehavior();
    addAllTypedArrayBehaviors();
    addArrayBufferBehavior();
    addMapBehavior();
    addSetBehavior();
    addWeakSetBehavior();
    addWeakMapBehavior();
    addBufferBehavior();
    addObjectBehavior();
    addUnknownAndPrimitive();
    function objectActions(typeName) {
      return objectBehaviors[typeName];
    }
    module.exports = [
      isPrimitive,
      objectType,
      objectActions
    ];
  }
});

// node_modules/deep-copy-all/dist/deepCopyAll.min.js
var require_deepCopyAll_min = __commonJS({
  "node_modules/deep-copy-all/dist/deepCopyAll.min.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var [isPrimitive, objectType, objectActions] = require_dca_library();
    var defaultOpts = { goDeep: true, includeNonEnumerable: false, detectCircular: true, maxDepth: 20 };
    function setMissingOptions(e) {
      Object.keys(defaultOpts).forEach((t) => {
        void 0 === e[t] && (e[t] = defaultOpts[t]);
      });
    }
    var Watcher = class {
      constructor() {
        this._seenMap = /* @__PURE__ */ new WeakMap();
      }
      setAsCopied(e, t) {
        e instanceof Object && this._seenMap.set(e, t);
      }
      wasCopied(e) {
        return e instanceof Object && this._seenMap.has(e);
      }
      getCopy(e) {
        return this._seenMap.get(e);
      }
    };
    function copyElement(e, t, c) {
      const { options: o, watcher: s } = c;
      let n;
      return t.mayDeepCopy ? (n = t.makeEmpty(e), o.detectCircular && s.setAsCopied(e, n)) : n = t.makeShallow(e), n;
    }
    function checkForExceededDepth(e, t) {
      if (e >= t)
        throw `Error max depth of ${t} levels exceeded, possible circular reference`;
    }
    var copyObjectContents = (e, t, c) => {
      const { destObject: o, srcType: s, watcher: n, options: r } = t, p = r.detectCircular;
      checkForExceededDepth(++c, r.maxDepth);
      const i = objectActions(s);
      if (!i.mayDeepCopy)
        return;
      const a = i.addElement;
      i.iterate(e, r.includeNonEnumerable, (e2) => {
        const t2 = e2.value, s2 = e2.type, i2 = objectActions(s2);
        let d, l = false;
        p && n.wasCopied(t2) ? (d = n.getCopy(t2), l = true) : d = copyElement(t2, i2, { options: r, watcher: n }), a(o, e2.key, d, e2.descriptor), i2.mayDeepCopy && !l && copyObjectContents(t2, { destObject: d, srcType: s2, watcher: n, options: r }, c);
      });
    };
    function deepCopy(e, t = defaultOpts) {
      if (setMissingOptions(t), isPrimitive(e))
        return e;
      const c = objectType(e), o = objectActions(c);
      if (!t.goDeep || !o.mayDeepCopy)
        return o.makeShallow(e);
      const s = t.detectCircular ? new Watcher() : null;
      let n = o.makeEmpty(e);
      return t.detectCircular && s.setAsCopied(e, n), copyObjectContents(e, { destObject: n, srcType: c, watcher: s, options: t }, 0), n;
    }
    module.exports = deepCopy;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/mergePerfText.js
var require_mergePerfText = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/mergePerfText.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _deepCopyAll = _interopRequireDefault(require_deepCopyAll_min());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var doMerge1 = (content) => {
      var ret = [];
      for (var element of content) {
        if (typeof element === "string") {
          if (ret.length > 0 && typeof ret[ret.length - 1] === "string") {
            ret[ret.length - 1] += element;
          } else {
            ret.push(element);
          }
        } else {
          if (element.content) {
            element.content = doMerge1(element.content);
          }
          if (element.metaContent) {
            element.metaContent = doMerge1(element.content);
          }
          ret.push(element);
        }
      }
      return ret;
    };
    var doMerge = (perf) => {
      var newPerf = (0, _deepCopyAll.default)(perf);
      for (var seq of Object.values(newPerf.sequences)) {
        for (var block2 of seq.blocks) {
          if (block2.content) {
            block2.content = doMerge1(block2.content);
          }
          if (block2.metaContent) {
            block2.metaContent = doMerge1(block2.metaContent);
          }
        }
      }
      return newPerf;
    };
    var mergePerfTextCode = function mergePerfTextCode2(_ref) {
      var {
        perf
      } = _ref;
      return {
        perf: doMerge(perf)
      };
    };
    var mergePerfText = {
      name: "mergePerfText",
      type: "Transform",
      description: "PERF=>PERF: Merge consecutive text strings",
      inputs: [{
        name: "perf",
        type: "json",
        source: ""
      }],
      outputs: [{
        name: "perf",
        type: "json"
      }],
      code: mergePerfTextCode
    };
    module.exports = {
      mergePerfText,
      mergePerfTextCode
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/index.js
var require_transforms5 = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/transforms/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      identity
    } = require_identity4();
    var {
      justTheBible
    } = require_justTheBible2();
    var {
      mergePerfText,
      mergePerfTextCode
    } = require_mergePerfText();
    module.exports = {
      identity,
      justTheBible,
      mergePerfText,
      mergePerfTextCode
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/index.js
var require_perfToPerf = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/perfToPerf/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var renderActions = require_renderActions5();
    var transforms = require_transforms5();
    module.exports = {
      transforms,
      renderActions
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/index.js
var require_render = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/render/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var alignment = require_alignment();
    var xToPerf = require_xToPerf();
    var sofriaToSofria = require_sofriaToSofria();
    var perfToX = require_perfToX();
    var perfToPerf = require_perfToPerf();
    module.exports = {
      xToPerf,
      perfToX,
      sofriaToSofria,
      alignment,
      perfToPerf
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/usfmToPerfPipeline.json
var require_usfmToPerfPipeline = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/usfmToPerfPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          usfm: "text",
          selectors: "json"
        }
      },
      {
        id: 2,
        title: "USFM to PERF",
        name: "usfmToPerf",
        type: "Transform",
        inputs: [
          {
            name: "usfm",
            type: "text",
            source: "Input usfm"
          },
          {
            name: "selectors",
            type: "json",
            source: "Input selectors"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          }
        ],
        description: "USFM=>PERF: Conversion via Proskomma"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 2 perf"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/mergeAlignmentPipeline.json
var require_mergeAlignmentPipeline = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/mergeAlignmentPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json",
          strippedAlignment: "json"
        }
      },
      {
        id: 1,
        title: "Count stripped perf words",
        name: "verseWords",
        transformName: "verseWords",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "verseWords",
            type: "json"
          }
        ],
        description: "PERF=>JSON: Counts words occurrences"
      },
      {
        id: 2,
        title: "Merge Back Into Stripped (roundtrip)",
        name: "mergeAlignment",
        transformName: "mergeAlignment",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          },
          {
            name: "strippedAlignment",
            type: "json",
            source: "Input strippedAlignment"
          },
          {
            name: "verseWords",
            type: "json",
            source: "Transform 1 verseWords"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          },
          {
            name: "unalignedWords",
            type: "json"
          }
        ],
        description: "PERF=>PERF adds report to verses"
      },
      {
        id: 3,
        title: "Merge Merged PERF Text",
        name: "mergePerfText",
        transformName: "mergePerfText",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 2 perf"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          }
        ],
        description: "PERF=>PERF: Merge consecutive text strings"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 3 perf"
          },
          {
            name: "unalignedWords",
            type: "json",
            source: "Transform 2 unalignedWords"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/stripAlignmentPipeline.json
var require_stripAlignmentPipeline = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/stripAlignmentPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json"
        }
      },
      {
        id: 1,
        title: "Count stripped perf words",
        name: "verseWords",
        type: "Transform",
        transformName: "verseWords",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "verseWords",
            type: "json"
          }
        ],
        description: "PERF=>JSON: Counts words occurrences"
      },
      {
        id: 2,
        title: "Strip Alignment",
        name: "stripAlignment",
        type: "Transform",
        transformName: "stripAlignment",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          },
          {
            name: "verseWords",
            type: "json",
            source: "Transform 1 verseWords"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          },
          {
            name: "strippedAlignment",
            type: "json"
          },
          {
            name: "unalignedWords",
            type: "json"
          }
        ],
        description: "PERF=>PERF: Strips alignment markup"
      },
      {
        id: 3,
        title: "Merge stripped perf",
        name: "mergePerfText",
        type: "Transform",
        transformName: "mergePerfText",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 2 perf"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          }
        ],
        description: "PERF=>PERF: Merge consecutive text strings"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 3 perf"
          },
          {
            name: "strippedAlignment",
            type: "json",
            source: "Transform 2 strippedAlignment"
          },
          {
            name: "unalignedWords",
            type: "json",
            source: "Transform 2 unalignedWords"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/perfToUsfmPipeline.json
var require_perfToUsfmPipeline = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/perfToUsfmPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json"
        }
      },
      {
        id: 1,
        title: "Generate report",
        name: "calculateUsfmChapterPositions",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "report",
            type: "json"
          }
        ],
        description: "Generate report from perf to calculate the position of the chapters"
      },
      {
        id: 2,
        title: "PERF to USFM",
        name: "perfToUsfm",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          },
          {
            name: "report",
            type: "json",
            source: "Transform 1 report"
          }
        ],
        outputs: [
          {
            name: "usfm",
            type: "text"
          }
        ],
        description: "PERF=>USFM: Conversion via Proskomma"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "usfm",
            type: "text",
            source: "Transform 2 usfm"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/justTheBiblePipeline.json
var require_justTheBiblePipeline = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/justTheBiblePipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json"
        }
      },
      {
        id: 1,
        title: "Simplify Input PERF",
        name: "justTheBible",
        transformName: "justTheBible",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "perf",
            type: "json"
          }
        ]
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "perf",
            type: "json",
            source: "Transform 1 perf"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/index.js
var require_pipelines = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/pipelines/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var _usfmToPerfPipeline = _interopRequireDefault(require_usfmToPerfPipeline());
    var _mergeAlignmentPipeline = _interopRequireDefault(require_mergeAlignmentPipeline());
    var _stripAlignmentPipeline = _interopRequireDefault(require_stripAlignmentPipeline());
    var _perfToUsfmPipeline = _interopRequireDefault(require_perfToUsfmPipeline());
    var _justTheBiblePipeline = _interopRequireDefault(require_justTheBiblePipeline());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = {
      usfmToPerfPipeline: _usfmToPerfPipeline.default,
      mergeAlignmentPipeline: _mergeAlignmentPipeline.default,
      stripAlignmentPipeline: _stripAlignmentPipeline.default,
      perfToUsfmPipeline: _perfToUsfmPipeline.default,
      justTheBiblePipeline: _justTheBiblePipeline.default
    };
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/classes/PipelineHandler.js
var require_PipelineHandler = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/classes/PipelineHandler.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var namespaceTransforms = require_render();
    var officialPipelines = require_pipelines();
    var PipelineHandler = class {
      /**
       *
       * @param {Proskomma} proskomma - a proskomma instance
       * @param {JSON[]} pipelines - a list of the pipelines
       * @param {JSON[]} transforms - a list of the transforms
       * @param {boolean} verbose - print pipeline reading step by step
       */
      constructor(_ref) {
        var {
          pipelines = null,
          transforms = null,
          proskomma = null,
          verbose = false
        } = _ref;
        if (proskomma !== null) {
          this.proskomma = proskomma;
          var query = "{ id }";
          var content = proskomma.gqlQuerySync(query) || {};
          if (!content || !content.data.id) {
            throw new Error("Provided Proskomma instance does not have any ID");
          }
        }
        this.pipelines = officialPipelines;
        this.namespaces = namespaceTransforms;
        this.transforms = {};
        if (pipelines != null) {
          for (var key of Object.keys(pipelines)) {
            this.pipelines[key] = pipelines[key];
          }
        }
        if (transforms != null) {
          for (var _key of Object.keys(transforms)) {
            this.transforms[_key] = transforms[_key];
          }
        }
        this.verbose = verbose;
      }
      getProskomma() {
        return this.proskomma;
      }
      setProskomma(proskomma) {
        this.proskomma = proskomma;
      }
      listPipelinesNames() {
        return Object.keys(this.pipelines).join("\n");
      }
      listTransformsNames() {
        return Object.keys(this.transforms).join("\n");
      }
      listNamespacesNames() {
        return Object.keys(this.namespaces).join("\n");
      }
      /**
       * Gets pipeline by given name
       * @param {string} pipelineName - the pipeline name
       * @param {object} data input data
       * @return {pipeline} pipeline transforms
       * @private
       */
      getPipeline(pipelineName, data) {
        if (!this.pipelines[pipelineName]) {
          throw new Error("Unknown pipeline name '".concat(pipelineName, "'"));
        }
        var pipeline = this.pipelines[pipelineName];
        var inputSpecs = pipeline[0].inputs;
        if (Object.keys(inputSpecs).length !== Object.keys(data).length) {
          throw new Error("".concat(Object.keys(inputSpecs).length, " input(s) expected by ").concat(pipelineName, " but ").concat(Object.keys(data).length, " provided (").concat(Object.keys(data).join(", "), ")"));
        }
        for (var [inputSpecName, inputSpecType] of Object.entries(inputSpecs)) {
          if (!data[inputSpecName]) {
            throw new Error("Input ".concat(inputSpecName, " not provided as input to ").concat(pipelineName));
          }
          if (typeof data[inputSpecName] === "string" !== (inputSpecType === "text")) {
            throw new Error("Input ".concat(inputSpecName, " must be ").concat(inputSpecType, " but ").concat(typeof data[inputSpecName] === "string" ? "text" : "json", " was provided"));
          }
        }
        return pipeline;
      }
      /**
       * Generates and returns a report via a transform pipeline
       * @async
       * @param {string} pipelineName
       * @param {object} data
       * @return {Promise<array>} A report
       */
      runPipeline(pipelineName, data) {
        var _this = this;
        return _asyncToGenerator(function* () {
          var pipeline = _this.getPipeline(pipelineName, data);
          _this.loadTransforms(pipeline, "perf");
          return yield _this.evaluateSteps({
            specSteps: pipeline,
            inputValues: data
          });
        })();
      }
      loadTransforms(pipeline) {
        var namespace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "perf";
        var transformSteps = pipeline.filter((s) => s.type === "Transform");
        if (transformSteps.length === 0) {
          throw new Error("No Transform steps found in report steps");
        }
        var names = Object.keys(transformSteps).map((val) => transformSteps[val]["name"]);
        if (namespace === "sofria") {
          var entries = null;
          for (var [key, tr] of Object.entries(this.namespaces)) {
            if (key === "sofriaToSofria") {
              if (tr.transforms) {
                entries = Object.entries(tr.transforms);
              } else {
                entries = Object.entries(tr);
              }
              for (var [k, t] of entries) {
                if (names.includes(k)) {
                  this.transforms[k] = t;
                }
              }
            }
          }
        } else {
          var _entries = null;
          for (var [_key2, _tr] of Object.entries(this.namespaces)) {
            if (_key2 !== "sofriaToSofria") {
              if (_tr.transforms) {
                _entries = Object.entries(_tr.transforms);
              } else {
                _entries = Object.entries(_tr);
              }
              for (var [_k, _t] of _entries) {
                if (names.includes(_k)) {
                  this.transforms[_k] = _t;
                }
              }
            }
          }
        }
      }
      evaluateSteps(_ref2) {
        var {
          specSteps,
          inputValues
        } = _ref2;
        this.verbose && console.log("** Evaluate **");
        var inputStep = specSteps.filter((s) => s.type === "Inputs")[0];
        if (!inputStep) {
          throw new Error("No Inputs step found in report steps");
        }
        var outputStep = specSteps.filter((s) => s.type === "Outputs")[0];
        if (!outputStep) {
          throw new Error("No Outputs step found in report steps");
        }
        var transformSteps = specSteps.filter((s) => s.type === "Transform");
        if (transformSteps.length === 0) {
          throw new Error("No Transform steps found in report steps");
        }
        var transformInputs = {};
        var transformOutputs = {};
        for (var transformStep of Object.values(transformSteps)) {
          transformInputs[transformStep.id] = {};
          for (var input of transformStep.inputs) {
            transformInputs[transformStep.id][input.name] = null;
          }
          transformOutputs[transformStep.id] = {};
          for (var output of transformStep.outputs) {
            transformOutputs[transformStep.id][output] = null;
          }
        }
        for (var [inputKey, inputValue] of Object.entries(inputValues)) {
          for (var _transformStep of transformSteps) {
            for (var _input of _transformStep.inputs) {
              if (_input.source === "Input ".concat(inputKey)) {
                this.verbose && console.log("Copying Input ".concat(inputKey, " to Transform ").concat(_transformStep.id, " ").concat(_input.name, " input"));
                transformInputs[_transformStep.id][_input.name] = inputValue;
              }
            }
          }
        }
        var changed = true;
        var nWaitingTransforms = 0;
        while (changed) {
          changed = false;
          for (var _transformStep2 of transformSteps) {
            if (Object.values(transformInputs[_transformStep2.id]).filter((i) => !i).length === 0 && Object.values(transformOutputs[_transformStep2.id]).filter((i) => !i).length > 0) {
              this.verbose && console.log("Evaluating Transform ".concat(_transformStep2.id));
              try {
                transformOutputs[_transformStep2.id] = this.transforms[_transformStep2.name].code(_objectSpread(_objectSpread({}, transformInputs[_transformStep2.id]), {}, {
                  proskomma: this.getProskomma()
                }));
              } catch (err) {
                var errMsg = "Error evaluating Transform ".concat(_transformStep2.id, " (name=").concat(_transformStep2.name, ", type=").concat(typeof _transformStep2.code, "): ").concat(err);
                throw new Error(errMsg);
              }
              for (var consumingTransform of transformSteps) {
                for (var consumingInput of consumingTransform.inputs) {
                  for (var resolvedOutput of Object.keys(transformOutputs[_transformStep2.id])) {
                    if (consumingInput.source === "Transform ".concat(_transformStep2.id, " ").concat(resolvedOutput)) {
                      this.verbose && console.log("Copying Transform ".concat(_transformStep2.id, " ").concat(resolvedOutput, " output to Transform ").concat(consumingTransform.id, " ").concat(consumingInput.name, " input"));
                      transformInputs[consumingTransform.id][consumingInput.name] = transformOutputs[_transformStep2.id][resolvedOutput];
                    }
                  }
                }
              }
              changed = true;
            }
          }
        }
        if (nWaitingTransforms) {
          throw new Error("Inputs not satisfied for ".concat(nWaitingTransforms, " transform(s)"));
        }
        var outputValues = {};
        for (var _output of outputStep.outputs) {
          var transformN = _output.source.split(" ")[1];
          this.verbose && console.log("Copying Transform ".concat(transformN, " ").concat(_output.name, " to Output ").concat(_output.name));
          outputValues[_output.name] = transformOutputs[transformN][_output.name];
        }
        this.verbose && console.log("****");
        return outputValues;
      }
    };
    module.exports = PipelineHandler;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/PerfRenderFromProskomma.js
var require_PerfRenderFromProskomma = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/PerfRenderFromProskomma.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ProskommaRender = require_ProskommaRender();
    var camelCaseToSnakeCase = (s) => {
      var ret = [];
      for (var c of s.split("")) {
        if (c.toUpperCase() === c && c.toLowerCase() !== c) {
          ret.push("_".concat(c.toLowerCase()));
        } else {
          ret.push(c);
        }
      }
      return ret.join("");
    };
    var PerfRenderFromProskomma = class extends ProskommaRender {
      constructor(spec) {
        super(spec);
        if (!spec.proskomma) {
          throw new Error("No Proskomma");
        }
        this.pk = spec.proskomma;
        this._tokens = [];
        this._container = null;
      }
      renderDocument1(_ref) {
        var {
          docId,
          config: config2,
          context,
          workspace,
          output
        } = _ref;
        var environment = {
          config: config2,
          context,
          workspace,
          output
        };
        context.renderer = this;
        var documentResult = this.pk.gqlQuerySync('{document(id: "'.concat(docId, '") {docSetId mainSequence { id } nSequences sequences {id} headers { key value } } }'));
        var docSetId = documentResult.data.document.docSetId;
        var mainId = documentResult.data.document.mainSequence.id;
        var nSequences = documentResult.data.document.nSequences;
        var sequenceIds = documentResult.data.document.sequences.map((s) => s.id);
        var headers = {};
        for (var header of documentResult.data.document.headers) {
          headers[header.key] = header.value;
        }
        var docSetResult = this.pk.gqlQuerySync('{docSet(id: "'.concat(docSetId, '") {selectors {key value}}}'));
        var selectors = {};
        for (var selector of docSetResult.data.docSet.selectors) {
          selectors[selector.key] = selector.value;
        }
        context.document = {
          id: docId,
          schema: {
            "structure": "flat",
            "structure_version": "0.2.1",
            "constraints": [{
              "name": "perf",
              "version": "0.2.1"
            }]
          },
          metadata: {
            translation: {
              id: docSetId,
              selectors,
              properties: {},
              tags: []
            },
            document: _objectSpread(_objectSpread({}, headers), {}, {
              properties: {},
              tags: []
            })
          },
          mainSequenceId: mainId,
          nSequences
        };
        context.sequences = [];
        this.renderEvent("startDocument", environment);
        this.renderSequenceId(environment, mainId);
        this.renderEvent("endDocument", environment);
      }
      sequenceContext(sequence, sequenceId) {
        return {
          id: sequenceId,
          type: camelCaseToSnakeCase(sequence.type),
          nBlocks: sequence.nBlocks,
          milestones: /* @__PURE__ */ new Set([])
        };
      }
      renderSequenceId(environment, sequenceId) {
        var context = environment.context;
        var documentResult = this.pk.gqlQuerySync('{document(id: "'.concat(context.document.id, '") {sequence(id:"').concat(sequenceId, '") {id type nBlocks } } }'));
        var sequence = documentResult.data.document.sequence;
        if (!sequence) {
          throw new Error("Sequence '".concat(sequenceId, "' not found in renderSequenceId()"));
        }
        context.sequences.unshift(this.sequenceContext(sequence, sequenceId));
        this.renderEvent("startSequence", environment);
        var outputBlockN = 0;
        for (var inputBlockN = 0; inputBlockN < sequence.nBlocks; inputBlockN++) {
          var blocksResult = this.pk.gqlQuerySync('{\n               document(id: "'.concat(context.document.id, '") {\n                 sequence(id:"').concat(sequenceId, '") {\n                   blocks(positions:').concat(inputBlockN, ") {\n                     bg {subType payload}\n                     bs {payload}\n                     items {type subType payload}\n                   }\n                 }\n               }\n             }"));
          var blockResult = blocksResult.data.document.sequence.blocks[0];
          for (var blockGraft of blockResult.bg) {
            context.sequences[0].block = {
              type: "graft",
              subType: camelCaseToSnakeCase(blockGraft.subType),
              blockN: outputBlockN
            };
            context.sequences[0].block.target = blockGraft.payload;
            context.sequences[0].block.isNew = false;
            this.renderEvent("blockGraft", environment);
            outputBlockN++;
          }
          context.sequences[0].block = {
            type: "paragraph",
            subType: "usfm:".concat(blockResult.bs.payload.split("/")[1]),
            blockN: outputBlockN,
            wrappers: []
          };
          this.renderEvent("startParagraph", environment);
          this._tokens = [];
          this.renderContent(blockResult.items, environment);
          this._tokens = [];
          this.renderEvent("endParagraph", environment);
          delete context.sequences[0].block;
          outputBlockN++;
        }
        this.renderEvent("endSequence", environment);
        context.sequences.shift();
      }
      renderContent(items, environment) {
        for (var item of items) {
          this.renderItem(item, environment);
        }
        this.maybeRenderText(environment);
      }
      renderItem(item, environment) {
        if (item.type === "scope" && item.payload.startsWith("attribute")) {
          var scopeBits = item.payload.split("/");
          if (item.subType === "start") {
            if (!this._container) {
              this._container = {
                direction: "start",
                subType: "usfm:w",
                type: "wrapper",
                atts: {}
              };
            }
            if (scopeBits[3] in this._container.atts) {
              this._container.atts[scopeBits[3]].push(scopeBits[5]);
            } else {
              this._container.atts[scopeBits[3]] = [scopeBits[5]];
            }
          } else {
            if (!this._container) {
              this._container = {
                direction: "end",
                subType: "usfm:".concat(camelCaseToSnakeCase(scopeBits[2]))
              };
              if (scopeBits[1] === "milestone") {
                this._container.type = "end_milestone";
              } else {
                this._container.type = "wrapper";
                this._container.atts = {};
              }
            }
          }
        } else {
          if (this._container) {
            this.maybeRenderText(environment);
            this.renderContainer(environment);
          }
          if (item.type === "token") {
            this._tokens.push(item.payload.replace(/\s+/g, " "));
          } else {
            if (item.type === "graft") {
              this.maybeRenderText(environment);
              var graft = {
                type: "graft",
                subType: camelCaseToSnakeCase(item.subType),
                target: item.payload,
                isNew: false
              };
              environment.context.sequences[0].element = graft;
              this.renderEvent("inlineGraft", environment);
              delete environment.context.sequences[0].element;
            } else {
              this.maybeRenderText(environment);
              var _scopeBits = item.payload.split("/");
              if (["chapter", "verses", "pubChapter", "pubVerse", "altChapter", "altVerse"].includes(_scopeBits[0])) {
                if (item.subType === "start") {
                  var mark = {
                    type: "mark",
                    subType: camelCaseToSnakeCase(_scopeBits[0]),
                    atts: {
                      number: _scopeBits[1]
                    }
                  };
                  environment.context.sequences[0].element = mark;
                  this.renderEvent("mark", environment);
                  delete environment.context.sequences[0].element;
                }
              } else if (_scopeBits[0] === "span") {
                var wrapper = {
                  type: "wrapper",
                  subType: "usfm:".concat(_scopeBits[1]),
                  atts: {}
                };
                environment.context.sequences[0].element = wrapper;
                if (item.subType === "start") {
                  environment.context.sequences[0].block.wrappers.unshift(wrapper.subType);
                  this.renderEvent("startWrapper", environment);
                } else {
                  this.renderEvent("endWrapper", environment);
                  environment.context.sequences[0].block.wrappers.shift();
                }
                delete environment.context.sequences[0].element;
              } else if (_scopeBits[0] === "spanWithAtts") {
                if (item.subType === "start") {
                  this._container = {
                    direction: "start",
                    type: "wrapper",
                    subType: "usfm:".concat(_scopeBits[1]),
                    atts: {}
                  };
                }
              } else if (_scopeBits[0] === "milestone" && item.subType === "start") {
                if (_scopeBits[1] === "ts") {
                  var _mark = {
                    type: "mark",
                    subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
                    atts: {}
                  };
                  environment.context.sequences[0].element = _mark;
                  this.renderEvent("mark", environment);
                  delete environment.context.sequences[0].element;
                } else {
                  this._container = {
                    type: "start_milestone",
                    subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
                    atts: {}
                  };
                }
              }
            }
          }
        }
      }
      maybeRenderText(environment) {
        if (this._tokens.length === 0) {
          return;
        }
        var elementContext = {
          type: "text",
          text: this._tokens.join("")
        };
        environment.context.sequences[0].element = elementContext;
        this._tokens = [];
        this.renderEvent("text", environment);
        delete environment.context.sequences[0].element;
      }
      renderContainer(environment) {
        if (this._container.type === "wrapper") {
          var direction = this._container.direction;
          delete this._container.direction;
          if (direction === "start") {
            environment.context.sequences[0].element = this._container;
            environment.context.sequences[0].block.wrappers.unshift(this._container.subType);
            this.renderEvent("startWrapper", environment);
            delete environment.context.sequences[0].element;
          } else {
            environment.context.sequences[0].element = this._container;
            this.renderEvent("endWrapper", environment);
            environment.context.sequences[0].block.wrappers.shift();
            delete environment.context.sequences[0].element;
          }
        } else if (this._container.type === "start_milestone") {
          environment.context.sequences[0].element = this._container;
          this.renderEvent("startMilestone", environment);
          delete environment.context.sequences[0].element;
        } else if (this._container.type === "end_milestone") {
          environment.context.sequences[0].element = this._container;
          this.renderEvent("endMilestone", environment);
          delete environment.context.sequences[0].element;
        }
        this._container = null;
      }
    };
    module.exports = PerfRenderFromProskomma;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/SofriaRenderFromJson.js
var require_SofriaRenderFromJson = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/SofriaRenderFromJson.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var ProskommaRender = require_ProskommaRender();
    var SofriaRenderFromJson = class extends ProskommaRender {
      constructor(spec) {
        super(spec);
        if (!spec.srcJson) {
          throw new Error("Must provide srcJson");
        }
        this.srcJson = spec.srcJson;
        this.cachedSequences = [];
      }
      renderDocument1(_ref) {
        var {
          docId,
          config: config2,
          context,
          workspace,
          output
        } = _ref;
        var environment = {
          config: config2,
          context,
          workspace,
          output
        };
        context.renderer = this;
        context.document = {
          id: docId,
          schema: this.srcJson.schema,
          metadata: this.srcJson.metadata
        };
        context.sequences = [];
        this.renderEvent("startDocument", environment);
        this.renderSequence(environment, this.srcJson.sequence);
        this.renderEvent("endDocument", environment);
      }
      sequenceContext(sequence) {
        return {
          type: sequence.type,
          nBlocks: sequence.blocks.length,
          milestones: /* @__PURE__ */ new Set([])
        };
      }
      renderSequence(environment, providedSequence) {
        var sequence;
        if (!providedSequence) {
          if (this.cachedSequences.length === 0) {
            throw new Error("No sequence provided and no sequences cached");
          }
          sequence = this.cachedSequences[0];
        } else {
          sequence = providedSequence;
        }
        var context = environment.context;
        context.sequences.unshift(sequence);
        this.renderEvent("startSequence", environment);
        for (var [blockN, block2] of sequence.blocks.entries()) {
          context.sequences[0].block = {
            type: block2.type,
            blockN,
            wrappers: []
          };
          if (block2.type === "graft") {
            context.sequences[0].block.sequence = this.sequenceContext(block2.sequence);
            this.cachedSequences.unshift(block2.sequence);
            this.renderEvent("blockGraft", environment);
            this.cachedSequences.shift();
          } else {
            this.renderEvent("startParagraph", environment);
            this.renderContent(block2.content, environment);
            this.renderEvent("endParagraph", environment);
          }
          delete context.sequences[0].block;
        }
        this.renderEvent("endSequence", environment);
        this.cachedSequence = null;
        context.sequences.shift();
      }
      renderContent(content, environment) {
        for (var element of content) {
          this.renderElement(element, environment);
        }
      }
      renderElement(element, environment) {
        var maybeRenderMetaContent = (elementContext2) => {
          if (element.meta_content) {
            elementContext2.metaContent = element.meta_content;
            this.renderEvent("metaContent", environment);
          }
        };
        var context = environment.context;
        var elementContext = {
          type: element.type || "text"
        };
        if (element.subtype) {
          elementContext.subType = element.subtype;
        }
        if (element.atts) {
          elementContext.atts = element.atts;
        } else if (elementContext.type !== "end_milestone" && elementContext.type !== "meta_content") {
          elementContext.atts = {};
        }
        if (element.sequence) {
          elementContext.sequence = this.sequenceContext(element.sequence);
        }
        if (elementContext.type === "text") {
          elementContext.text = element;
        }
        context.sequences[0].element = elementContext;
        if (elementContext.type === "text") {
          this.renderEvent("text", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "mark") {
          this.renderEvent("mark", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "start_milestone") {
          this.renderEvent("startMilestone", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "end_milestone") {
          this.renderEvent("endMilestone", environment);
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "graft") {
          this.cachedSequences.unshift(element.sequence);
          this.renderEvent("inlineGraft", environment);
          this.cachedSequences.shift();
          maybeRenderMetaContent(elementContext);
        } else if (elementContext.type === "wrapper") {
          context.sequences[0].block.wrappers.unshift(elementContext.subType);
          this.renderEvent("startWrapper", environment);
          this.renderContent(element.content, environment);
          context.sequences[0].element = elementContext;
          maybeRenderMetaContent(elementContext);
          this.renderEvent("endWrapper", environment);
          context.sequences[0].block.wrappers.shift();
        } else {
          throw new Error("Unexpected element type '".concat(elementContext.type));
        }
        delete context.sequences[0].element;
      }
    };
    module.exports = SofriaRenderFromJson;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/SofriaRenderFromProskomma.js
var require_SofriaRenderFromProskomma = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/SofriaRenderFromProskomma.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ProskommaRender = require_ProskommaRender();
    var camelCaseToSnakeCase = (s) => {
      var ret = [];
      for (var c of s.split("")) {
        if (c.toUpperCase() === c && c.toLowerCase() !== c) {
          ret.push("_".concat(c.toLowerCase()));
        } else {
          ret.push(c);
        }
      }
      return ret.join("");
    };
    var SofriaRenderFromProskomma = class extends ProskommaRender {
      constructor(spec) {
        super(spec);
        if (!spec.proskomma) {
          throw new Error("No Proskomma");
        }
        this.pk = spec.proskomma;
        this._tokens = [];
        this._container = null;
        this.cachedSequenceIds = [];
        this.sequences = null;
        this.currentCV = {
          chapter: null,
          verses: null
        };
      }
      renderDocument1(_ref) {
        var {
          docId,
          config: config2,
          context,
          workspace,
          output
        } = _ref;
        var environment = {
          config: config2,
          context,
          workspace,
          output
        };
        context.renderer = this;
        var documentResult = this.pk.gqlQuerySync('{\n          document(id: "'.concat(docId, '") {\n            docSetId\n            mainSequence { id }\n            nSequences\n            sequences {\n              id\n              type\n              nBlocks\n            }\n            headers {\n              key\n              value\n            }\n          } \n        }'));
        var docSetId = documentResult.data.document.docSetId;
        var mainId = documentResult.data.document.mainSequence.id;
        var nSequences = documentResult.data.document.nSequences;
        this.sequences = {};
        for (var seq of documentResult.data.document.sequences) {
          this.sequences[seq.id] = seq;
        }
        var headers = {};
        for (var header of documentResult.data.document.headers) {
          headers[header.key] = header.value;
        }
        var docSetResult = this.pk.gqlQuerySync('{docSet(id: "'.concat(docSetId, '") {selectors {key value}}}'));
        var selectors = {};
        for (var selector of docSetResult.data.docSet.selectors) {
          selectors[selector.key] = selector.value;
        }
        context.document = {
          id: docId,
          schema: {
            "structure": "nested",
            "structure_version": "0.2.1",
            "constraints": [{
              "name": "sofria",
              "version": "0.2.1"
            }]
          },
          metadata: {
            translation: {
              id: docSetId,
              selectors,
              properties: {},
              tags: []
            },
            document: _objectSpread(_objectSpread({}, headers), {}, {
              properties: {},
              tags: []
            })
          },
          mainSequenceId: mainId,
          nSequences
        };
        if (config2.chapters) {
          context.document.metadata.document.properties.chapters = config2.chapters[0];
        }
        context.sequences = [];
        this.renderEvent("startDocument", environment);
        this.cachedSequenceIds.unshift(mainId);
        this.renderSequence(environment, mainId);
        this.cachedSequenceIds.shift();
        this.renderEvent("endDocument", environment);
      }
      sequenceContext(sequence, sequenceId) {
        return {
          id: sequenceId,
          type: camelCaseToSnakeCase(sequence.type),
          nBlocks: sequence.nBlocks,
          milestones: /* @__PURE__ */ new Set([])
        };
      }
      renderSequence(environment) {
        var context = environment.context;
        var sequenceId = this.cachedSequenceIds[0];
        var documentResult = this.pk.gqlQuerySync('{document(id: "'.concat(context.document.id, '") {sequence(id:"').concat(sequenceId, '") {id type nBlocks blocks { os {payload} is {payload} } } } }'));
        var sequence = documentResult.data.document.sequence;
        if (!sequence) {
          throw new Error("Sequence '".concat(sequenceId, "' not found in renderSequenceId()"));
        }
        context.sequences.unshift(this.sequenceContext(sequence, sequenceId));
        this.renderEvent("startSequence", environment);
        var outputBlockN = 0;
        for (var inputBlockN = 0; inputBlockN < sequence.nBlocks; inputBlockN++) {
          if (environment.config.chapters && sequence.type === "main") {
            var chapterScopes = [...sequence.blocks[inputBlockN].os.map((s) => s.payload), ...sequence.blocks[inputBlockN].is.map((s) => s.payload)].filter((s) => ["chapter"].includes(s.split("/")[0])).map((s) => s.split("/")[1]);
            if (chapterScopes.length === 0 || !environment.config.chapters.includes(chapterScopes[0])) {
              continue;
            }
          }
          var blocksResult = this.pk.gqlQuerySync('{\n               document(id: "'.concat(context.document.id, '") {\n                 sequence(id:"').concat(sequenceId, '") {\n                   blocks(positions:').concat(inputBlockN, ") {\n                     bg {subType payload}\n                     bs {payload}\n                     items {type subType payload}\n                   }\n                 }\n               }\n             }"));
          var blockResult = blocksResult.data.document.sequence.blocks[0];
          for (var blockGraft of blockResult.bg) {
            context.sequences[0].block = {
              type: "graft",
              subType: camelCaseToSnakeCase(blockGraft.subType),
              blockN: outputBlockN,
              sequence: this.sequences[blockGraft.payload]
            };
            this.cachedSequenceIds.unshift(blockGraft.payload);
            this.renderEvent("blockGraft", environment);
            this.cachedSequenceIds.shift();
            outputBlockN++;
          }
          var subTypeValues = blockResult.bs.payload.split("/");
          var subTypeValue = subTypeValues[1] ? "usfm:".concat(subTypeValues[1]) : subTypeValues[0];
          context.sequences[0].block = {
            type: "paragraph",
            subType: subTypeValue,
            blockN: outputBlockN,
            wrappers: []
          };
          this.renderEvent("startParagraph", environment);
          this._tokens = [];
          if (sequence.type === "main" && this.currentCV.chapter) {
            var wrapper = {
              type: "wrapper",
              subType: "chapter",
              atts: {
                number: this.currentCV.chapter
              }
            };
            environment.context.sequences[0].element = wrapper;
            environment.context.sequences[0].block.wrappers.unshift(wrapper.subType);
            this.renderEvent("startWrapper", environment);
          }
          if (sequence.type === "main" && this.currentCV.verses) {
            var _wrapper = {
              type: "wrapper",
              subType: "verses",
              atts: {
                number: this.currentCV.verses
              }
            };
            environment.context.sequences[0].element = _wrapper;
            environment.context.sequences[0].block.wrappers.unshift(_wrapper.subType);
            this.renderEvent("startWrapper", environment);
          }
          this.renderContent(blockResult.items, environment);
          this._tokens = [];
          if (sequence.type === "main" && this.currentCV.verses) {
            var _wrapper2 = {
              type: "wrapper",
              subType: "verses",
              atts: {
                number: this.currentCV.verses
              }
            };
            environment.context.sequences[0].element = _wrapper2;
            environment.context.sequences[0].block.wrappers.shift();
            this.renderEvent("endWrapper", environment);
          }
          if (sequence.type === "main" && this.currentCV.chapter) {
            var _wrapper3 = {
              type: "wrapper",
              subType: "chapter",
              atts: {
                number: this.currentCV.chapter
              }
            };
            environment.context.sequences[0].element = _wrapper3;
            environment.context.sequences[0].block.wrappers.shift();
            this.renderEvent("endWrapper", environment);
          }
          this.renderEvent("endParagraph", environment);
          delete context.sequences[0].block;
          outputBlockN++;
        }
        this.renderEvent("endSequence", environment);
        context.sequences.shift();
      }
      renderContent(items, environment) {
        for (var item of items) {
          this.renderItem(item, environment);
        }
        this.maybeRenderText(environment);
      }
      renderItem(item, environment) {
        if (item.type === "scope" && item.payload.startsWith("attribute")) {
          var scopeBits = item.payload.split("/");
          if (item.subType === "start") {
            if (!this._container) {
              this._container = {
                direction: "start",
                subType: "usfm:w",
                type: "wrapper",
                atts: {}
              };
            }
            if (scopeBits[3] in this._container.atts) {
              this._container.atts[scopeBits[3]].push(scopeBits[5]);
            } else {
              this._container.atts[scopeBits[3]] = [scopeBits[5]];
            }
          } else {
            if (!this._container) {
              this._container = {
                direction: "end",
                subType: "usfm:".concat(camelCaseToSnakeCase(scopeBits[2]))
              };
              if (scopeBits[1] === "milestone") {
                this._container.type = "end_milestone";
              } else {
                this._container.type = "wrapper";
                this._container.atts = {};
              }
            }
          }
        } else {
          if (this._container) {
            this.maybeRenderText(environment);
            this.renderContainer(environment);
          }
          if (item.type === "token") {
            this._tokens.push(item.payload.replace(/\s+/g, " "));
          } else if (item.type === "graft") {
            this.maybeRenderText(environment);
            var graft = {
              type: "graft",
              subType: camelCaseToSnakeCase(item.subType),
              sequence: this.sequences[item.payload]
            };
            environment.context.sequences[0].element = graft;
            this.cachedSequenceIds.unshift(item.payload);
            this.renderEvent("inlineGraft", environment);
            this.cachedSequenceIds.shift();
            delete environment.context.sequences[0].element;
          } else {
            this.maybeRenderText(environment);
            var _scopeBits = item.payload.split("/");
            if (["chapter", "verses"].includes(_scopeBits[0])) {
              var wrapper = {
                type: "wrapper",
                subType: camelCaseToSnakeCase(_scopeBits[0]),
                atts: {
                  number: _scopeBits[1]
                }
              };
              environment.context.sequences[0].element = wrapper;
              if (item.subType === "start") {
                this.currentCV[_scopeBits[0]] = _scopeBits[1];
                environment.context.sequences[0].block.wrappers.unshift(wrapper.subType);
                this.renderEvent("startWrapper", environment);
                var cvMark = {
                  "type": "mark",
                  "subType": "".concat(_scopeBits[0], "_label"),
                  "atts": {
                    "number": _scopeBits[1]
                  }
                };
                environment.context.sequences[0].element = cvMark;
                this.renderEvent("mark", environment);
                environment.context.sequences[0].element = wrapper;
              } else {
                this.renderEvent("endWrapper", environment);
                environment.context.sequences[0].block.wrappers.shift();
                delete environment.context.sequences[0].element;
                this.currentCV[_scopeBits[0]] = null;
              }
            } else if (["pubChapter", "pubVerse", "altChapter", "altVerse"].includes(_scopeBits[0])) {
              if (item.subType === "start") {
                var mark = {
                  type: "mark",
                  subType: camelCaseToSnakeCase(_scopeBits[0]),
                  atts: {
                    number: _scopeBits[1]
                  }
                };
                environment.context.sequences[0].element = mark;
                this.renderEvent("mark", environment);
                delete environment.context.sequences[0].element;
              }
            } else if (_scopeBits[0] === "span") {
              var _wrapper4 = {
                type: "wrapper",
                subType: "usfm:".concat(_scopeBits[1]),
                atts: {}
              };
              environment.context.sequences[0].element = _wrapper4;
              if (item.subType === "start") {
                environment.context.sequences[0].block.wrappers.unshift(_wrapper4.subType);
                this.renderEvent("startWrapper", environment);
              } else {
                this.renderEvent("endWrapper", environment);
                environment.context.sequences[0].block.wrappers.shift();
              }
              delete environment.context.sequences[0].element;
            } else if (_scopeBits[0] === "spanWithAtts") {
              if (item.subType === "start") {
                this._container = {
                  direction: "start",
                  type: "wrapper",
                  subType: "usfm:".concat(_scopeBits[1]),
                  atts: {}
                };
              }
            } else if (_scopeBits[0] === "milestone" && item.subType === "start") {
              if (_scopeBits[1] === "ts") {
                var _mark = {
                  type: "mark",
                  subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
                  atts: {}
                };
                environment.context.sequences[0].element = _mark;
                this.renderEvent("mark", environment);
                delete environment.context.sequences[0].element;
              } else {
                this._container = {
                  type: "start_milestone",
                  subType: "usfm:".concat(camelCaseToSnakeCase(_scopeBits[1])),
                  atts: {}
                };
              }
            }
          }
        }
      }
      maybeRenderText(environment) {
        if (this._tokens.length === 0) {
          return;
        }
        var elementContext = {
          type: "text",
          text: this._tokens.join("")
        };
        environment.context.sequences[0].element = elementContext;
        this._tokens = [];
        this.renderEvent("text", environment);
        delete environment.context.sequences[0].element;
      }
      renderContainer(environment) {
        if (this._container.type === "wrapper") {
          var direction = this._container.direction;
          delete this._container.direction;
          if (direction === "start") {
            environment.context.sequences[0].element = this._container;
            environment.context.sequences[0].block.wrappers.unshift(this._container.subType);
            this.renderEvent("startWrapper", environment);
            delete environment.context.sequences[0].element;
          } else {
            environment.context.sequences[0].element = this._container;
            this.renderEvent("endWrapper", environment);
            environment.context.sequences[0].block.wrappers.shift();
            delete environment.context.sequences[0].element;
          }
        } else if (this._container.type === "start_milestone") {
          environment.context.sequences[0].element = this._container;
          this.renderEvent("startMilestone", environment);
          delete environment.context.sequences[0].element;
        } else if (this._container.type === "end_milestone") {
          environment.context.sequences[0].element = this._container;
          this.renderEvent("endMilestone", environment);
          delete environment.context.sequences[0].element;
        }
        this._container = null;
      }
    };
    module.exports = SofriaRenderFromProskomma;
  }
});

// node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/index.js
var require_dist = __commonJS({
  "node_modules/proskomma-core/node_modules/proskomma-json-tools/dist/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Validator = require_validator();
    var usfmHelps = require_usfmHelps();
    var PipelineHandler = require_PipelineHandler();
    var ProskommaRender = require_ProskommaRender();
    var PerfRenderFromJson2 = require_PerfRenderFromJson();
    var PerfRenderFromProskomma = require_PerfRenderFromProskomma();
    var SofriaRenderFromJson = require_SofriaRenderFromJson();
    var SofriaRenderFromProskomma = require_SofriaRenderFromProskomma();
    var mergeActions = require_mergeActions();
    var pipelines = require_pipelines();
    var render = require_render();
    module.exports = {
      Validator,
      usfmHelps,
      ProskommaRender,
      PerfRenderFromJson: PerfRenderFromJson2,
      SofriaRenderFromJson,
      SofriaRenderFromProskomma,
      PerfRenderFromProskomma,
      mergeActions,
      PipelineHandler,
      pipelines,
      render
    };
  }
});

// node_modules/proskomma-core/src/parser/lexers/lexingRegexes.cjs
var require_lexingRegexes = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/lexingRegexes.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var lexingRegexes2 = [
      ["chapter", "chapter", xre("([\\r\\n]*\\\\c[ \\t]+(\\d+)[ \\t\\r\\n]*)")],
      [
        "pubchapter",
        "pubchapter",
        xre("([\\r\\n]*\\\\cp[ \\t]+([^\\r\\n]+)[ \\t\\r\\n]*)")
      ],
      ["verses", "verses", xre("(\\\\v[ \\t]+([\\d\\-]+)[ \\t\\r\\n]*)")],
      [
        "attribute",
        "attribute",
        xre('([ \\t]*\\|?[ \\t]*([A-Za-z0-9\\-]+)="([^"]*)"[ \\t]?)')
      ],
      [
        "attribute",
        "defaultAttribute",
        xre("([ \\t]*\\|[ \\t]*([^\\|\\\\]*))")
      ],
      ["milestone", "emptyMilestone", xre("(\\\\([a-z1-9]+)\\\\[*])")],
      ["milestone", "startMilestoneTag", xre("(\\\\([a-z1-9]+)-([se]))")],
      ["milestone", "endMilestoneMarker", xre("(\\\\([*]))")],
      ["tag", "endTag", xre("(\\\\([+]?[a-z\\-]+)([1-9]?(-([1-9]))?)[*])")],
      ["tag", "startTag", xre("(\\\\([+]?[a-z\\-]+)([1-9]?(-([1-9]))?)[ \\t]?)")],
      ["bad", "bareSlash", xre("(\\\\)")],
      ["printable", "eol", xre("([ \\t]*[\\r\\n]+[ \\t]*)")],
      ["break", "noBreakSpace", xre("~")],
      ["break", "softLineBreak", xre("//")],
      [
        "printable",
        "wordLike",
        xre("([\\p{Letter}\\p{Number}\\p{Mark}\\u2060]{1,127})")
      ],
      ["printable", "lineSpace", xre("([\\p{Separator}	]{1,127})")],
      ["printable", "punctuation", xre("([\\p{Punctuation}\\p{Math_Symbol}\\p{Currency_Symbol}\\p{Modifier_Symbol}\\p{Other_Symbol}])")],
      ["bad", "unknown", xre("(.)")]
    ];
    var mainRegex = xre.union(lexingRegexes2.map((x) => x[2]));
    module.exports = {
      lexingRegexes: lexingRegexes2,
      mainRegex
    };
  }
});

// node_modules/proskomma-core/src/parser/lexers/object_for_fragment.cjs
var require_object_for_fragment = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/object_for_fragment.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var makePrintable = (subclass, matchedBits) => ({
      subclass,
      printValue: matchedBits[0]
    });
    var makeChapter = (subclass, matchedBits) => ({
      subclass,
      numberString: matchedBits[2],
      number: parseInt(matchedBits[2]),
      printValue: `\\c ${matchedBits[2]}
`
    });
    var makeVerses = (subclass, matchedBits) => {
      const ret = {
        subclass,
        numberString: matchedBits[2],
        printValue: `\\v ${matchedBits[2]}
`
      };
      if (ret.numberString.includes("-")) {
        const [fromV, toV] = ret.numberString.split("-").map((v) => parseInt(v));
        ret.numbers = Array.from(Array(toV - fromV + 1).keys()).map((v) => v + fromV);
      } else {
        ret.numbers = [parseInt(ret.numberString)];
      }
      return ret;
    };
    var makeAttribute = (subclass, matchedBits) => {
      let ret;
      if (subclass === "defaultAttribute") {
        ret = {
          subclass,
          key: "default",
          valueString: matchedBits[2].trim().replace(/\//g, "÷")
        };
      } else {
        ret = {
          subclass,
          key: matchedBits[2],
          valueString: matchedBits[3].trim().replace(/\//g, "÷")
        };
      }
      ret.values = ret.valueString.split(",").map((vb) => vb.trim());
      ret.printValue = `| ${ret.key}="${ret.valueString}"`;
      return ret;
    };
    var makePubChapter = (subclass, matchedBits) => ({
      subclass,
      numberString: matchedBits[2],
      printValue: `\\cp ${matchedBits[2]}
`
    });
    var makeMilestone = (subclass, matchedBits) => {
      const ret = {
        subclass,
        sOrE: null
      };
      if (subclass === "endMilestoneMarker") {
        ret.printValue = "\\*";
      } else {
        ret.tagName = matchedBits[2];
        if (subclass === "emptyMilestone") {
          ret.printValue = `\\${ret.tagName}\\*`;
        } else {
          ret.printValue = `\\${ret.tagName}`;
          ret.sOrE = matchedBits[3];
        }
      }
      return ret;
    };
    var makeTag = (subclass, matchedBits) => {
      const ret = {
        subclass,
        tagName: matchedBits[2],
        isNested: false
      };
      if (ret.tagName.startsWith("+")) {
        ret.isNested = true;
        ret.tagName = ret.tagName.substring(1);
      }
      ret.tagLevel = matchedBits[3] !== "" ? parseInt(matchedBits[3]) : 1;
      ret.fullTagName = `${ret.tagName}${matchedBits[3] === "1" ? "" : matchedBits[3]}`;
      ret.printValue = subclass === "startTag" ? `\\${ret.fullTagName} ` : `\\${ret.fullTagName}*`;
      return ret;
    };
    var constructorForFragment = {
      printable: makePrintable,
      chapter: makeChapter,
      pubchapter: makePubChapter,
      verses: makeVerses,
      tag: makeTag,
      break: makePrintable,
      milestone: makeMilestone,
      attribute: makeAttribute,
      bad: makePrintable
    };
    var preTokenObjectForFragment = (fragment, lexingRegexes2) => {
      for (let n = 0; n < lexingRegexes2.length; n++) {
        let [tClass, tSubclass, tRE] = lexingRegexes2[n];
        let matchedBits = xre.exec(fragment, tRE, 0, "sticky");
        if (matchedBits) {
          return constructorForFragment[tClass](tSubclass, matchedBits);
        }
      }
      throw new Error(`Could not match preToken fragment '${fragment}'`);
    };
    module.exports = {
      constructorForFragment,
      preTokenObjectForFragment
    };
  }
});

// node_modules/proskomma-core/src/parser/lexers/usfm.cjs
var require_usfm = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/usfm.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var {
      lexingRegexes: lexingRegexes2,
      mainRegex
    } = require_lexingRegexes();
    var { preTokenObjectForFragment } = require_object_for_fragment();
    var parseUsfm = (str, parser) => {
      const matches = xre.match(str, mainRegex, "all");
      for (let n = 0; n < matches.length; n++) {
        parser.parseItem(preTokenObjectForFragment(matches[n], lexingRegexes2));
      }
    };
    module.exports = { parseUsfm };
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_process();
    init_buffer();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version2, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process2 = __esm({
  "node-modules-polyfills:process"() {
    init_process();
    init_buffer();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version2 = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version: version2,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect2(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect2(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect2(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue2(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect2.styles[styleType];
  if (style) {
    return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue2(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== inspect2 && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError2(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError2(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError2(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray2(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError2(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray2(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty2(value, String(i))) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_process();
    init_buffer();
    init_process2();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect2.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect2.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer2 = __esm({
  "node-modules-polyfills:buffer"() {
    init_process();
    init_buffer();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect3() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_process();
    init_buffer();
    init_buffer2();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
var string_decoder_exports = {};
__export(string_decoder_exports, {
  StringDecoder: () => StringDecoder
});
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_process();
    init_buffer();
    init_buffer2();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process2();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_process();
    init_buffer();
    init_util();
    init_buffer2();
    init_events();
    init_duplex();
    init_process2();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_process();
    init_buffer();
    init_util();
    init_process2();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_process();
    init_buffer();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_process();
    init_buffer();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_process();
    init_buffer();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node-modules-polyfills-commonjs:string_decoder
var require_string_decoder = __commonJS({
  "node-modules-polyfills-commonjs:string_decoder"(exports, module) {
    init_process();
    init_buffer();
    var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    init_process();
    init_buffer();
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit3(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write: write3,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream2;
      try {
        Stream2 = require_stream().Stream;
      } catch (ex) {
        Stream2 = function() {
        };
      }
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream2.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream2.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream2.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit3(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit3(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit3(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit3(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit3(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write3(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/proskomma-core/src/parser/lexers/usx/usx_lexer.cjs
var require_usx_lexer = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/usx/usx_lexer.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var sax = require_sax();
    var {
      lexingRegexes: lexingRegexes2,
      mainRegex
    } = require_lexingRegexes();
    var {
      preTokenObjectForFragment,
      constructorForFragment
    } = require_object_for_fragment();
    var UsxLexer = class {
      constructor() {
        this.sax = sax.parser(true);
        this.sax.ontext = (text) => this.handleSaxText(text);
        this.sax.onopentag = (ot) => this.handleSaxOpenTag(ot);
        this.sax.onclosetag = (ct) => this.handleSaxCloseTag(ct);
        this.lexed = [];
        this.elementStack = [];
        this.currentText = "";
        this.openTagHandlers = {
          usx: this.ignoreHandler,
          book: this.handleBookOpen,
          chapter: this.handleChapter,
          verse: this.handleVerses,
          para: this.handleParaOpen,
          table: this.ignoreHandler,
          row: this.handleRowOpen,
          cell: this.handleCellOpen,
          char: this.handleCharOpen,
          ms: this.handleMSOpen,
          note: this.handleNoteOpen,
          sidebar: this.handleSidebarOpen,
          periph: this.notHandledHandler,
          figure: this.handleFigureOpen,
          optbreak: this.handleOptBreakOpen,
          ref: this.ignoreHandler
          // this.handleRefOpen,
        };
        this.closeTagHandlers = {
          usx: this.ignoreHandler,
          book: this.handleBookClose,
          chapter: this.ignoreHandler,
          verse: this.ignoreHandler,
          para: this.handleParaClose,
          table: this.ignoreHandler,
          row: this.handleRowClose,
          cell: this.handleCellClose,
          char: this.handleCharClose,
          ms: this.handleMSClose,
          note: this.handleNoteClose,
          sidebar: this.handleSidebarClose,
          periph: this.notHandledHandler,
          figure: this.handleFigureClose,
          optbreak: this.handleOptBreakClose,
          ref: this.ignoreHandler
          // this.handleRefClose,
        };
      }
      lexAndParse(str, parser) {
        this.parser = parser;
        this.lexed = [];
        this.elementStack = [];
        this.sax.write(str).close();
      }
      handleSaxText(text) {
        this.currentText = this.replaceEntities(text);
        xre.match(this.currentText, mainRegex, "all").map((f) => preTokenObjectForFragment(f, lexingRegexes2)).forEach((t) => this.parser.parseItem(t));
      }
      replaceEntities(text) {
        return text.replace("&lt;", "<").replace("&gt;", ">").replace("&apos;", "'").replace("&quot;", '"').replace("&amp;", "&");
      }
      handleSaxOpenTag(tagOb) {
        const name = tagOb.name;
        const atts = tagOb.attributes;
        if (name in this.openTagHandlers) {
          this.openTagHandlers[name](this, "open", name, atts);
        } else {
          throw new Error(`Unexpected open element tag '${name}' in UsxParser`);
        }
      }
      handleSaxCloseTag(name) {
        this.closeTagHandlers[name](this, "close", name);
      }
      notHandledHandler(lexer, oOrC, tag) {
        console.error(`WARNING: ${oOrC} element tag '${tag}' is not handled by UsxParser`);
      }
      stackPush(name, atts) {
        this.elementStack.push([name, atts]);
      }
      stackPop() {
        return this.elementStack.pop();
      }
      splitTagNumber(fullTagName) {
        const tagBits = xre.exec(fullTagName, xre("([^1-9]+)(.*)"));
        const tagName = tagBits[1];
        const tagNo = tagBits[2].length > 0 ? tagBits[2] : "1";
        return [tagName, tagNo];
      }
      ignoreHandler(lexer, oOrC, tag) {
      }
      handleParaOpen(lexer, oOrC, name, atts) {
        lexer.currentText = "";
        const [tagName, tagNo] = lexer.splitTagNumber(atts.style);
        if (!["cp"].includes(tagName)) {
          lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, tagName, tagNo]));
        }
        lexer.stackPush(name, atts);
      }
      handleParaClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        const [tagName, tagNo] = lexer.splitTagNumber(sAtts.style);
        if (["cp"].includes(tagName)) {
          lexer.parser.parseItem(constructorForFragment.pubchapter("pubchapter", [null, null, lexer.currentText]));
        } else {
          lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, tagName, tagNo]));
        }
        lexer.currentText = "";
      }
      handleCharOpen(lexer, oOrC, name, atts) {
        const [tagName, tagNo] = lexer.splitTagNumber(atts.style);
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, `+${tagName}`, tagNo]));
        const ignoredAtts = ["sid", "eid", "style", "srcloc", "link-href", "link-title", "link-id", "closed"];
        for (const [attName, attValue] of Object.entries(atts)) {
          if (!ignoredAtts.includes(attName)) {
            lexer.parser.parseItem(constructorForFragment.attribute("attribute", [null, null, attName, attValue]));
          }
        }
        lexer.stackPush(name, atts);
      }
      handleCharClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        const [tagName, tagNo] = lexer.splitTagNumber(sAtts.style);
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, `+${tagName}`, tagNo]));
      }
      handleRefOpen(lexer) {
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "xt", ""]));
      }
      handleRefClose(lexer) {
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "xt", ""]));
      }
      handleRowOpen(lexer, oOrC, name, atts) {
        const [tagName, tagNo] = lexer.splitTagNumber(atts.style);
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, tagName, tagNo]));
        lexer.stackPush(name, atts);
      }
      handleRowClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        const [tagName, tagNo] = lexer.splitTagNumber(sAtts.style);
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, tagName, tagNo]));
      }
      handleCellOpen(lexer, oOrC, name, atts) {
        const [tagName, tagNo] = lexer.splitTagNumber(atts.style);
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, tagName, tagNo]));
        lexer.stackPush(name, atts);
      }
      handleCellClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        const [tagName, tagNo] = lexer.splitTagNumber(sAtts.style);
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, tagName, tagNo]));
      }
      handleBookOpen(lexer, oOrC, name, atts) {
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "id", ""]));
        lexer.parser.parseItem(constructorForFragment.printable("wordLike", [atts.code]));
        lexer.parser.parseItem(constructorForFragment.printable("lineSpace", [" "]));
        lexer.stackPush(name, atts);
      }
      handleBookClose(lexer) {
        lexer.stackPop();
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "id", ""]));
      }
      handleChapter(lexer, oOrC, name, atts) {
        if (atts.number) {
          lexer.parser.parseItem(constructorForFragment.chapter("chapter", [null, null, atts.number]));
          if (atts.pubnumber) {
            lexer.parser.parseItem(constructorForFragment.pubchapter("pubchapter", [null, null, atts.pubnumber]));
          }
          if (atts.altnumber) {
            lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "+ca", ""]));
            lexer.parser.parseItem(constructorForFragment.printable("wordLike", [atts.altnumber]));
            lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "+ca", ""]));
          }
        }
      }
      handleVerses(lexer, oOrC, name, atts) {
        if (atts.number) {
          lexer.parser.parseItem(constructorForFragment.verses("verses", [null, null, atts.number]));
          if (atts.pubnumber) {
            lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "+vp", ""]));
            lexer.parser.parseItem(constructorForFragment.printable("wordLike", [atts.pubnumber]));
            lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "+vp", ""]));
          }
          if (atts.altnumber) {
            lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "+va", ""]));
            lexer.parser.parseItem(constructorForFragment.printable("wordLike", [atts.altnumber]));
            lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "+va", ""]));
          }
        }
      }
      handleNoteOpen(lexer, oOrC, name, atts) {
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, atts.style, ""]));
        lexer.parser.parseItem(constructorForFragment.printable("punctuation", [atts.caller]));
        lexer.stackPush(name, atts);
      }
      handleNoteClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, sAtts.style, ""]));
      }
      handleSidebarOpen(lexer, oOrC, name, atts) {
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "esb", ""]));
        if ("category" in atts) {
          lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "cat", ""]));
          lexer.parser.parseItem(constructorForFragment.printable("wordLike", [atts.category]));
          lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, "cat", ""]));
        }
        lexer.stackPush(name, atts);
      }
      handleSidebarClose(lexer) {
        lexer.stackPop();
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "esbe", ""]));
      }
      handleMSOpen(lexer, oOrC, name, atts) {
        let matchBits = xre.exec(atts.style, xre("(([a-z1-9]+)-([se]))"));
        if (matchBits) {
          const startMS = constructorForFragment.milestone("startMilestoneTag", [null, null, matchBits[2], matchBits[3]]);
          lexer.parser.parseItem(startMS);
          const ignoredAtts = ["sid", "eid", "style", "srcloc", "link-href", "link-title", "link-id"];
          for (const [attName, attValue] of Object.entries(atts)) {
            if (!ignoredAtts.includes(attName)) {
              lexer.parser.parseItem(constructorForFragment.attribute("attribute", [null, null, attName, attValue]));
            }
          }
          lexer.parser.parseItem(constructorForFragment.milestone("endMilestoneMarker"));
        } else {
          const emptyMS = constructorForFragment.milestone("emptyMilestone", [null, null, atts.style, ""]);
          lexer.parser.parseItem(emptyMS);
        }
        lexer.stackPush(name, atts);
      }
      handleMSClose(lexer) {
        lexer.stackPop();
      }
      handleFigureOpen(lexer, oOrC, name, atts) {
        lexer.parser.parseItem(constructorForFragment.tag("startTag", [null, null, "+fig", ""]));
        for (const [attName, attValue] of Object.entries(atts)) {
          if (attName === "style") {
            continue;
          }
          const scopeAttName = attName === "file" ? "src" : attName;
          lexer.parser.parseItem(constructorForFragment.attribute("attribute", [null, null, scopeAttName, attValue]));
        }
        lexer.stackPush(name, atts);
      }
      handleFigureClose(lexer) {
        const sAtts = lexer.stackPop()[1];
        lexer.parser.parseItem(constructorForFragment.tag("endTag", [null, null, `+fig`, ""]));
      }
      handleOptBreakOpen(lexer, oOrC, name, atts) {
        lexer.parser.parseItem(constructorForFragment.printable("softLineBreak", ["//"]));
        lexer.stackPush(name, atts);
      }
      handleOptBreakClose(lexer) {
        lexer.stackPop();
      }
    };
    module.exports = { UsxLexer };
  }
});

// node_modules/proskomma-core/src/parser/lexers/usx/index.cjs
var require_usx = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/usx/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { UsxLexer } = require_usx_lexer();
    var parseUsx = (str, parser) => {
      new UsxLexer().lexAndParse(str, parser);
    };
    module.exports = { parseUsx };
  }
});

// node_modules/proskomma-core/src/parser/model/index.cjs
var require_model = __commonJS({
  "node_modules/proskomma-core/src/parser/model/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var {
      pushSuccinctGraftBytes,
      pushSuccinctScopeBytes,
      pushSuccinctTokenBytes
    } = utils.succinct;
    var { addTag } = utils.tags;
    var { labelForScope } = utils.scopeDefs;
    var { itemEnum } = utils.itemDefs;
    var { scopeEnum } = utils.scopeDefs;
    var { tokenCategory, tokenEnum } = utils.tokenDefs;
    var Sequence = class {
      constructor(sType) {
        this.id = utils.generateId();
        this.type = sType;
        this.tags = /* @__PURE__ */ new Set([]);
        this.blocks = [];
        this.activeScopes = [];
      }
      addTag(tag) {
        addTag(this.tags, tag);
      }
      plainText() {
        return this.blocks.map((b) => b.plainText()).join("").trim();
      }
      addItem(i) {
        this.lastBlock().addItem(i);
      }
      addBlockGraft(g) {
        this.newBlock("hangingGraft");
        this.lastBlock().bg.push(g);
      }
      lastBlock() {
        if (this.blocks.length === 0) {
          this.newBlock("orphanTokens");
        }
        return this.blocks[this.blocks.length - 1];
      }
      newBlock(label) {
        if (this.blocks.length > 0 && ["orphanTokens", "hangingGraft"].includes(this.blocks[this.blocks.length - 1].bs.payload)) {
          this.lastBlock().bs = {
            type: "scope",
            subType: "start",
            payload: label
          };
        } else {
          this.blocks.push(new Block(label));
        }
      }
      trim() {
        this.blocks.forEach((b) => b.trim());
      }
      reorderSpanWithAtts() {
        this.blocks.forEach((b) => b.reorderSpanWithAtts());
      }
      makeNoteGrafts(parser) {
        this.blocks.forEach((b) => b.makeNoteGrafts(parser));
      }
      close(parser) {
        for (const activeScope of this.activeScopes.filter(() => true).reverse()) {
          this.closeActiveScope(parser, activeScope);
        }
        this.activeScopes = [];
      }
      closeActiveScope(parser, sc) {
        this.addItem({
          type: "scope",
          subType: "end",
          payload: sc.label
        });
        if (sc.onEnd) {
          sc.onEnd(parser, sc.label);
        }
      }
      filterGrafts(options) {
        return this.blocks.map((b) => b.filterGrafts(options)).reduce((acc, current) => acc.concat(current), []);
      }
      filterScopes(options) {
        this.blocks.forEach((b) => b.filterScopes(options));
      }
      text() {
        return this.blocks.map((b) => b.text()).join("");
      }
      addTableScopes() {
        let inTable = false;
        for (const [blockNo, block2] of this.blocks.entries()) {
          if (!inTable && block2.bs.payload === "blockTag/tr") {
            inTable = true;
            this.blocks[blockNo].items.unshift({
              type: "scope",
              subType: "start",
              payload: labelForScope("table", [])
            });
          } else if (inTable && block2.bs.payload !== "blockTag/tr") {
            inTable = false;
            this.blocks[blockNo - 1].items.push({
              type: "scope",
              subType: "end",
              payload: labelForScope("table", [])
            });
          }
        }
        if (inTable) {
          this.lastBlock().items.push({
            type: "scope",
            subType: "end",
            payload: labelForScope("table", [])
          });
        }
      }
      graftifyIntroductionHeadings(parser) {
        let blockEntries = [...this.blocks.entries()];
        blockEntries.reverse();
        const introHeadingTags = ["iot", "is"].concat(parser.customTags.introHeading);
        for (const [n, block2] of blockEntries) {
          const blockTag = block2.bs.payload.split("/")[1].replace(/[0-9]/g, "");
          if (introHeadingTags.includes(blockTag)) {
            const headingSequence = new Sequence("heading");
            parser.sequences.heading.push(headingSequence);
            headingSequence.blocks.push(block2);
            const headingGraft = {
              type: "graft",
              subType: "heading",
              payload: headingSequence.id
            };
            if (this.blocks.length < n + 2) {
              this.newBlock("blockTag/hangingGraft");
            }
            this.blocks[n + 1].bg.unshift(headingGraft);
            this.blocks.splice(n, 1);
          } else if (blockTag.startsWith("imt")) {
            const titleType = blockTag.startsWith("imte") ? "introEndTitle" : "introTitle";
            let titleSequence;
            if (parser.sequences[titleType]) {
              titleSequence = parser.sequences[titleType];
            } else {
              const graftType = blockTag.startsWith("imte") ? "endTitle" : "title";
              titleSequence = new Sequence(graftType);
              parser.sequences[titleType] = titleSequence;
              const titleGraft = {
                type: "graft",
                subType: graftType,
                payload: titleSequence.id
              };
              if (this.blocks.length < n + 2) {
                this.newBlock("blockTag/hangingGraft");
              }
              this.blocks[n + 1].bg.unshift(titleGraft);
            }
            this.blocks.splice(n, 1);
            titleSequence.blocks.unshift(block2);
          }
        }
      }
      moveOrphanScopes() {
        if (this.blocks.length > 1) {
          this.moveOrphanStartScopes();
          this.moveOrphanEndScopes();
        }
      }
      moveOrphanStartScopes() {
        for (const [blockNo, block2] of this.blocks.entries()) {
          if (blockNo >= this.blocks.length - 1) {
            continue;
          }
          for (const item of [...block2.items].reverse()) {
            if (item.subType !== "start" || item.payload.startsWith("altChapter")) {
              break;
            }
            this.blocks[blockNo + 1].items.unshift(this.blocks[blockNo].items.pop());
          }
        }
      }
      moveOrphanStartScopes2() {
        for (const [blockNo, block2] of this.blocks.entries()) {
          if (blockNo >= this.blocks.length - 1) {
            continue;
          }
          for (const item of [...block2.items].reverse()) {
            if (item.subType !== "start") {
              break;
            }
            this.blocks[blockNo + 1].items.unshift(this.blocks[blockNo].items.pop());
          }
        }
      }
      moveOrphanEndScopes() {
        for (const [blockNo, block2] of this.blocks.entries()) {
          if (blockNo === 0) {
            continue;
          }
          for (const item of [...block2.items]) {
            if (item.subType !== "end") {
              break;
            }
            this.blocks[blockNo - 1].items.push(this.blocks[blockNo].items.shift());
          }
        }
      }
      removeEmptyBlocks(customCanBeEmpty) {
        const canBeEmpty = ["blockTag/b", "blockTag/ib"].concat(customCanBeEmpty);
        const emptyBlocks = [];
        let changed = false;
        for (const blockRecord of this.blocks.entries()) {
          if (blockRecord[1].tokens().length === 0 && !canBeEmpty.includes(blockRecord[1].bs.payload)) {
            emptyBlocks.push(blockRecord);
          }
        }
        for (const [n, block2] of emptyBlocks.reverse()) {
          if (n < this.blocks.length - 1) {
            for (const bg of [...block2.bg].reverse()) {
              this.blocks[n + 1].bg.unshift(bg);
            }
            for (const i of block2.items.reverse()) {
              this.blocks[n + 1].items.unshift(i);
            }
            this.blocks.splice(n, 1);
            changed = true;
          } else if (block2.bg.length === 0 && block2.items.length === 0) {
            this.blocks.splice(n, 1);
            changed = true;
          }
        }
        if (changed) {
          this.removeEmptyBlocks(customCanBeEmpty);
        }
      }
      removeGraftsToEmptySequences(emptySequences) {
        this.blocks.forEach((b) => b.removeGraftsToEmptySequences(emptySequences));
      }
      succinctifyBlocks(docSet) {
        const ret = [];
        let openScopes = [];
        const updateOpenScopes = (item) => {
          if (item.subType === "start") {
            const existingScopes = openScopes.filter((s) => s.payload === item.payload);
            if (existingScopes.length === 0) {
              openScopes.push(item);
            }
          } else {
            openScopes = openScopes.filter((s) => s.payload !== item.payload);
          }
        };
        let nextToken = 0;
        for (const block2 of this.blocks) {
          const contentBA = new ByteArray(block2.length);
          const blockGraftsBA = new ByteArray(1);
          const openScopesBA = new ByteArray(1);
          const includedScopesBA = new ByteArray(1);
          const nextTokenBA = new ByteArray(1);
          nextTokenBA.pushNByte(nextToken);
          for (const bg of block2.bg) {
            this.pushSuccinctGraft(blockGraftsBA, docSet, bg);
          }
          for (const os of openScopes) {
            this.pushSuccinctScope(openScopesBA, docSet, os);
          }
          const includedScopes = [];
          for (const item of block2.items) {
            switch (item.type) {
              case "token":
                this.pushSuccinctToken(contentBA, docSet, item);
                if (item.subType === "wordLike") {
                  nextToken++;
                }
                break;
              case "graft":
                this.pushSuccinctGraft(contentBA, docSet, item);
                break;
              case "scope":
                this.pushSuccinctScope(contentBA, docSet, item);
                updateOpenScopes(item);
                if (item.subType === "start") {
                  includedScopes.push(item);
                }
                break;
              default:
                throw new Error(`Item type ${item.type} is not handled in succinctifyBlocks`);
            }
          }
          const blockScopeBA = new ByteArray(10);
          this.pushSuccinctScope(blockScopeBA, docSet, block2.bs);
          for (const is of includedScopes) {
            this.pushSuccinctScope(includedScopesBA, docSet, is);
          }
          contentBA.trim();
          blockGraftsBA.trim();
          blockScopeBA.trim();
          openScopesBA.trim();
          includedScopesBA.trim();
          ret.push({
            c: contentBA,
            bs: blockScopeBA,
            bg: blockGraftsBA,
            os: openScopesBA,
            is: includedScopesBA,
            nt: nextTokenBA
          });
        }
        return ret;
      }
      pushSuccinctToken(bA, docSet, item) {
        const charsEnumIndex = docSet.enumForCategoryValue(tokenCategory[item.subType], item.payload);
        pushSuccinctTokenBytes(bA, tokenEnum[item.subType], charsEnumIndex);
      }
      pushSuccinctGraft(bA, docSet, item) {
        const graftTypeEnumIndex = docSet.enumForCategoryValue("graftTypes", item.subType);
        const seqEnumIndex = docSet.enumForCategoryValue("ids", item.payload);
        pushSuccinctGraftBytes(bA, graftTypeEnumIndex, seqEnumIndex);
      }
      pushSuccinctScope(bA, docSet, item) {
        const scopeBits = item.payload.split("/");
        const scopeTypeByte = scopeEnum[scopeBits[0]];
        const scopeBitBytes = scopeBits.slice(1).map((b) => docSet.enumForCategoryValue("scopeBits", b));
        pushSuccinctScopeBytes(bA, itemEnum[`${item.subType}Scope`], scopeTypeByte, scopeBitBytes);
      }
    };
    var Block = class {
      constructor(blockScope) {
        this.id = utils.generateId();
        this.items = [];
        this.bg = [];
        this.bs = {
          type: "scope",
          subType: "start",
          payload: blockScope
        };
        this.os = [];
      }
      addItem(i) {
        this.items.push(i);
      }
      plainText() {
        return this.items.filter((i) => i.type === "token").map((i) => i.payload).join("");
      }
      trim() {
        this.items = this.trimEnd(this.trimStart(this.items));
      }
      reorderSpanWithAtts() {
        const swaStarts = [];
        for (const [pos, item] of this.items.entries()) {
          if (item.subType === "start" && item.payload.startsWith("spanWithAtts")) {
            swaStarts.push(pos + 1);
          }
        }
        for (const swaStart of swaStarts) {
          let pos = swaStart;
          let tokens = [];
          let scopes = [];
          while (true) {
            if (pos >= this.items.length) {
              break;
            }
            const item = this.items[pos];
            if (item.type === "token") {
              tokens.push(item);
            } else if (item.subType === "start" && item.payload.startsWith("attribute/spanWithAtts")) {
              scopes.push(item);
            } else {
              break;
            }
            pos++;
          }
          if (tokens.length !== 0 && scopes.length !== 0) {
            let pos2 = swaStart;
            for (const s of scopes) {
              this.items[pos2] = s;
              pos2++;
            }
            for (const t of tokens) {
              this.items[pos2] = t;
              pos2++;
            }
          }
        }
      }
      inlineToEnd() {
        let toAppend = null;
        for (const [pos, item] of this.items.entries()) {
          if (item.subType === "end" && ["inline/f", "inline/fe", "inline/x"].includes(item.payload)) {
            toAppend = item;
            this.items.splice(pos, 1);
            break;
          }
        }
        if (toAppend) {
          this.addItem(toAppend);
        }
      }
      makeNoteGrafts(parser) {
        const noteStarts = [];
        for (const [pos, item] of this.items.entries()) {
          if (item.subType === "start" && (item.payload.startsWith("inline/f") || item.payload.startsWith("inline/x"))) {
            noteStarts.push(pos);
          }
        }
        for (const noteStart of noteStarts) {
          const noteLabel = this.items[noteStart].payload;
          const callerToken = this.items[noteStart + 1];
          if (callerToken.type === "token" && callerToken.payload.length === 1) {
            const callerSequence = new Sequence("noteCaller");
            callerSequence.newBlock(noteLabel);
            callerSequence.addItem(callerToken);
            parser.sequences.noteCaller.push(callerSequence);
            this.items[noteStart + 1] = {
              type: "graft",
              subType: "noteCaller",
              payload: callerSequence.id
            };
          }
        }
      }
      trimStart(items) {
        if (items.length === 0) {
          return items;
        }
        const firstItem = items[0];
        if (["lineSpace", "eol"].includes(firstItem.subType)) {
          return this.trimStart(items.slice(1));
        }
        if (firstItem.type === "token") {
          return items;
        }
        return [firstItem, ...this.trimStart(items.slice(1))];
      }
      trimEnd(items) {
        if (items.length === 0) {
          return items;
        }
        const lastItem = items[items.length - 1];
        if (["lineSpace", "eol"].includes(lastItem.subType)) {
          return this.trimEnd(items.slice(0, items.length - 1));
        }
        if (lastItem.type === "token") {
          return items;
        }
        return [...this.trimEnd(items.slice(0, items.length - 1)), lastItem];
      }
      filterGrafts(options) {
        const ret = [];
        let toRemove = [];
        for (const [pos, item] of this.grafts()) {
          if (this.graftPassesOptions(item, options)) {
            ret.push(item.payload);
          } else {
            toRemove.push(pos);
          }
        }
        for (const [count, pos] of Array.from(toRemove.entries())) {
          this.items.splice(pos - count, 1);
        }
        toRemove = [];
        for (const [pos, item] of this.bg.entries()) {
          if (this.graftPassesOptions(item, options)) {
            ret.push(item.payload);
          } else {
            toRemove.push(pos);
          }
        }
        for (const [count, pos] of Array.from(toRemove.entries())) {
          this.bg.splice(pos - count, 1);
        }
        return ret;
      }
      filterScopes(options) {
        const toRemove = [];
        for (const [pos, item] of this.scopes()) {
          if (!this.scopePassesOptions(item, options)) {
            toRemove.push(pos);
          }
        }
        for (const [count, pos] of Array.from(toRemove.entries())) {
          this.items.splice(pos - count, 1);
        }
      }
      graftPassesOptions(item, options) {
        return (!("includeGrafts" in options) || options.includeGrafts.includes(item.subType)) && (!("excludeGrafts" in options) || !options.excludeGrafts.includes(item.subType));
      }
      scopePassesOptions(item, options) {
        return (!("includeScopes" in options) || this.scopeMatchesOptionArray(item.payload, options.includeScopes)) && (!("excludeScopes" in options) || !this.scopeMatchesOptionArray(item.payload, options.excludeScopes));
      }
      scopeMatchesOptionArray(itemString, optionArray) {
        for (const optionString of optionArray) {
          if (itemString.startsWith(optionString)) {
            return true;
          }
        }
        return false;
      }
      removeGraftsToEmptySequences(emptySequences) {
        const ret = [];
        let toRemove = [];
        for (const [pos, item] of this.grafts()) {
          if (emptySequences.includes(item.payload)) {
            toRemove.push(pos);
          }
        }
        for (const [count, pos] of Array.from(toRemove.entries())) {
          this.items.splice(pos - count, 1);
        }
        toRemove = [];
        for (const [pos, item] of this.bg.entries()) {
          if (emptySequences.includes(item.payload)) {
            toRemove.push(pos);
          }
        }
        for (const [count, pos] of Array.from(toRemove.entries())) {
          this.bg.splice(pos - count, 1);
        }
        return ret;
      }
      grafts() {
        return Array.from(this.items.entries()).filter((ip) => ip[1].type === "graft");
      }
      scopes() {
        return Array.from(this.items.entries()).filter((ip) => ip[1].type === "scope");
      }
      tokens() {
        return Array.from(this.items.entries()).filter((ip) => !["scope", "graft"].includes(ip[1].type));
      }
      text() {
        return this.tokens().map((t) => t[1].payload).join("");
      }
    };
    module.exports = { Sequence, Block };
  }
});

// node_modules/proskomma-core/src/parser/lib/tokenize.cjs
var require_tokenize = __commonJS({
  "node_modules/proskomma-core/src/parser/lib/tokenize.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var { lexingRegexes: lexingRegexes2 } = require_lexingRegexes();
    var tokenTypes = {};
    var unionComponents = [];
    for (const lr of lexingRegexes2) {
      if (["wordLike", "eol", "lineSpace", "punctuation", "unknown"].includes(lr[1])) {
        tokenTypes[lr[1]] = xre(`^${lr[2].xregexp.source}$`);
        unionComponents.push(lr[2]);
      }
    }
    var tokenizeString = (str) => {
      const unionRegex = xre.union(unionComponents);
      const ret = [];
      for (const token of xre.match(str, unionRegex, "all")) {
        let tokenType;
        if (xre.test(token, tokenTypes["wordLike"])) {
          tokenType = "wordLike";
        } else if (xre.test(token, tokenTypes["punctuation"])) {
          tokenType = "punctuation";
        } else if (xre.test(token, tokenTypes["lineSpace"])) {
          tokenType = "lineSpace";
        } else if (xre.test(token, tokenTypes["eol"])) {
          tokenType = "eol";
        } else {
          tokenType = "unknown";
        }
        ret.push([token, tokenType]);
      }
      return ret;
    };
    module.exports = { tokenizeString };
  }
});

// node_modules/proskomma-core/src/parser/lexers/tsv.cjs
var require_tsv = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/tsv.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { labelForScope } = utils.scopeDefs;
    var { Sequence } = require_model();
    var { tokenizeString } = require_tokenize();
    var parseTableToDocument = (str, parser, bookCode) => {
      const { rows } = JSON.parse(str);
      parser.headers.id = bookCode;
      parser.headers.bookCode = bookCode;
      const tableSequence = new Sequence("table");
      for (const [rowN, row] of rows.entries()) {
        for (const [cellN, cell] of row.entries()) {
          tableSequence.newBlock(labelForScope("tTableRow", [`${rowN}`]));
          const lastBlock = tableSequence.lastBlock();
          lastBlock.addItem({
            type: "scope",
            subType: "start",
            payload: `tTableCol/${cellN}`
          });
          for (const [token, tokenType] of tokenizeString(cell)) {
            lastBlock.addItem({
              type: "token",
              subType: tokenType,
              payload: token
            });
          }
          lastBlock.addItem({
            type: "scope",
            subType: "end",
            payload: `tTableCol/${cellN}`
          });
        }
      }
      parser.sequences.table.push(tableSequence);
      parser.sequences.main.addBlockGraft({
        type: "graft",
        subType: "table",
        payload: tableSequence.id
      });
    };
    module.exports = { parseTableToDocument };
  }
});

// node_modules/proskomma-core/src/parser/lexers/nodes.cjs
var require_nodes = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/nodes.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { labelForScope } = utils.scopeDefs;
    var { Sequence } = require_model();
    var { tokenizeString } = require_tokenize();
    var nextNodeId = 0;
    var numberNodes = (node, parentId) => {
      if (typeof parentId !== "number") {
        nextNodeId = 0;
      }
      const ret = {
        ...node,
        id: nextNodeId,
        parentId: typeof parentId === "number" ? parentId : "none"
      };
      nextNodeId++;
      if (node.children) {
        ret.children = node.children.map((cn) => numberNodes(cn, ret.id));
      }
      return ret;
    };
    var flattenNodes = (node) => {
      const ret = [{}];
      ret[0].id = node.id;
      ret[0].parentId = node.parentId;
      if (node.content) {
        ret[0].content = node.content;
      }
      if (node.children) {
        ret[0].children = [];
        for (const cn of node.children) {
          ret[0].children.push(cn.id);
          flattenNodes(cn).forEach((n) => ret.push(n));
        }
      }
      return ret;
    };
    var parseNodes = (str, parser, bookCode) => {
      parser.headers.id = bookCode;
      parser.headers.bookCode = bookCode;
      const treeSequence = new Sequence("tree");
      for (const node of flattenNodes(numberNodes(JSON.parse(str)))) {
        treeSequence.newBlock(labelForScope("tTreeNode", [`${node.id}`]));
        const scopePayload = labelForScope("tTreeParent", [`${node.parentId}`]);
        treeSequence.lastBlock().items.push({
          type: "scope",
          subType: "start",
          payload: scopePayload
        });
        if (node.content) {
          for (const [name, content] of Object.entries(node.content)) {
            const treeContentStart = treeSequence.lastBlock().items.length;
            const tokenized = tokenizeString(content);
            const scopePayload2 = labelForScope("tTreeContent", [name, node.id, `${treeContentStart}`, `${tokenized.length}`]);
            treeSequence.lastBlock().items.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            for (const [payload, subType] of tokenized) {
              treeSequence.lastBlock().items.push({
                type: "token",
                subType,
                payload
              });
            }
            treeSequence.lastBlock().items.push({
              type: "scope",
              subType: "end",
              payload: scopePayload2
            });
          }
        }
        if (node.children) {
          for (const [childN, childNodeN] of node.children.entries()) {
            const scopePayload2 = labelForScope("tTreeChild", [childN, childNodeN]);
            treeSequence.lastBlock().items.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            treeSequence.lastBlock().items.push({
              type: "scope",
              subType: "end",
              payload: scopePayload2
            });
          }
        }
        treeSequence.lastBlock().items.push({
          type: "scope",
          subType: "end",
          payload: scopePayload
        });
      }
      parser.sequences.tree.push(treeSequence);
      parser.sequences.main.addBlockGraft({
        type: "graft",
        subType: "tree",
        payload: treeSequence.id
      });
    };
    module.exports = {
      flattenNodes,
      numberNodes,
      parseNodes
    };
  }
});

// node_modules/proskomma-core/src/parser/lexers/index.cjs
var require_lexers = __commonJS({
  "node_modules/proskomma-core/src/parser/lexers/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { parseUsfm } = require_usfm();
    var { parseUsx } = require_usx();
    var { parseTableToDocument } = require_tsv();
    var { parseNodes } = require_nodes();
    module.exports = {
      parseUsfm,
      parseUsx,
      parseTableToDocument,
      parseNodes
    };
  }
});

// node_modules/proskomma-core/src/parser/parser_specs.cjs
var require_parser_specs = __commonJS({
  "node_modules/proskomma-core/src/parser/parser_specs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { labelForScope } = utils.scopeDefs;
    var { constructorForFragment } = require_object_for_fragment();
    var buildSpecLookup = (specs2) => {
      const ret = {};
      for (const spec of specs2) {
        for (const context of spec.contexts) {
          if (!(context[0] in ret)) {
            ret[context[0]] = {};
          }
          const accessor = context[1];
          if (!accessor) {
            ret[context[0]]._noAccessor = spec.parser;
          } else {
            if (!(accessor in ret[context[0]])) {
              ret[context[0]][accessor] = {};
            }
            for (const accessorValue of context[2]) {
              ret[context[0]][accessor][accessorValue] = spec.parser;
            }
          }
        }
      }
      return ret;
    };
    var specs = (pt) => [
      {
        // HEADERS - make temp sequence, then add to headers object
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "id",
              "usfm",
              "ide",
              "sts",
              "h",
              "toc",
              "toca",
              "cl"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "header",
          forceNewSequence: true,
          newBlock: true,
          useTempSequence: true,
          newScopes: [
            {
              label: (pt2) => pt2.fullTagName,
              endedBy: ["baseSequenceChange"],
              onEnd: (parser, label) => {
                parser.headers[label] = parser.current.sequence.plainText();
                if (label === "id") {
                  if (parser.headers[label].length === 3 || parser.headers[label].length > 3 && parser.headers[label].substring(3, 4) === " ") {
                    const bookCode = parser.headers[label].substring(0, 3);
                    parser.headers["bookCode"] = bookCode;
                  }
                }
              }
            }
          ]
        }
      },
      {
        // HEADINGS - Start new sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "ms",
              "mr",
              "s",
              "sr",
              "r",
              "qa",
              "sp",
              "sd"
            ].concat(pt.customTags.heading)
          ]
        ],
        parser: {
          baseSequenceType: "heading",
          forceNewSequence: true,
          newBlock: true,
          newScopes: []
        }
      },
      {
        // TITLE - make a sequence or add to existing one
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "mt"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "title",
          newBlock: true,
          newScopes: []
        }
      },
      {
        // END TITLE - make a sequence or add to existing one
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "mte"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "endTitle",
          newBlock: true,
          newScopes: []
        }
      },
      {
        // INTRODUCTION - make a sequence or add to existing one
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "imt",
              "is",
              "ip",
              "ipi",
              "im",
              "imi",
              "ipq",
              "imq",
              "ipr",
              "iq",
              "ib",
              "ili",
              "iot",
              "io",
              "iex",
              "imte"
            ].concat(pt.customTags.intro)
          ]
        ],
        parser: {
          baseSequenceType: "introduction",
          newBlock: true,
          newScopes: []
        }
      },
      {
        // START SIDEBAR - make a new sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "esb"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "sidebar",
          newBlock: true,
          newScopes: [],
          after: (parser) => {
            parser.mainLike = parser.current.sequence;
          }
        }
      },
      {
        // END SIDEBAR - return to main
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "esbe"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "main",
          newBlock: true,
          newScopes: [],
          after: (parser) => {
            parser.mainLike = parser.sequences.main;
          }
        }
      },
      {
        // CAT - graft label and add stub scope, then remove graft and modify scope at tidy stage
        contexts: [
          [
            "startTag",
            "tagName",
            ["cat"]
          ]
        ],
        parser: {
          inlineSequenceType: "esbCat",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/cat", "endBlock", "implicitEnd"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ],
          during: (parser, pt2) => {
            const scopeId = utils.generateId();
            const esbScope = {
              label: () => labelForScope("esbCat", [scopeId]),
              endedBy: ["startTag/esbe"]
            };
            parser.openNewScope(pt2, esbScope, true, parser.mainLike);
          }
        }
      },
      {
        // REMARK - make new sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "rem"
            ]
          ]
        ],
        parser: {
          baseSequenceType: "remark",
          forceNewSequence: true,
          newScopes: []
        }
      },
      {
        // PARAGRAPH STYLES - Make new block on main
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "cd",
              "p",
              "m",
              "po",
              "pr",
              "cls",
              "pmo",
              "pm",
              "pmc",
              "pmr",
              "pi",
              "mi",
              "nb",
              "pc",
              "ph",
              "b",
              "q",
              "qr",
              "qc",
              "qa",
              "qm",
              "qd",
              "lh",
              "li",
              "lf",
              "lim",
              "d"
            ].concat(pt.customTags.paragraph)
          ]
        ],
        parser: {
          baseSequenceType: "mainLike",
          newBlock: true,
          newScopes: []
        }
      },
      {
        // ROW - Make new block
        contexts: [
          [
            "startTag",
            "tagName",
            ["tr"]
          ]
        ],
        parser: {
          newBlock: true,
          newScopes: []
        }
      },
      {
        // FOOTNOTE/ENDNOTE - new inline sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "f",
              "fe"
            ]
          ]
        ],
        parser: {
          inlineSequenceType: "footnote",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/f", "endTag/fe", "endBlock"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ]
        }
      },
      {
        // CROSS REFERENCE - make new inline sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "x"
            ]
          ]
        ],
        parser: {
          inlineSequenceType: "xref",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/x", "endBlock"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ]
        }
      },
      {
        // FIGURE - new inline sequence
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "fig"
            ]
          ]
        ],
        parser: {
          inlineSequenceType: "fig",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("spanWithAtts", [pt2.tagName]),
              endedBy: ["endBlock", "endTag/$tagName$"],
              onEnd: (parser) => parser.clearAttributeContext()
            }
          ],
          during: (parser, pt2) => {
            parser.setAttributeContext(labelForScope("spanWithAtts", [pt2.tagName]));
          }
        }
      },
      {
        // CHAPTER - chapter scope
        contexts: [["chapter"]],
        parser: {
          mainSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("chapter", [pt2.number]),
              endedBy: ["chapter"]
            }
          ]
        }
      },
      {
        // CP - graft label and add stub scope, then remove graft and modify scope at tidy stage
        contexts: [["pubchapter"]],
        parser: {
          mainSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("pubChapter", [pt2.numberString]),
              endedBy: ["pubchapter", "chapter"]
            }
          ]
        }
      },
      {
        // CA - graft label and add stub scope, then remove graft and modify scope at tidy stage
        contexts: [
          [
            "startTag",
            "tagName",
            ["ca"]
          ]
        ],
        parser: {
          inlineSequenceType: "altNumber",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/ca", "endBlock", "implicitEnd"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ],
          during: (parser, pt2) => {
            const scopeId = utils.generateId();
            const caScope = {
              label: () => labelForScope("altChapter", [scopeId]),
              endedBy: ["startTag/ca", "chapter"]
            };
            parser.openNewScope(pt2, caScope, true, parser.sequences.main);
          }
        }
      },
      {
        // VERSES - verse and verses scopes
        contexts: [
          ["verses"]
        ],
        parser: {
          mainSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("verses", [pt2.numberString]),
              endedBy: ["verses", "chapter", "pubchapter"]
            }
          ],
          during: (parser, pt2) => {
            pt2.numbers.forEach(
              (n) => {
                const verseScope = {
                  label: () => labelForScope("verse", [n]),
                  endedBy: ["verses", "chapter", "pubchapter"]
                };
                parser.openNewScope(pt2, verseScope, true, parser.sequences.main);
              }
            );
          }
        }
      },
      {
        // VP - graft label and add stub scope, then remove graft and modify scope at tidy stage
        contexts: [
          [
            "startTag",
            "tagName",
            ["vp"]
          ]
        ],
        parser: {
          inlineSequenceType: "pubNumber",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/vp", "endBlock", "implicitEnd"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ],
          during: (parser, pt2) => {
            const scopeId = utils.generateId();
            const vpScope = {
              label: () => labelForScope("pubVerse", [scopeId]),
              endedBy: ["startTag/vp", "verses", "chapter", "pubchapter"]
            };
            parser.openNewScope(pt2, vpScope, true, parser.sequences.main);
          }
        }
      },
      {
        // VA - graft label and add stub scope, then remove graft and modify scope at tidy stage
        contexts: [
          [
            "startTag",
            "tagName",
            ["va"]
          ]
        ],
        parser: {
          inlineSequenceType: "altNumber",
          forceNewSequence: true,
          newScopes: [
            {
              label: (pt2) => labelForScope("inline", [pt2.fullTagName]),
              endedBy: ["endTag/va", "endBlock", "implicitEnd"],
              onEnd: (parser) => parser.returnToBaseSequence()
            }
          ],
          during: (parser, pt2) => {
            const scopeId = utils.generateId();
            const vpScope = {
              label: () => labelForScope("altVerse", [scopeId]),
              endedBy: ["startTag/va", "verses", "chapter", "pubchapter"]
            };
            parser.openNewScope(pt2, vpScope, true, parser.sequences.main);
          }
        }
      },
      {
        // CHARACTER MARKUP - add scope
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "qs",
              "qac",
              "litl",
              "lik",
              "liv",
              "fr",
              "fq",
              "fqa",
              "fk",
              "fl",
              "fw",
              "fp",
              "fv",
              "ft",
              "fdc",
              "fm",
              "xo",
              "xk",
              "xq",
              "xt",
              "xta",
              "xop",
              "xot",
              "xnt",
              "xdc",
              "rq",
              "add",
              "bk",
              "dc",
              "k",
              "nd",
              "ord",
              "pn",
              "png",
              "qt",
              "sig",
              "sls",
              "tl",
              "wj",
              "em",
              "bd",
              "it",
              "bdit",
              "no",
              "sc",
              "sup",
              "ior",
              "iqt"
            ].concat(pt.customTags.char)
          ]
        ],
        parser: {
          newScopes: [
            {
              label: (pt2) => labelForScope("span", [pt2.fullTagName]),
              endedBy: ["endBlock", "endTag/$fullTagName$", "implicitEnd"]
            }
          ]
        }
      },
      {
        // CELL - unpick tagName, add scope
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "th",
              "thr",
              "tc",
              "tcr"
            ]
          ]
        ],
        parser: {
          newScopes: [
            {
              label: (pt2) => labelForScope("cell", [pt2.fullTagName]),
              endedBy: [
                "startTag/th",
                "startTag/thr",
                "startTag/tc",
                "startTag/tcr",
                "startTag/th2",
                "startTag/thr2",
                "startTag/tc2",
                "startTag/tcr2",
                "startTag/th3",
                "startTag/thr3",
                "startTag/tc3",
                "startTag/tcr3",
                "endBlock",
                "endTag/$fullTagName$"
              ]
            }
          ]
        }
      },
      {
        // EMPTY MILESTONE - add open and close scope
        contexts: [
          ["emptyMilestone"]
        ],
        parser: { during: (parser, pt2) => parser.addEmptyMilestone(labelForScope("milestone", [pt2.tagName])) }
      },
      {
        // START MILESTONE - open scope, set attribute context
        contexts: [
          ["startMilestoneTag", "sOrE", "s"]
        ],
        parser: {
          newScopes: [
            {
              label: (pt2) => labelForScope("milestone", [pt2.tagName]),
              endedBy: ["endMilestone/$tagName$"]
            }
          ],
          during: (parser, pt2) => {
            parser.setAttributeContext(labelForScope("milestone", [pt2.tagName]));
          }
        }
      },
      {
        // END MILESTONE - close scope, clear attribute context
        contexts: [
          ["endMilestoneMarker"]
        ],
        parser: { during: (parser) => parser.clearAttributeContext() }
      },
      {
        // ATTRIBUTE - open scope based on attribute context
        contexts: [
          ["attribute"],
          ["defaultAttribute"]
        ],
        parser: {
          during: (parser, pt2) => {
            const defaults = {
              w: "lemma",
              rb: "gloss",
              xt: "link-href"
            };
            if (parser.current.attributeContext) {
              const contextParts = parser.current.attributeContext.split("/");
              if (pt2.key === "default" && contextParts.length === 2) {
                pt2.key = defaults[contextParts[1]] || `unknownDefault_${contextParts[1]}`;
                pt2.printValue = pt2.printValue.replace(/default/, pt2.key);
              }
              [...pt2.values.entries()].forEach(
                (na) => {
                  const attScope = {
                    label: (pt3) => labelForScope("attribute", [parser.current.attributeContext, pt3.key, na[0], na[1]]),
                    endedBy: [`$attributeContext$`]
                  };
                  parser.openNewScope(pt2, attScope);
                }
              );
            } else {
              parser.addToken(constructorForFragment.printable("unknown", [pt2.printValue]));
            }
          }
        }
      },
      {
        // WORD-LEVEL MARKUP - open scope and set attribute context
        contexts: [
          [
            "startTag",
            "tagName",
            [
              "w",
              "rb"
              // 'xt',
            ].concat(pt.customTags.word)
          ]
        ],
        parser: {
          newScopes: [
            {
              label: (pt2) => labelForScope("spanWithAtts", [pt2.tagName]),
              endedBy: ["endBlock", "endTag/$tagName$"],
              onEnd: (parser) => parser.clearAttributeContext()
            }
          ],
          during: (parser, pt2) => {
            parser.setAttributeContext(labelForScope("spanWithAtts", [pt2.tagName]));
          }
        }
      },
      {
        // TOKEN - add a token!
        contexts: [
          ["wordLike"],
          ["lineSpace"],
          ["punctuation"],
          ["eol"]
        ],
        parser: { during: (parser, pt2) => parser.addToken(pt2) }
      },
      {
        // NO BREAK SPACE - make a token!
        contexts: [
          ["noBreakSpace"]
        ],
        parser: {
          during: (parser) => {
            parser.addToken(constructorForFragment.printable("lineSpace", [" "]));
          }
        }
      },
      {
        // SOFT LINE BREAK - make a token!
        contexts: [
          ["softLineBreak"]
        ],
        parser: {
          during: (parser) => {
            parser.addToken(constructorForFragment.printable("softLineBreak", ["//"]));
          }
        }
      },
      {
        // BARESLASH - make a token!
        contexts: [
          ["bareSlash"]
        ],
        parser: {
          during: (parser) => {
            parser.addToken(constructorForFragment.printable("bareSlash", ["\\"]));
          }
        }
      },
      {
        // UNKNOWN - make a token!
        contexts: [
          ["unknown"]
        ],
        parser: {
          during: (parser, pt2) => {
            parser.addToken(constructorForFragment.printable("unknown", [pt2.printValue]));
          }
        }
      }
    ];
    module.exports = {
      specs,
      buildSpecLookup
    };
  }
});

// node_modules/proskomma-core/src/parser/index.cjs
var require_parser = __commonJS({
  "node_modules/proskomma-core/src/parser/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { Sequence } = require_model();
    var {
      specs,
      buildSpecLookup
    } = require_parser_specs();
    var { labelForScope } = utils.scopeDefs;
    var parserConstantDef = utils.parserConstants;
    var Parser2 = class {
      constructor(filterOptions, customTags, emptyBlocks) {
        this.filterOptions = filterOptions;
        this.customTags = customTags;
        this.emptyBlocks = emptyBlocks;
        this.specs = specs(this);
        this.specLookup = buildSpecLookup(this.specs);
        this.headers = {};
        this.baseSequenceTypes = parserConstantDef.usfm.baseSequenceTypes;
        this.inlineSequenceTypes = parserConstantDef.usfm.inlineSequenceTypes;
        this.setSequences();
        this.setCurrent();
      }
      setSequences() {
        this.sequences = {};
        for (const [sType, sArity] of Object.entries({ ...this.baseSequenceTypes, ...this.inlineSequenceTypes })) {
          switch (sArity) {
            case "1":
              this.sequences[sType] = new Sequence(sType);
              break;
            case "?":
              this.sequences[sType] = null;
              break;
            case "*":
              this.sequences[sType] = [];
              break;
            default:
              throw new Error(`Unexpected sequence arity '${sArity}' for '${sType}'`);
          }
        }
        this.mainLike = this.sequences.main;
      }
      setCurrent() {
        this.current = {
          sequence: this.sequences.main,
          parentSequence: null,
          baseSequenceType: "main",
          inlineSequenceType: null,
          attributeContext: null
        };
      }
      parseItem(lexedItem) {
        let changeBaseSequence = false;
        if (["startTag"].includes(lexedItem.subclass)) {
          this.closeActiveScopes(`startTag/${lexedItem.fullTagName}`);
          if (!lexedItem.isNested) {
            this.closeActiveScopes(`implicitEnd`);
          }
        }
        if (["endTag"].includes(lexedItem.subclass)) {
          this.closeActiveScopes(`endTag/${lexedItem.fullTagName}`);
        }
        if (["startMilestoneTag"].includes(lexedItem.subclass) && lexedItem.sOrE === "e") {
          this.closeActiveScopes(`endMilestone/${lexedItem.tagName}`);
        }
        if (["chapter", "pubchapter", "verses"].includes(lexedItem.subclass)) {
          this.closeActiveScopes(lexedItem.subclass, this.sequences.main);
        }
        const spec = this.specForItem(lexedItem);
        if (spec) {
          if ("before" in spec.parser) {
            spec.parser.before(this, lexedItem);
          }
          changeBaseSequence = false;
          if (spec.parser.baseSequenceType) {
            const returnSequenceType = spec.parser.baseSequenceType === "mainLike" ? this.mainLike.type : spec.parser.baseSequenceType;
            changeBaseSequence = returnSequenceType !== this.current.baseSequenceType || spec.parser.forceNewSequence;
          }
          if (changeBaseSequence) {
            this.closeActiveScopes("baseSequenceChange");
            this.changeBaseSequence(spec.parser);
            if ("newBlock" in spec.parser && spec.parser.newBlock) {
              this.closeActiveScopes("endBlock");
              this.current.sequence.newBlock(labelForScope("blockTag", [lexedItem.fullTagName]));
            }
          } else if (spec.parser.inlineSequenceType) {
            this.current.inlineSequenceType = spec.parser.inlineSequenceType;
            this.current.parentSequence = this.current.sequence;
            if (this.current.parentSequence.type === "header") {
              this.current.parentSequence = this.sequences.main;
            }
            this.current.sequence = new Sequence(this.current.inlineSequenceType);
            this.current.sequence.newBlock(labelForScope("inline", spec.parser.inlineSequenceType));
            this.sequences[this.current.inlineSequenceType].push(this.current.sequence);
            this.current.parentSequence.addItem({
              type: "graft",
              subType: this.current.inlineSequenceType,
              payload: this.current.sequence.id
            });
          } else if ("newBlock" in spec.parser && spec.parser.newBlock) {
            this.current.sequence.newBlock(labelForScope("blockTag", [lexedItem.fullTagName]));
          }
          if ("during" in spec.parser) {
            spec.parser.during(this, lexedItem);
          }
          this.openNewScopes(spec.parser, lexedItem);
          if ("after" in spec.parser) {
            spec.parser.after(this, lexedItem);
          }
        }
      }
      tidy() {
        for (const introduction of this.sequences.introduction) {
          introduction.graftifyIntroductionHeadings(this);
        }
        const allSequences = this.allSequences();
        for (const seq of allSequences) {
          seq.trim();
          seq.reorderSpanWithAtts();
          seq.makeNoteGrafts(this);
          seq.moveOrphanScopes();
          seq.removeEmptyBlocks(this.emptyBlocks);
        }
        const emptySequences = this.emptySequences(allSequences);
        for (const seq of allSequences) {
          if (emptySequences) {
            seq.removeGraftsToEmptySequences(emptySequences);
          }
          seq.addTableScopes();
          seq.close(this);
          this.substitutePubNumberScopes(seq);
          seq.moveOrphanStartScopes2();
          if (seq.type === "sidebar") {
            this.substituteEsbCatScopes(seq);
          }
          if (["footnote", "xref"].includes(seq.type)) {
            seq.lastBlock().inlineToEnd();
          }
        }
      }
      emptySequences(sequences) {
        return sequences.filter((s) => s.blocks.length === 0).map((s) => s.id);
      }
      substitutePubNumberScopes(seq) {
        const scopeToGraftContent = {};
        const sequenceById = this.sequenceById();
        for (const block2 of seq.blocks) {
          let spliceCount = 0;
          const itItems = [...block2.items];
          for (const [n, item] of itItems.entries()) {
            if (item.type === "graft" && ["pubNumber", "altNumber"].includes(item.subType)) {
              const graftContent = sequenceById[item.payload].text().trim();
              const scopeId = itItems[n + 1].payload.split("/")[1];
              scopeToGraftContent[scopeId] = graftContent;
              block2.items.splice(n - spliceCount, 1);
              spliceCount++;
            }
          }
        }
        if (Object.keys(scopeToGraftContent).length > 0) {
          for (const block2 of seq.blocks) {
            for (const scope of block2.items.filter((i) => i.type === "scope")) {
              const scopeParts = scope.payload.split("/");
              if (["altChapter", "pubVerse", "altVerse"].includes(scopeParts[0])) {
                scope.payload = `${scopeParts[0]}/${scopeToGraftContent[scopeParts[1]]}`;
              }
            }
          }
        }
      }
      substituteEsbCatScopes(seq) {
        const scopeToGraftContent = {};
        const sequenceById = this.sequenceById();
        for (const block2 of seq.blocks) {
          let spliceCount = 0;
          const itItems = [...block2.items];
          for (const [n, item] of itItems.entries()) {
            if (item.type === "graft" && item.subType === "esbCat") {
              const catContent = sequenceById[item.payload].text().trim();
              const scopeId = itItems[1].payload.split("/")[1];
              scopeToGraftContent[scopeId] = catContent;
              block2.items.splice(n - spliceCount, 1);
              spliceCount++;
            }
          }
        }
        if (Object.keys(scopeToGraftContent).length > 0) {
          for (const block2 of seq.blocks) {
            for (const scope of block2.items.filter((i) => i.type === "scope")) {
              const scopeParts = scope.payload.split("/");
              if (scopeParts[0] === "esbCat") {
                scope.payload = `${scopeParts[0]}/${scopeToGraftContent[scopeParts[1]]}`;
              }
            }
          }
        }
      }
      allSequences() {
        const ret = [];
        for (const [seqName, seqArity] of Object.entries({ ...this.baseSequenceTypes, ...this.inlineSequenceTypes })) {
          switch (seqArity) {
            case "1":
            case "?":
              if (this.sequences[seqName]) {
                ret.push(this.sequences[seqName]);
              }
              break;
            case "*":
              this.sequences[seqName].forEach((s) => {
                ret.push(s);
              });
              break;
            default:
              throw new Error(`Unexpected sequence arity '${seqArity}' for '${seqName}'`);
          }
        }
        return ret;
      }
      sequenceById() {
        const ret = {};
        this.allSequences().forEach((s) => {
          ret[s.id] = s;
        });
        return ret;
      }
      filter() {
        const usedSequences = [];
        const sequenceById = this.sequenceById();
        this.filterGrafts(this.sequences.main.id, sequenceById, usedSequences, this.filterOptions);
        this.removeUnusedSequences(usedSequences);
        this.filterScopes(Object.values(sequenceById), this.filterOptions);
      }
      filterGrafts(seqId, seqById, used, options) {
        used.push(seqId);
        const childSequences = seqById[seqId].filterGrafts(options);
        for (const si of childSequences) {
          if (seqById[si].type === "main") {
            console.log("MAIN is child!");
            console.log(JSON.stringify(seqById[seqId], null, 2));
            process.exit(1);
          }
          this.filterGrafts(si, seqById, used, options);
        }
      }
      removeUnusedSequences(usedSequences) {
        for (const seq of this.allSequences()) {
          if (!usedSequences.includes(seq.id)) {
            const seqArity = { ...this.baseSequenceTypes, ...this.inlineSequenceTypes }[seq.type];
            switch (seqArity) {
              case "1":
                throw new Error("Attempting to remove sequence with arity of 1");
              case "?":
                this.sequences[seq.type] = null;
                break;
              case "*":
                this.sequences[seq.type] = this.sequences[seq.type].filter((s) => s.id !== seq.id);
                break;
              default:
                throw new Error(`Unexpected sequence arity '${seqArity}' for '${seq.type}'`);
            }
          }
        }
      }
      filterScopes(sequences, options) {
        sequences.forEach((s) => s.filterScopes(options));
      }
      specForItem(item) {
        const context = item.subclass;
        if (!(context in this.specLookup)) {
          return null;
        }
        for (const accessor of ["tagName", "sOrE"]) {
          if (accessor in item && accessor in this.specLookup[context] && item[accessor] in this.specLookup[context][accessor]) {
            return { parser: this.specLookup[context][accessor][item[accessor]] };
          }
        }
        if ("_noAccessor" in this.specLookup[context]) {
          return { parser: this.specLookup[context]["_noAccessor"] };
        }
        return null;
      }
      closeActiveScopes(closeLabel, targetSequence) {
        if (targetSequence === void 0) {
          targetSequence = this.current.sequence;
        }
        const matchedScopes = targetSequence.activeScopes.filter(
          (sc) => sc.endedBy.includes(closeLabel)
        ).reverse();
        targetSequence.activeScopes = targetSequence.activeScopes.filter(
          (sc) => !sc.endedBy.includes(closeLabel)
        );
        matchedScopes.forEach((ms) => this.closeActiveScope(ms, targetSequence));
      }
      closeActiveScope(sc, targetSequence) {
        this.addScope("end", sc.label, targetSequence);
        if (sc.onEnd) {
          sc.onEnd(this, sc.label);
        }
      }
      changeBaseSequence(parserSpec) {
        const newType = parserSpec.baseSequenceType;
        if (newType === "mainLike") {
          this.current.sequence = this.mainLike;
          return;
        }
        this.current.baseSequenceType = newType;
        const arity = this.baseSequenceTypes[newType];
        switch (arity) {
          case "1":
            this.current.sequence = this.sequences[newType];
            break;
          case "?":
            if (!this.sequences[newType]) {
              this.sequences[newType] = new Sequence(newType);
            }
            this.current.sequence = this.sequences[newType];
            break;
          case "*":
            this.current.sequence = new Sequence(newType);
            if (!parserSpec.useTempSequence) {
              this.sequences[newType].push(this.current.sequence);
            }
            break;
          default:
            throw new Error(`Unexpected base sequence arity '${arity}' for '${newType}'`);
        }
        if (!parserSpec.useTempSequence && this.current.sequence.type !== "main") {
          this.mainLike.addBlockGraft({
            type: "graft",
            subType: this.current.baseSequenceType,
            payload: this.current.sequence.id
          });
        }
      }
      returnToBaseSequence() {
        this.current.inlineSequenceType = null;
        this.current.sequence = this.current.parentSequence;
        this.current.parentSequence = null;
      }
      openNewScopes(parserSpec, pt) {
        if (parserSpec.newScopes) {
          let targetSequence = this.current.sequence;
          if ("mainSequence" in parserSpec && parserSpec.mainSequence) {
            targetSequence = this.sequences.main;
          }
          parserSpec.newScopes.forEach((sc) => this.openNewScope(pt, sc, true, targetSequence));
        }
      }
      openNewScope(pt, sc, addItem, targetSequence) {
        if (addItem === void 0) {
          addItem = true;
        }
        if (targetSequence === void 0) {
          targetSequence = this.current.sequence;
        }
        if (addItem) {
          targetSequence.addItem({
            type: "scope",
            subType: "start",
            payload: sc.label(pt)
          });
        }
        const newScope = {
          label: sc.label(pt),
          endedBy: this.substituteEndedBys(sc.endedBy, pt)
        };
        if ("onEnd" in sc) {
          newScope.onEnd = sc.onEnd;
        }
        targetSequence.activeScopes.push(newScope);
      }
      substituteEndedBys(endedBy, pt) {
        return endedBy.map(
          (eb) => {
            let ret = eb.replace("$fullTagName$", pt.fullTagName).replace("$tagName$", pt.tagName);
            if (this.current.attributeContext) {
              ret = ret.replace(
                "$attributeContext$",
                this.current.attributeContext.replace("milestone", "endMilestone").replace("spanWithAtts", "endTag")
              );
            }
            return ret;
          }
        );
      }
      addToken(pt) {
        this.current.sequence.addItem({
          type: "token",
          subType: pt.subclass,
          payload: pt.printValue
        });
      }
      addScope(sOrE, label, targetSequence) {
        if (targetSequence === void 0) {
          targetSequence = this.current.sequence;
        }
        targetSequence.addItem({
          type: "scope",
          subType: sOrE,
          payload: label
        });
      }
      addEmptyMilestone(label) {
        this.mainLike.addItem({
          type: "scope",
          subType: "start",
          payload: label
        });
        this.mainLike.addItem({
          type: "scope",
          subType: "end",
          payload: label
        });
      }
      setAttributeContext(label) {
        this.current.attributeContext = label;
      }
      clearAttributeContext() {
        this.current.attributeContext = null;
      }
    };
    module.exports = { Parser: Parser2 };
  }
});

// node_modules/proskomma-core/src/pipelines/perf2x/perf2usfmPipeline.json
var require_perf2usfmPipeline = __commonJS({
  "node_modules/proskomma-core/src/pipelines/perf2x/perf2usfmPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json"
        }
      },
      {
        id: 1,
        title: "Generate report",
        name: "calculateUsfmChapterPositions",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "report",
            type: "json"
          }
        ],
        description: "Generate report from perf to calculate the position of the chapters"
      },
      {
        id: 2,
        title: "PERF to USFM",
        name: "perf2usfm",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          },
          {
            name: "report",
            type: "json",
            source: "Transform 1 report"
          }
        ],
        outputs: [
          {
            name: "usfm",
            type: "text"
          }
        ],
        description: "PERF=>USFM: Conversion via Proskomma"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "usfm",
            type: "text",
            source: "Transform 2 usfm"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/src/pipelines/perf2x/perf2PkJsonPipeline.json
var require_perf2PkJsonPipeline = __commonJS({
  "node_modules/proskomma-core/src/pipelines/perf2x/perf2PkJsonPipeline.json"(exports, module) {
    module.exports = [
      {
        id: 0,
        type: "Inputs",
        inputs: {
          perf: "json"
        }
      },
      {
        id: 1,
        title: "PERF to PkJSON",
        name: "perf2PkJson",
        type: "Transform",
        inputs: [
          {
            name: "perf",
            type: "json",
            source: "Input perf"
          }
        ],
        outputs: [
          {
            name: "pkJson",
            type: "json"
          }
        ],
        documentation: "",
        description: "PERF=>JSON: Converts PERF to current Proskomma input format"
      },
      {
        id: 999,
        type: "Outputs",
        outputs: [
          {
            name: "pkJson",
            type: "json",
            source: "Transform 1 pkJson"
          }
        ]
      }
    ];
  }
});

// node_modules/proskomma-core/src/pipelines/perf2x/index.cjs
var require_perf2x = __commonJS({
  "node_modules/proskomma-core/src/pipelines/perf2x/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var perf2usfmPipeline = require_perf2usfmPipeline();
    var perf2PkJsonPipeline = require_perf2PkJsonPipeline();
    module.exports = {
      perf2usfmPipeline,
      perf2PkJsonPipeline
    };
  }
});

// node_modules/proskomma-core/src/transforms/calculateUsfmChapterPositions.cjs
var require_calculateUsfmChapterPositions3 = __commonJS({
  "node_modules/proskomma-core/src/transforms/calculateUsfmChapterPositions.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { PerfRenderFromJson: PerfRenderFromJson2 } = require_dist();
    var initialBlockRecord = (ct) => ({
      type: ct.sequences[0].block.type,
      subType: ct.sequences[0].block.subType,
      pos: ct.sequences[0].block.blockN,
      perfChapter: null
    });
    var calculateUsfmChapterPositionsActions = {
      startDocument: [
        {
          description: "Set up storage",
          test: () => true,
          action: ({ workspace, output }) => {
            workspace.blockRecords = [];
            output.report = {};
          }
        }
      ],
      startParagraph: [
        {
          description: "Set up block record",
          test: () => true,
          action: ({ context, workspace }) => {
            workspace.blockRecords.push(initialBlockRecord(context));
          }
        }
      ],
      blockGraft: [
        {
          description: "Set up block record",
          test: () => true,
          action: ({ context, workspace }) => {
            workspace.blockRecords.push(initialBlockRecord(context));
          }
        }
      ],
      mark: [
        {
          description: "Add chapter number to block record",
          test: ({ context }) => context.sequences[0].element.subType === "chapter",
          action: ({ context, workspace }) => {
            workspace.blockRecords[workspace.blockRecords.length - 1].perfChapter = context.sequences[0].element.atts["number"];
          }
        }
      ],
      endDocument: [
        {
          description: "Populate report",
          test: () => true,
          action: ({ workspace, output }) => {
            for (const [recordN, record] of Object.entries(workspace.blockRecords)) {
              if (!record.perfChapter) {
                continue;
              }
              let usfmChapterPos = recordN;
              let found = false;
              while (usfmChapterPos > 0 && !found) {
                if (workspace.blockRecords[usfmChapterPos - 1].type === "paragraph" || workspace.blockRecords[usfmChapterPos - 1].subType === "title") {
                  found = true;
                } else {
                  usfmChapterPos--;
                }
              }
              output.report[usfmChapterPos.toString()] = record.perfChapter;
            }
          }
        }
      ]
    };
    var calculateUsfmChapterPositionsCode = function({ perf }) {
      const cl = new PerfRenderFromJson2({ srcJson: perf, actions: calculateUsfmChapterPositionsActions });
      const output = {};
      cl.renderDocument({
        docId: "",
        config: { maxLength: 60 },
        output
      });
      return { report: output.report };
    };
    var calculateUsfmChapterPositions = {
      name: "calculateUsfmChapterPositions",
      type: "Transform",
      description: "PERF=>JSON: Generates positions for inserting chapter numbers into USFM",
      inputs: [
        {
          name: "perf",
          type: "json",
          source: ""
        }
      ],
      outputs: [
        {
          name: "report",
          type: "json"
        }
      ],
      code: calculateUsfmChapterPositionsCode
    };
    module.exports = calculateUsfmChapterPositions;
  }
});

// node_modules/proskomma-core/src/transforms/perf2usfm.cjs
var require_perf2usfm = __commonJS({
  "node_modules/proskomma-core/src/transforms/perf2usfm.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { PerfRenderFromJson: PerfRenderFromJson2 } = require_dist();
    var oneifyTag = (t) => {
      if (["toc", "toca", "mt", "imt", "s", "ms", "mte", "sd"].includes(t)) {
        return t + "1";
      }
      return t;
    };
    var buildMilestone = (atts, type) => {
      let str = `\\${type}-s |`;
      for (let [key, value] of Object.entries(atts)) {
        if (key === "x-morph") {
          str = str + oneifyTag(key) + '="' + value.join(",") + '" ';
        } else {
          str = str + oneifyTag(key) + '="' + value + '" ';
        }
      }
      ;
      return str + "\\*";
    };
    var buildEndWrapper = (atts, type, isnested = false) => {
      let str = "|";
      for (let [key, value] of Object.entries(atts)) {
        str = str + oneifyTag(key) + '="' + value + '" ';
      }
      ;
      str = str + "\\";
      if (isnested) {
        str = str + "+";
      }
      return str + type + "*";
    };
    var localToUsfmActions = {
      startDocument: [
        {
          description: "Set up environment",
          test: () => true,
          action: ({ context, workspace }) => {
            workspace.usfmBits = [""];
            workspace.nestedWrapper = 0;
            for (let [key, value] of Object.entries(context.document.metadata.document).filter((kv) => !["tags", "properties", "bookCode", "cl"].includes(kv[0]))) {
              workspace.usfmBits.push(`\\${oneifyTag(key)} ${value}
`);
            }
            ;
          }
        }
      ],
      blockGraft: [
        {
          description: "Follow block grafts",
          test: ({ context }) => ["title", "heading", "introduction"].includes(context.sequences[0].block.subType),
          action: (environment) => {
            let contextSequence = environment.context.sequences[0];
            let chapterValue = environment.config.report[contextSequence.block.blockN.toString()];
            const target = contextSequence.block.target;
            if (chapterValue && contextSequence.type === "main") {
              environment.workspace.usfmBits.push(`
\\c ${chapterValue}
`);
            }
            if (target) {
              environment.context.renderer.renderSequenceId(environment, target);
            }
          }
        }
      ],
      inlineGraft: [
        {
          description: "Follow inline grafts",
          test: () => true,
          action: (environment) => {
            const target = environment.context.sequences[0].element.target;
            if (target) {
              environment.context.renderer.renderSequenceId(environment, target);
            }
          }
        }
      ],
      startParagraph: [
        {
          description: "Output footnote paragraph tag (footnote)",
          test: ({ context }) => context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref",
          action: ({ context, workspace }) => {
            workspace.nestedWrapper = 0;
            let contextSequence = context.sequences[0];
            workspace.usfmBits.push(`\\${oneifyTag(contextSequence.block.subType.split(":")[1])} `);
          }
        },
        {
          description: "Output footnote note_caller tag (footnote)",
          test: ({ context }) => context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x",
          action: ({ workspace }) => {
            workspace.nestedWrapper = 0;
          }
        },
        {
          description: "Output paragraph tag (main)",
          test: () => true,
          action: ({
            context,
            workspace,
            config: config2
          }) => {
            workspace.nestedWrapper = 0;
            let contextSequence = context.sequences[0];
            let chapterValue = config2.report[contextSequence.block.blockN.toString()];
            if (chapterValue && contextSequence.type === "main") {
              workspace.usfmBits.push(`
\\c ${chapterValue}
`);
            }
            workspace.usfmBits.push(`
\\${oneifyTag(contextSequence.block.subType.split(":")[1])}
`);
          }
        }
      ],
      endParagraph: [
        {
          description: "Output footnote paragraph tag (footnote)",
          test: ({ context }) => context.sequences[0].block.subType === "usfm:f" && context.sequences[0].type === "footnote" || context.sequences[0].block.subType === "usfm:x" && context.sequences[0].type === "xref",
          action: ({ context, workspace }) => {
            let contextSequence = context.sequences[0];
            workspace.usfmBits.push(`\\${oneifyTag(contextSequence.block.subType.split(":")[1])}*`);
          }
        },
        {
          description: "Output footnote note_caller tag (footnote)",
          test: ({ context }) => context.sequences[0].block.subType === "usfm:f" || context.sequences[0].block.subType === "usfm:x",
          action: () => {
          }
        },
        {
          description: "Output nl",
          test: () => true,
          action: ({ workspace }) => {
            workspace.usfmBits.push(`
`);
          }
        }
      ],
      startMilestone: [
        {
          description: "Output start milestone",
          test: () => true,
          action: ({ context, workspace }) => {
            let contextSequenceElement = context.sequences[0].element;
            let newStartMileStone = buildMilestone(contextSequenceElement.atts, oneifyTag(contextSequenceElement.subType.split(":")[1]));
            workspace.usfmBits.push(newStartMileStone);
          }
        }
      ],
      endMilestone: [
        {
          description: "Output end milestone",
          test: () => true,
          action: ({ context, workspace }) => {
            workspace.usfmBits.push(`\\${oneifyTag(context.sequences[0].element.subType.split(":")[1])}-e\\*`);
          }
        }
      ],
      text: [
        {
          description: "Output text",
          test: () => true,
          action: ({ context, workspace }) => {
            const text = context.sequences[0].element.text;
            workspace.usfmBits.push(text);
          }
        }
      ],
      mark: [
        {
          description: "Output chapter or verses",
          test: () => true,
          action: ({ context, workspace }) => {
            const element = context.sequences[0].element;
            if (element.subType === "verses") {
              workspace.usfmBits.push(`
\\v ${element.atts["number"]}
`);
            }
          }
        }
      ],
      endSequence: [
        {
          description: "Output \\cl",
          test: ({ context }) => context.document.metadata.document.cl && context.sequences[0].type === "title",
          action: ({ context, workspace }) => {
            workspace.usfmBits.push(`
\\cl ${context.document.metadata.document.cl}
`);
          }
        }
      ],
      startWrapper: [
        {
          description: "Output start tag",
          test: () => true,
          action: ({ workspace, context }) => {
            let contextSequence = context.sequences[0];
            if (workspace.nestedWrapper > 0) {
              workspace.usfmBits.push(`\\+${oneifyTag(contextSequence.element.subType.split(":")[1])} `);
            } else {
              workspace.usfmBits.push(`\\${oneifyTag(contextSequence.element.subType.split(":")[1])} `);
            }
            workspace.nestedWrapper += 1;
          }
        }
      ],
      endWrapper: [
        {
          description: "Output end tag",
          test: ({ context }) => !["fr", "fq", "fqa", "fk", "fl", "fw", "fp", "ft", "xo", "xk", "xq", "xt", "xta"].includes(context.sequences[0].element.subType.split(":")[1]),
          action: ({ workspace, context }) => {
            workspace.nestedWrapper -= 1;
            let contextSequence = context.sequences[0];
            let subType = contextSequence.element.subType.split(":")[1];
            let isNested = workspace.nestedWrapper > 0;
            if (subType === "w") {
              let newEndW = buildEndWrapper(contextSequence.element.atts, oneifyTag(subType), isNested);
              workspace.usfmBits.push(newEndW);
            } else {
              if (isNested) {
                workspace.usfmBits.push(`\\+${oneifyTag(contextSequence.element.subType.split(":")[1])}*`);
              } else {
                workspace.usfmBits.push(`\\${oneifyTag(contextSequence.element.subType.split(":")[1])}*`);
              }
            }
          }
        },
        {
          description: "Do NOT output end tag",
          test: () => true,
          action: ({ workspace }) => {
            workspace.nestedWrapper -= 1;
          }
        }
      ],
      endDocument: [
        {
          description: "Build output",
          test: () => true,
          action: ({ workspace, output }) => {
            output.usfm = workspace.usfmBits.join("").replace(/(\s*)\n(\s*)/gm, "\n");
          }
        }
      ]
    };
    var perf2usfmCode = function({ perf, report }) {
      const cl = new PerfRenderFromJson2({ srcJson: perf, actions: localToUsfmActions });
      const output = {};
      cl.renderDocument({
        docId: "",
        config: { report },
        output
      });
      return { usfm: output.usfm };
    };
    var perf2usfm = {
      name: "perf2usfm",
      type: "Transform",
      description: "PERF=>USFM",
      inputs: [
        {
          name: "perf",
          type: "json",
          source: ""
        },
        {
          name: "report",
          type: "json",
          source: ""
        }
      ],
      outputs: [
        {
          name: "usfm",
          type: "text"
        }
      ],
      code: perf2usfmCode
    };
    module.exports = perf2usfm;
  }
});

// node_modules/proskomma-core/src/transforms/perf2PkJson.cjs
var require_perf2PkJson = __commonJS({
  "node_modules/proskomma-core/src/transforms/perf2PkJson.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { PerfRenderFromJson: PerfRenderFromJson2 } = require_dist();
    var xre = require_lib();
    var { lexingRegexes: lexingRegexes2 } = require_lexingRegexes();
    var wordLikeRegex = lexingRegexes2.filter((r) => r[1] === "wordLike")[0][2];
    var lineSpaceRegex = lexingRegexes2.filter((r) => r[1] === "lineSpace")[0][2];
    var punctuationRegex = lexingRegexes2.filter((r) => r[1] === "punctuation")[0][2];
    var closeAllOpenScopes = (workspace) => {
      [...workspace.os].reverse().forEach(
        (o) => {
          workspace.block.items.push(
            {
              type: "scope",
              subType: "end",
              payload: o
            }
          );
        }
      );
      workspace.os = [];
    };
    var closeParagraphScopes = (workspace) => {
      [...workspace.os.filter((o) => ["span"].includes(o.split("/")[1]))].reverse().forEach(
        (o) => {
          workspace.block.items.push({
            type: "scope",
            subType: "end",
            payload: o
          });
          workspace.os = [...workspace.os.filter((wo) => wo !== o)];
        }
      );
    };
    var closeVerseScopes = (workspace) => {
      [...workspace.os.filter((o) => ["verse", "verses"].includes(o.split("/")[0]))].reverse().forEach(
        (o) => {
          workspace.block.items.push({
            type: "scope",
            subType: "end",
            payload: o
          });
          workspace.os = [...workspace.os.filter((wo) => wo !== o)];
        }
      );
    };
    var closeChapterScopes = (workspace) => {
      [...workspace.os.filter((o) => ["chapter"].includes(o.split("/")[0]))].reverse().forEach(
        (o) => {
          workspace.block.items.push({
            type: "scope",
            subType: "end",
            payload: o
          });
          workspace.os = [...workspace.os.filter((wo) => wo !== o)];
        }
      );
    };
    var perf2PkJsonActions = {
      startDocument: [
        {
          description: "Set up word object",
          test: () => true,
          action: ({
            workspace,
            output
          }) => {
            output.pkJson = {};
            workspace.sequenceId = null;
            workspace.block = null;
            workspace.os = [];
            workspace.waitingBlockGrafts = [];
          }
        }
      ],
      startSequence: [
        {
          description: "Add sequence array to output",
          test: () => true,
          action: (environment) => {
            environment.output.pkJson[environment.context.sequences[0].id] = [];
            environment.workspace.sequenceId = environment.context.sequences[0].id;
          }
        }
      ],
      endSequence: [
        {
          description: "Reset sequenceId pointer",
          test: () => true,
          action: (environment) => {
            var _a;
            closeAllOpenScopes(environment.workspace);
            environment.workspace.sequenceId = (_a = environment.context.sequences[1]) == null ? void 0 : _a.id;
          }
        }
      ],
      unresolvedBlockGraft: [
        {
          description: "Stash for next para",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const target = context.sequences[0].block.target;
            if (target) {
              workspace.waitingBlockGrafts.push({
                type: "graft",
                subType: context.sequences[0].block.subType,
                payload: context.sequences[0].block.target
              });
            }
          }
        }
      ],
      unresolvedInlineGraft: [
        {
          description: "Follow inline grafts",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const target = context.sequences[0].element.target;
            if (target) {
              workspace.block.items.push({
                type: "graft",
                subType: context.sequences[0].element.subType,
                payload: context.sequences[0].element.target
              });
            }
          }
        }
      ],
      startParagraph: [
        {
          description: "Add object for paragraph block",
          test: () => true,
          action: ({
            context,
            workspace,
            output
          }) => {
            workspace.block = {
              os: [...workspace.os],
              is: [],
              bs: {
                type: "scope",
                subType: "start",
                payload: `blockTag/${context.sequences[0].block.subType.split(":")[1]}`
              },
              bg: [...workspace.waitingBlockGrafts],
              items: []
            };
            output.pkJson[workspace.sequenceId].push(workspace.block);
          }
        }
      ],
      endParagraph: [
        {
          description: "Close open scopes",
          test: () => true,
          action: ({ workspace }) => {
            closeParagraphScopes(workspace);
            workspace.waitingBlockGrafts = [];
          }
        }
      ],
      mark: [
        {
          description: "ts mark as milestone",
          test: ({ context }) => ["usfm:ts"].includes(context.sequences[0].element.subType),
          action: ({ workspace }) => {
            const milestoneScope = `milestone/ts`;
            if (!workspace.block.is.includes(milestoneScope)) {
              workspace.block.is.push(milestoneScope);
            }
            workspace.os.push(milestoneScope);
            workspace.block.items.push({
              type: "scope",
              subType: "start",
              payload: milestoneScope
            });
            workspace.block.items.push({
              type: "scope",
              subType: "end",
              payload: milestoneScope
            });
          }
        },
        {
          description: "Chapter",
          test: ({ context }) => ["chapter"].includes(context.sequences[0].element.subType),
          action: ({
            context,
            workspace
          }) => {
            closeVerseScopes(workspace);
            closeChapterScopes(workspace);
            const element = context.sequences[0].element;
            const chapterScope = `chapter/${element.atts["number"]}`;
            if (!workspace.block.is.includes(chapterScope)) {
              workspace.block.is.push(chapterScope);
            }
            workspace.os.push(chapterScope);
            workspace.block.items.push({
              type: "scope",
              subType: "start",
              payload: chapterScope
            });
          }
        },
        {
          description: "Verses",
          test: ({ context }) => ["verses"].includes(context.sequences[0].element.subType),
          action: ({
            context,
            workspace
          }) => {
            closeVerseScopes(workspace);
            const element = context.sequences[0].element;
            const vn = element.atts["number"];
            let va = [parseInt(vn)];
            if (vn.includes("-")) {
              let [vs, ve] = vn.split("-").map((s) => parseInt(s));
              va = [vs];
              while (vs <= ve) {
                vs++;
                va.push(vs);
              }
            }
            for (const v of va) {
              const verseScope = `verse/${v}`;
              workspace.os.push(verseScope);
              if (!workspace.block.is.includes(verseScope)) {
                workspace.block.is.push(verseScope);
              }
              workspace.block.items.push({
                type: "scope",
                subType: "start",
                payload: verseScope
              });
            }
            const versesScope = `verses/${element.atts["number"]}`;
            if (!workspace.block.is.includes(versesScope)) {
              workspace.block.is.push(versesScope);
            }
            workspace.os.push(versesScope);
            workspace.block.items.push({
              type: "scope",
              subType: "start",
              payload: versesScope
            });
          }
        }
      ],
      startMilestone: [
        {
          description: "Add scope and update state",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const element = context.sequences[0].element;
            const milestoneScope = `milestone/${element.subType.split(":")[1]}`;
            if (!workspace.block.is.includes(milestoneScope)) {
              workspace.block.is.push(milestoneScope);
            }
            workspace.os.push(milestoneScope);
            workspace.block.items.push({
              type: "scope",
              subType: "start",
              payload: milestoneScope
            });
            for (const [attKey, attValue] of Object.entries(element.atts || {})) {
              const valueParts = attValue.toString().split(",");
              for (const [partN, part] of valueParts.entries()) {
                const attScope = `attribute/milestone/${element.subType.split(":")[1]}/${attKey}/${partN}/${part}`;
                if (!workspace.block.is.includes(attScope)) {
                  workspace.block.is.push(attScope);
                }
                workspace.os.push(attScope);
                workspace.block.items.push({
                  type: "scope",
                  subType: "start",
                  payload: attScope
                });
              }
            }
          }
        }
      ],
      endMilestone: [
        {
          description: "Remove scope and update state",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const element = context.sequences[0].element;
            const attScopeRoot = `attribute/milestone/${element.subType.split(":")[1]}`;
            for (const att of [...workspace.os.filter((s) => s.startsWith(attScopeRoot))].reverse()) {
              workspace.os = workspace.os.filter((o) => o !== att);
              workspace.block.items.push({
                type: "scope",
                subType: "end",
                payload: att
              });
            }
            const milestoneScope = `milestone/${element.subType.split(":")[1]}`;
            workspace.os = workspace.os.filter((s) => s !== milestoneScope);
            workspace.block.items.push({
              type: "scope",
              subType: "end",
              payload: milestoneScope
            });
          }
        }
      ],
      startWrapper: [
        {
          description: "Add scope and update state",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const element = context.sequences[0].element;
            const wrapperScope = `${element.subType === "usfm:w" ? "spanWithAtts" : "span"}/${element.subType.split(":")[1]}`;
            if (!workspace.block.is.includes(wrapperScope)) {
              workspace.block.is.push(wrapperScope);
            }
            workspace.os.push(wrapperScope);
            workspace.block.items.push({
              type: "scope",
              subType: "start",
              payload: wrapperScope
            });
            for (const [attKey, attValue] of Object.entries(element.atts || {})) {
              const valueParts = attValue.toString().split(",");
              for (const [partN, part] of valueParts.entries()) {
                const attScope = `attribute/spanWithAtts/w/${attKey}/${partN}/${part}`;
                if (!workspace.block.is.includes(attScope)) {
                  workspace.block.is.push(attScope);
                }
                workspace.os.push(attScope);
                workspace.block.items.push({
                  type: "scope",
                  subType: "start",
                  payload: attScope
                });
              }
            }
          }
        }
      ],
      endWrapper: [
        {
          description: "Remove scope and update state",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const element = context.sequences[0].element;
            for (const [attKey, attValue] of [...Object.entries(element.atts || {})].reverse()) {
              const valueParts = attValue.toString().split(",");
              for (const [partN, part] of [...valueParts.entries()].reverse()) {
                const attScope = `attribute/spanWithAtts/w/${attKey}/${partN}/${part}`;
                workspace.os = workspace.os.filter((o) => o !== attScope);
                workspace.block.items.push({
                  type: "scope",
                  subType: "end",
                  payload: attScope
                });
              }
            }
            const wrapperScope = `${element.subType === "usfm:w" ? "spanWithAtts" : "span"}/${element.subType.split(":")[1]}`;
            workspace.os = workspace.os.filter((s) => s !== wrapperScope);
            workspace.block.items.push({
              type: "scope",
              subType: "end",
              payload: wrapperScope
            });
          }
        }
      ],
      text: [
        {
          description: "Log occurrences",
          test: () => true,
          action: ({
            context,
            workspace
          }) => {
            const text = context.sequences[0].element.text;
            const re = xre.union(lexingRegexes2.map((x) => x[2]));
            const words = xre.match(text, re, "all");
            for (const word of words) {
              let subType;
              if (xre.test(word, wordLikeRegex)) {
                subType = "wordLike";
              } else if (xre.test(word, lineSpaceRegex)) {
                subType = "lineSpace";
              } else if (xre.test(word, punctuationRegex)) {
                subType = "punctuation";
              }
              workspace.block.items.push({
                type: "token",
                subType,
                payload: word
              });
            }
          }
        }
      ],
      endDocument: [
        {
          description: "Rework hanging end cv scopes",
          test: () => true,
          action: ({ output }) => {
            const sequenceBlocks = Object.values(output.pkJson)[0];
            for (let blockN = 1; blockN < sequenceBlocks.length; blockN++) {
              let thisBlockItems = sequenceBlocks[blockN].items;
              const lastBlockItems = sequenceBlocks[blockN - 1].items;
              let itemN = 0;
              while (itemN < thisBlockItems.length) {
                const item = thisBlockItems[itemN];
                if (item.type !== "scope" || item.subType !== "end") {
                  break;
                }
                itemN++;
              }
              while (itemN > 0) {
                const movingScope = thisBlockItems.shift();
                lastBlockItems.push(movingScope);
                sequenceBlocks[blockN].os = sequenceBlocks[blockN].os.filter((s) => s !== movingScope.payload);
                itemN--;
              }
            }
          }
        }
      ]
    };
    var perf2PkJsonCode = function({ perf }) {
      const cl = new PerfRenderFromJson2(
        {
          srcJson: perf,
          ignoreMissingSequences: true,
          actions: perf2PkJsonActions
        }
      );
      const output = {};
      cl.renderDocument({
        docId: "",
        config: {},
        output
      });
      return { pkJson: output.pkJson };
    };
    var perf2PkJson = {
      name: "perf2PkJson",
      type: "Transform",
      description: "PERF=>JSON: Converts PERF to current Proskomma input format",
      documentation: "",
      inputs: [
        {
          name: "perf",
          type: "json",
          source: ""
        }
      ],
      outputs: [
        {
          name: "pkJson",
          type: "json"
        }
      ],
      code: perf2PkJsonCode
    };
    module.exports = perf2PkJson;
  }
});

// node_modules/proskomma-core/src/transforms/index.cjs
var require_transforms6 = __commonJS({
  "node_modules/proskomma-core/src/transforms/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var calculateUsfmChapterPositions = require_calculateUsfmChapterPositions3();
    var perf2usfm = require_perf2usfm();
    var perf2PkJson = require_perf2PkJson();
    module.exports = {
      calculateUsfmChapterPositions,
      perf2usfm,
      perf2PkJson
    };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/chapter_verse.cjs
var require_chapter_verse = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/chapter_verse.cjs"(exports, module) {
    init_process();
    init_buffer();
    var BitSet = require_bitset();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var { itemEnum } = utils.itemDefs;
    var { tokenEnum } = utils.tokenDefs;
    var emptyCVIndexType = 0;
    var shortCVIndexType = 2;
    var longCVIndexType = 3;
    var buildChapterVerseIndex = (document2) => {
      const mainSequence = document2.sequences[document2.mainId];
      const docSet = document2.processor.docSets[document2.docSetId];
      docSet.buildPreEnums();
      docSet.buildEnumIndexes();
      const chapterVerseIndexes = {};
      const chapterIndexes = {};
      let chapterN = "0";
      let verseN = "0";
      let verses = "1";
      let nextTokenN = 0;
      mainSequence.chapterVerses = {};
      if (docSet.enums.wordLike.length === 0) {
        throw new Error("No wordLike content in docSet - probably a USFM issue, maybe missing \\mt?");
      }
      mainSequence.tokensPresent = new BitSet(
        new Array(docSet.enums.wordLike.length).fill(0).map((b) => b.toString()).join("")
      );
      for (const [blockN, block2] of mainSequence.blocks.entries()) {
        let pos = 0;
        let succinct = block2.c;
        let itemN = -1;
        while (pos < succinct.length) {
          itemN++;
          const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(succinct, pos);
          if (itemType === itemEnum["startScope"]) {
            let scopeLabel = docSet.succinctScopeLabel(succinct, itemSubtype, pos);
            if (scopeLabel.startsWith("chapter/")) {
              chapterN = scopeLabel.split("/")[1];
              chapterVerseIndexes[chapterN] = {};
              chapterIndexes[chapterN] = {
                startBlock: blockN,
                startItem: itemN,
                nextToken: nextTokenN
              };
            } else if (scopeLabel.startsWith("verse/")) {
              verseN = scopeLabel.split("/")[1];
              if (verseN === "1" && !("0" in chapterVerseIndexes[chapterN])) {
                if (chapterIndexes[chapterN].nextToken < nextTokenN) {
                  chapterVerseIndexes[chapterN]["0"] = [{
                    startBlock: chapterIndexes[chapterN].startBlock,
                    startItem: chapterIndexes[chapterN].startItem,
                    endBlock: blockN,
                    endItem: Math.max(itemN - 1, 0),
                    nextToken: chapterIndexes[chapterN].nextToken,
                    verses: "0"
                  }];
                }
              }
              if (!(verseN in chapterVerseIndexes[chapterN])) {
                chapterVerseIndexes[chapterN][verseN] = [];
              }
              chapterVerseIndexes[chapterN][verseN].push({
                startBlock: blockN,
                startItem: itemN,
                nextToken: nextTokenN
              });
            } else if (scopeLabel.startsWith("verses/")) {
              verses = scopeLabel.split("/")[1];
            }
          } else if (itemType === itemEnum["endScope"]) {
            let scopeLabel = docSet.succinctScopeLabel(succinct, itemSubtype, pos);
            if (scopeLabel.startsWith("chapter/")) {
              chapterN = scopeLabel.split("/")[1];
              let chapterRecord = chapterIndexes[chapterN];
              if (chapterRecord) {
                chapterRecord.endBlock = blockN;
                chapterRecord.endItem = itemN;
              }
            } else if (scopeLabel.startsWith("verse/")) {
              verseN = scopeLabel.split("/")[1];
              let versesRecord = chapterVerseIndexes[chapterN][verseN];
              if (versesRecord) {
                const verseRecord = chapterVerseIndexes[chapterN][verseN][chapterVerseIndexes[chapterN][verseN].length - 1];
                verseRecord.endBlock = blockN;
                verseRecord.endItem = itemN;
                verseRecord.verses = verses;
              }
            }
          } else if (itemType === itemEnum["token"] && itemSubtype === tokenEnum["wordLike"]) {
            mainSequence.tokensPresent.set(
              succinct.nByte(pos + 2),
              1
            );
            nextTokenN++;
          }
          pos += itemLength;
        }
      }
      for (const [chapterN2, chapterVerses] of Object.entries(chapterVerseIndexes)) {
        const ba = new ByteArray();
        mainSequence.chapterVerses[chapterN2] = ba;
        const sortedVerses = Object.keys(chapterVerses).map((n) => parseInt(n)).sort((a, b) => a - b);
        if (sortedVerses.length === 0) {
          continue;
        }
        const maxVerse = sortedVerses[sortedVerses.length - 1];
        const verseSlots = Array.from(Array(maxVerse + 1).keys());
        let pos = 0;
        for (const verseSlot of verseSlots) {
          const verseKey = `${verseSlot}`;
          if (verseKey in chapterVerses) {
            const verseElements = chapterVerses[verseKey];
            const nVerseElements = verseElements.length;
            for (const [verseElementN, verseElement] of verseElements.entries()) {
              if (!verseElement.verses) {
                console.log(`** VerseElement without verses for ${verseSlot} in buildChapterVerseIndex`);
                continue;
              }
              const versesEnumIndex = docSet.enumForCategoryValue("scopeBits", verseElement.verses);
              const recordType = verseElement.startBlock === verseElement.endBlock ? shortCVIndexType : longCVIndexType;
              ba.pushByte(0);
              if (recordType === shortCVIndexType) {
                ba.pushNBytes([
                  verseElement.startBlock,
                  verseElement.startItem,
                  verseElement.endItem,
                  verseElement.nextToken,
                  versesEnumIndex
                ]);
              } else {
                ba.pushNBytes([
                  verseElement.startBlock,
                  verseElement.endBlock,
                  verseElement.startItem,
                  verseElement.endItem,
                  verseElement.nextToken,
                  versesEnumIndex
                ]);
              }
              ba.setByte(pos, makeVerseLengthByte(recordType, verseElementN === nVerseElements - 1, ba.length - pos));
              pos = ba.length;
            }
          } else {
            ba.pushByte(makeVerseLengthByte(emptyCVIndexType, true, 1));
            pos++;
          }
        }
        ba.trim();
      }
      mainSequence.chapters = {};
      for (const [chapterN2, chapterElement] of Object.entries(chapterIndexes)) {
        if (!("startBlock" in chapterElement) || !("endBlock" in chapterElement)) {
          continue;
        }
        const ba = new ByteArray();
        mainSequence.chapters[chapterN2] = ba;
        const recordType = chapterElement.startBlock === chapterElement.endBlock ? shortCVIndexType : longCVIndexType;
        ba.pushByte(0);
        if (recordType === shortCVIndexType) {
          ba.pushNBytes([chapterElement.startBlock, chapterElement.startItem, chapterElement.endItem, chapterElement.nextToken]);
        } else {
          ba.pushNBytes([chapterElement.startBlock, chapterElement.endBlock, chapterElement.startItem, chapterElement.endItem, chapterElement.nextToken]);
        }
        ba.setByte(0, makeVerseLengthByte(recordType, true, ba.length));
        ba.trim();
      }
    };
    var chapterVerseIndex = (document2, chapN) => {
      const docSet = document2.processor.docSets[document2.docSetId];
      docSet.buildEnumIndexes();
      const ret = [];
      const succinct = document2.sequences[document2.mainId].chapterVerses[chapN];
      if (succinct) {
        let pos = 0;
        let currentVerseRecord = [];
        while (pos < succinct.length) {
          const [recordType, isLast, recordLength] = verseLengthByte(succinct, pos);
          if (recordType === shortCVIndexType) {
            const nBytes = succinct.nBytes(pos + 1, 5);
            currentVerseRecord.push({
              startBlock: nBytes[0],
              endBlock: nBytes[0],
              startItem: nBytes[1],
              endItem: nBytes[2],
              nextToken: nBytes[3],
              verses: docSet.enums.scopeBits.countedString(docSet.enumIndexes.scopeBits[nBytes[4]])
            });
          } else if (recordType === longCVIndexType) {
            const nBytes = succinct.nBytes(pos + 1, 6);
            currentVerseRecord.push({
              startBlock: nBytes[0],
              endBlock: nBytes[1],
              startItem: nBytes[2],
              endItem: nBytes[3],
              nextToken: nBytes[4],
              verses: docSet.enums.scopeBits.countedString(docSet.enumIndexes.scopeBits[nBytes[5]])
            });
          }
          if (isLast) {
            ret.push(currentVerseRecord);
            currentVerseRecord = [];
          }
          pos += recordLength;
        }
      }
      return ret;
    };
    var chapterIndex = (document2, chapN) => {
      const succinct = document2.sequences[document2.mainId].chapters[chapN];
      if (succinct) {
        const recordType = verseLengthByte(succinct, 0)[0];
        if (recordType === shortCVIndexType) {
          const nBytes = succinct.nBytes(1, 4);
          return {
            startBlock: nBytes[0],
            endBlock: nBytes[0],
            startItem: nBytes[1],
            endItem: nBytes[2],
            nextToken: nBytes[3]
          };
        } else if (recordType === longCVIndexType) {
          const nBytes = succinct.nBytes(1, 5);
          return {
            startBlock: nBytes[0],
            endBlock: nBytes[1],
            startItem: nBytes[2],
            endItem: nBytes[3],
            nextToken: nBytes[4]
          };
        }
      }
    };
    var makeVerseLengthByte = (recordType, isLast, length) => length + (isLast ? 32 : 0) + recordType * 64;
    var verseLengthByte = (succinct, pos) => {
      const sByte = succinct.byte(pos);
      return [
        sByte >> 6,
        (sByte >> 5) % 2 === 1,
        sByte % 32
      ];
    };
    module.exports = {
      buildChapterVerseIndex,
      chapterVerseIndex,
      chapterIndex
    };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/sequences.cjs
var require_sequences = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/sequences.cjs"(exports, module) {
    init_process();
    init_buffer();
    var deepCopy = require_deepCopyAll_min();
    var utils = require_util();
    var gcSequences = (document2) => {
      const usedSequences = /* @__PURE__ */ new Set();
      const docSet = document2.processor.docSets[document2.docSetId];
      docSet.maybeBuildEnumIndexes();
      const followGrafts = (document3, sequence, used) => {
        used.add(sequence.id);
        for (const block2 of sequence.blocks) {
          for (const blockGraft of docSet.unsuccinctifyGrafts(block2.bg)) {
            if (!used.has(blockGraft[2])) {
              followGrafts(document3, document3.sequences[blockGraft[2]], used);
            }
          }
          for (const inlineGraft of docSet.unsuccinctifyItems(block2.c, { grafts: true }, 0)) {
            if (!used.has(inlineGraft[2])) {
              followGrafts(document3, document3.sequences[inlineGraft[2]], used);
            }
          }
        }
      };
      followGrafts(document2, document2.sequences[document2.mainId], usedSequences);
      let changed = false;
      for (const sequenceId of Object.keys(document2.sequences)) {
        if (!usedSequences.has(sequenceId)) {
          delete document2.sequences[sequenceId];
          changed = true;
        }
      }
      return changed;
    };
    var newSequence = (document2, seqType, tags) => {
      const seqId = utils.generateId();
      document2.sequences[seqId] = {
        id: seqId,
        type: seqType,
        tags: new Set(tags || []),
        isBaseType: seqType in document2.baseSequenceTypes,
        blocks: []
      };
      return seqId;
    };
    var deleteSequence = (document2, seqId) => {
      if (!(seqId in document2.sequences)) {
        return false;
      }
      if (document2.sequences[seqId].type === "main") {
        throw new Error("Cannot delete main sequence");
      }
      if (document2.sequences[seqId].type in document2.baseSequenceTypes) {
        gcSequenceReferences(document2, "block", seqId);
      } else {
        gcSequenceReferences(document2, "inline", seqId);
      }
      delete document2.sequences[seqId];
      document2.buildChapterVerseIndex(exports);
      document2.gcSequences();
      return true;
    };
    var gcSequenceReferences = (document2, seqContext, seqId) => {
      const docSet = document2.processor.docSets[document2.docSetId];
      for (const sequence of Object.values(document2.sequences)) {
        for (const block2 of sequence.blocks) {
          const succinct = seqContext === "block" ? block2.bg : block2.c;
          let pos = 0;
          while (pos < succinct.length) {
            const [itemLength, itemType] = utils.succinct.headerBytes(succinct, pos);
            if (itemType !== utils.itemDefs.itemEnum.graft) {
              pos += itemLength;
            } else {
              const graftSeqId = utils.succinct.succinctGraftSeqId(docSet.enums, docSet.enumIndexes, succinct, pos);
              if (graftSeqId === seqId) {
                succinct.deleteItem(pos);
              } else {
                pos += itemLength;
              }
            }
          }
        }
      }
    };
    var modifySequence = (document2, seqId, sequenceRewriteFunc, blockFilterFunc, itemFilterFunc, blockRewriteFunc, itemRewriteFunc) => {
      const docSet = document2.processor.docSets[document2.docSetId];
      docSet.maybeBuildEnumIndexes();
      sequenceRewriteFunc = sequenceRewriteFunc || ((s) => s);
      const oldSequence = document2.sequences[seqId];
      const newSequence2 = sequenceRewriteFunc({
        id: seqId,
        type: oldSequence.type,
        tags: oldSequence.tags,
        isBaseType: oldSequence.isBaseType,
        verseMapping: oldSequence.verseMapping
      });
      pushModifiedBlocks(
        oldSequence,
        newSequence2,
        blockFilterFunc,
        itemFilterFunc,
        blockRewriteFunc,
        itemRewriteFunc
      );
      document2.sequences[seqId] = newSequence2;
      if (newSequence2.type === "main") {
        document2.buildChapterVerseIndex();
      }
      return newSequence2;
    };
    var pushModifiedBlocks = (oldSequence, newSequence2, blockFilterFunc, itemFilterFunc, blockRewriteFunc, itemRewriteFunc) => {
      blockFilterFunc = blockFilterFunc || ((oldSequence2, blockN, block2) => !!block2);
      itemFilterFunc = itemFilterFunc || ((oldSequence2, oldBlockN, block2, itemN, itemType, itemSubType, pos) => !!block2 || pos);
      blockRewriteFunc = blockRewriteFunc || ((oldSequence2, blockN, block2) => block2);
      itemRewriteFunc = itemRewriteFunc || ((oldSequence2, oldBlockN, oldBlock, newBlock, itemN, itemLength, itemType, itemSubType, pos) => {
        for (let n = 0; n < itemLength; n++) {
          newBlock.c.pushByte(oldBlock.c.byte(pos + n));
        }
      });
      newSequence2.blocks = [];
      for (const [blockN, block2] of oldSequence.blocks.entries()) {
        if (blockFilterFunc(oldSequence, blockN, block2)) {
          const newBlock = blockRewriteFunc(oldSequence, blockN, deepCopy(block2));
          newBlock.c.clear();
          modifyBlockItems(
            oldSequence,
            blockN,
            block2,
            newBlock,
            itemFilterFunc,
            itemRewriteFunc
          );
          newSequence2.blocks.push(newBlock);
        }
      }
    };
    var modifyBlockItems = (oldSequence, oldBlockN, oldBlock, newBlock, itemFilterFunc, itemRewriteFunc) => {
      let pos = 0;
      let itemN = -1;
      while (pos < oldBlock.c.length) {
        itemN++;
        const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(oldBlock.c, pos);
        if (itemFilterFunc(oldSequence, oldBlockN, oldBlock, itemN, itemType, itemSubtype, pos)) {
          itemRewriteFunc(oldSequence, oldBlockN, oldBlock, newBlock, itemN, itemLength, itemType, itemSubtype, pos);
        }
        pos += itemLength;
      }
    };
    module.exports = {
      newSequence,
      gcSequences,
      deleteSequence,
      modifySequence
    };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/blocks.cjs
var require_blocks = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/blocks.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var {
      pushSuccinctGraftBytes,
      pushSuccinctScopeBytes,
      pushSuccinctTokenBytes
    } = utils.succinct;
    var { itemEnum } = utils.itemDefs;
    var {
      scopeEnum,
      scopeEnumLabels,
      nComponentsForScope
    } = utils.scopeDefs;
    var { tokenCategory, tokenEnum } = utils.tokenDefs;
    var { headerBytes } = utils.succinct;
    var { updateBlockGrafts } = require_update();
    var deleteBlock = (document2, seqId, blockN, buildCV) => {
      if (buildCV !== false) {
        buildCV = true;
      }
      if (!(seqId in document2.sequences)) {
        return false;
      }
      const sequence = document2.sequences[seqId];
      if (blockN < 0 || blockN >= sequence.blocks.length) {
        return false;
      }
      sequence.blocks.splice(blockN, 1);
      if (buildCV) {
        document2.buildChapterVerseIndex(exports);
      }
      return true;
    };
    var newBlock = (document2, seqId, blockN, blockScope, blockGrafts, buildCV) => {
      if (buildCV !== false) {
        buildCV = true;
      }
      if (!(seqId in document2.sequences)) {
        return false;
      }
      const sequence = document2.sequences[seqId];
      if (blockN < 0 || blockN > sequence.blocks.length) {
        return false;
      }
      const docSet = document2.processor.docSets[document2.docSetId];
      docSet.maybeBuildPreEnums();
      const newBlock2 = {
        bs: new ByteArray(0),
        bg: new ByteArray(0),
        c: new ByteArray(0),
        os: new ByteArray(0),
        is: new ByteArray(0),
        nt: new ByteArray(0)
      };
      const scopeBits = blockScope.split("/");
      const scopeTypeByte = scopeEnum[scopeBits[0]];
      const expectedNScopeBits = nComponentsForScope(scopeBits[0]);
      if (scopeBits.length !== expectedNScopeBits) {
        throw new Error(`Scope ${blockScope} has ${scopeBits.length} component(s) (expected ${expectedNScopeBits}`);
      }
      const scopeBitBytes = scopeBits.slice(1).map((b) => docSet.enumForCategoryValue("scopeBits", b, true));
      pushSuccinctScopeBytes(newBlock2.bs, itemEnum[`startScope`], scopeTypeByte, scopeBitBytes);
      newBlock2.bs.trim();
      if (blockGrafts) {
        updateBlockGrafts(
          docSet,
          document2.id,
          seqId,
          blockN,
          blockGrafts
        );
      }
      sequence.blocks.splice(blockN, 0, newBlock2);
      if (buildCV) {
        document2.buildChapterVerseIndex();
      }
      return true;
    };
    var rewriteBlock = (block2, oldToNew) => {
      for (const blockKey of ["bs", "bg", "c", "is", "os"]) {
        const oldBa = block2[blockKey];
        const newBa = new ByteArray(oldBa.length);
        let pos = 0;
        while (pos < oldBa.length) {
          const [itemLength, itemType, itemSubtype] = headerBytes(oldBa, pos);
          if (itemType === itemEnum["token"]) {
            if (itemSubtype === tokenEnum.wordLike) {
              pushSuccinctTokenBytes(newBa, itemSubtype, oldToNew.wordLike[oldBa.nByte(pos + 2)]);
            } else {
              pushSuccinctTokenBytes(newBa, itemSubtype, oldToNew.notWordLike[oldBa.nByte(pos + 2)]);
            }
          } else if (itemType === itemEnum["graft"]) {
            pushSuccinctGraftBytes(newBa, oldToNew.graftTypes[itemSubtype], oldToNew.ids[oldBa.nByte(pos + 2)]);
          } else {
            let nScopeBitBytes = nComponentsForScope(scopeEnumLabels[itemSubtype]);
            const scopeBitBytes = [];
            let offset = 2;
            while (nScopeBitBytes > 1) {
              const scopeBitByte = oldToNew.scopeBits[oldBa.nByte(pos + offset)];
              scopeBitBytes.push(scopeBitByte);
              offset += oldBa.nByteLength(scopeBitByte);
              nScopeBitBytes--;
            }
            pushSuccinctScopeBytes(newBa, itemType, itemSubtype, scopeBitBytes);
          }
          pos += itemLength;
        }
        newBa.trim();
        block2[blockKey] = newBa;
      }
    };
    module.exports = {
      newBlock,
      deleteBlock,
      rewriteBlock
    };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/succinct_filter.cjs
var require_succinct_filter = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/succinct_filter.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var ByteArray = utils.ByteArray;
    var { itemEnum } = utils.itemDefs;
    var succinctFilter = (document2, filterOptions) => {
      if (!filterOptions || Object.keys(filterOptions).length === 0) {
        return;
      }
      const docSet = document2.processor.docSets[document2.docSetId];
      const filterItem = (oldSequence, oldBlockN, block2, itemN, itemType, itemSubType, pos) => {
        if (itemType === itemEnum.token) {
          return true;
        } else if (itemType === itemEnum.startScope || itemType === itemEnum.endScope) {
          if (!filterOptions.includeScopes && !filterOptions.excludeScopes) {
            return true;
          } else {
            const scopeOb = docSet.unsuccinctifyScope(block2.c, itemType, itemSubType, pos);
            return (!filterOptions.includeScopes || filterOptions.includeScopes.filter((op) => scopeOb[2].startsWith(op)).length > 0) && (!filterOptions.excludeScopes || filterOptions.excludeScopes.filter((op) => scopeOb[2].startsWith(op)).length === 0);
          }
        } else {
          if (!filterOptions.includeGrafts && !filterOptions.excludeGrafts) {
            return true;
          }
          const graftOb = docSet.unsuccinctifyGraft(block2.c, itemSubType, pos);
          return (!filterOptions.includeGrafts || filterOptions.includeGrafts.filter((op) => graftOb[1].startsWith(op)).length > 0) && (!filterOptions.excludeGrafts || filterOptions.excludeGrafts.filter((op) => graftOb[1].startsWith(op)).length === 0);
        }
      };
      const rewriteBlock = (oldSequence, blockN, block2) => {
        const newBA = new ByteArray(block2.bg.length);
        let pos = 0;
        while (pos < block2.bg.length) {
          const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bg, pos);
          const graftOb = docSet.unsuccinctifyGraft(block2.bg, itemSubtype, pos);
          if ((!filterOptions.includeGrafts || filterOptions.includeGrafts.filter((op) => graftOb[1].startsWith(op)).length > 0) && (!filterOptions.excludeGrafts || filterOptions.excludeGrafts.filter((op) => graftOb[1].startsWith(op)).length === 0)) {
            for (let n = 0; n < itemLength; n++) {
              newBA.pushByte(block2.bg.byte(pos + n));
            }
          }
          pos += itemLength;
        }
        newBA.trim();
        block2.bg = newBA;
        return block2;
      };
      Object.keys(document2.sequences).forEach(
        (seqId) => {
          document2.modifySequence(
            seqId,
            null,
            null,
            filterItem,
            rewriteBlock,
            null
          );
        }
      );
      Object.values(document2.sequences).forEach(
        (seq) => docSet.updateBlockIndexesAfterFilter(seq)
      );
      document2.gcSequences();
    };
    module.exports = { succinctFilter };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/serialize_succinct.cjs
var require_serialize_succinct = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/serialize_succinct.cjs"(exports, module) {
    init_process();
    init_buffer();
    var serializeSuccinct = (document2) => {
      const ret = { sequences: {} };
      ret.headers = document2.headers;
      ret.mainId = document2.mainId;
      ret.tags = Array.from(document2.tags);
      for (const [seqId, seqOb] of Object.entries(document2.sequences)) {
        ret.sequences[seqId] = serializeSuccinctSequence(seqOb);
      }
      return ret;
    };
    var serializeSuccinctSequence = (seqOb) => {
      const ret = {
        type: seqOb.type,
        blocks: seqOb.blocks.map((b) => serializeSuccinctBlock(b)),
        tags: Array.from(seqOb.tags)
      };
      if (seqOb.type === "main") {
        ret.chapters = {};
        for (const [chK, chV] of Object.entries(seqOb.chapters || {})) {
          chV.trim();
          ret.chapters[chK] = chV.base64();
        }
        ret.chapterVerses = {};
        for (const [chvK, chvV] of Object.entries(seqOb.chapterVerses || {})) {
          chvV.trim();
          ret.chapterVerses[chvK] = chvV.base64();
        }
        if ("tokensPresent" in seqOb) {
          ret.tokensPresent = "0x" + seqOb.tokensPresent.toString(16);
        }
      }
      return ret;
    };
    var serializeSuccinctBlock = (blockOb) => {
      for (const succName of ["bs", "bg", "c", "is", "os", "nt"]) {
        blockOb[succName].trim();
      }
      return {
        bs: blockOb.bs.base64(),
        bg: blockOb.bg.base64(),
        c: blockOb.c.base64(),
        is: blockOb.is.base64(),
        os: blockOb.os.base64(),
        nt: blockOb.nt.base64()
      };
    };
    module.exports = { serializeSuccinct };
  }
});

// node_modules/proskomma-core/src/model/document_helpers/pre_enums.cjs
var require_pre_enums = __commonJS({
  "node_modules/proskomma-core/src/model/document_helpers/pre_enums.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var recordPreEnums = (docSet, seq) => {
      docSet.recordPreEnum("scopeBits", "0");
      for (const [blockN, block2] of seq.blocks.entries()) {
        for (const [itemN, item] of [...block2.items, block2.bs, ...block2.bg].entries()) {
          if (item.subType === "wordLike") {
            docSet.recordPreEnum("wordLike", item.payload);
          } else if (["lineSpace", "eol", "punctuation", "softLineBreak", "bareSlash", "unknown"].includes(item.subType)) {
            docSet.recordPreEnum("notWordLike", item.payload);
          } else if (item.type === "graft") {
            docSet.recordPreEnum("graftTypes", item.subType);
          } else if (item.subType === "start") {
            const labelBits = item.payload.split("/");
            if (labelBits.length !== utils.scopeDefs.nComponentsForScope(labelBits[0])) {
              throw new Error(`Scope ${item.payload} has unexpected number of components`);
            }
            for (const labelBit of labelBits.slice(1)) {
              docSet.recordPreEnum("scopeBits", labelBit);
            }
          }
        }
      }
    };
    var rerecordPreEnums = (docSet, seq) => {
      docSet.recordPreEnum("scopeBits", "0");
      docSet.recordPreEnum("ids", seq.id);
      for (const block2 of seq.blocks) {
        for (const blockKey of ["bs", "bg", "c", "is", "os"]) {
          rerecordBlockPreEnums(docSet, block2[blockKey]);
        }
      }
    };
    var rerecordBlockPreEnums = (docSet, ba) => {
      for (const item of docSet.unsuccinctifyItems(ba, {}, 0)) {
        if (item[0] === "token") {
          if (item[1] === "wordLike") {
            docSet.recordPreEnum("wordLike", item[2]);
          } else {
            docSet.recordPreEnum("notWordLike", item[2]);
          }
        } else if (item[0] === "graft") {
          docSet.recordPreEnum("graftTypes", item[1]);
        } else if (item[0] === "scope" && item[1] === "start") {
          const labelBits = item[2].split("/");
          if (labelBits.length !== utils.scopeDefs.nComponentsForScope(labelBits[0])) {
            throw new Error(`Scope ${item[2]} has unexpected number of components`);
          }
          for (const labelBit of labelBits.slice(1)) {
            docSet.recordPreEnum("scopeBits", labelBit);
          }
        }
      }
    };
    module.exports = {
      recordPreEnums,
      rerecordPreEnums
    };
  }
});

// node_modules/proskomma-core/src/model/document.cjs
var require_document = __commonJS({
  "node_modules/proskomma-core/src/model/document.cjs"(exports, module) {
    init_process();
    init_buffer();
    var {
      PerfRenderFromProskomma,
      SofriaRenderFromProskomma,
      render,
      PipelineHandler
    } = require_dist();
    var utils = require_util();
    var {
      parseUsfm,
      parseUsx,
      parseTableToDocument,
      parseNodes
    } = require_lexers();
    var { Parser: Parser2 } = require_parser();
    var pipelines = require_perf2x();
    var customTransforms = require_transforms6();
    var {
      buildChapterVerseIndex,
      chapterVerseIndex,
      chapterIndex
    } = require_chapter_verse();
    var {
      modifySequence,
      deleteSequence,
      gcSequences,
      newSequence
    } = require_sequences();
    var {
      deleteBlock,
      newBlock,
      rewriteBlock
    } = require_blocks();
    var { succinctFilter } = require_succinct_filter();
    var { serializeSuccinct } = require_serialize_succinct();
    var {
      recordPreEnums,
      rerecordPreEnums
    } = require_pre_enums();
    var {
      addTag,
      removeTag,
      validateTags
    } = utils.tags;
    var parserConstantDef = utils.parserConstants;
    var maybePrint = (str) => str;
    var Document = class {
      constructor(processor, docSetId, contentType, contentString, filterOptions, customTags, emptyBlocks, tags) {
        this.processor = processor;
        this.docSetId = docSetId;
        this.baseSequenceTypes = parserConstantDef.usfm.baseSequenceTypes;
        if (contentType) {
          this.id = utils.generateId();
          this.filterOptions = filterOptions;
          this.customTags = customTags;
          this.emptyBlocks = emptyBlocks;
          this.tags = new Set(tags || []);
          validateTags(this.tags);
          this.headers = {};
          this.mainId = null;
          this.sequences = {};
          switch (contentType.toLowerCase()) {
            case "usfm":
            case "sfm":
              this.processUsfm(contentString);
              break;
            case "usx":
              this.processUsx(contentString);
              break;
            case "tsv":
              this.processTSV(contentString);
              break;
            case "nodes":
              this.processNodes(contentString);
              break;
            default:
              throw new Error(`Unknown document contentType '${contentType}'`);
          }
        }
      }
      addTag(tag) {
        addTag(this.tags, tag);
      }
      removeTag(tag) {
        removeTag(this.tags, tag);
      }
      makeParser() {
        return new Parser2(
          this.filterOptions,
          this.customTags,
          this.emptyBlocks
        );
      }
      processUsfm(usfmString) {
        const parser = this.makeParser();
        const t = Date.now();
        parseUsfm(usfmString, parser);
        const t2 = Date.now();
        maybePrint(`
Parse USFM in ${t2 - t} msec`);
        this.postParseScripture(parser);
        maybePrint(`Total USFM import time = ${Date.now() - t} msec (parse = ${(t2 - t) * 100 / (Date.now() - t)}%)`);
      }
      processUsx(usxString) {
        const parser = this.makeParser();
        const t = Date.now();
        parseUsx(usxString, parser);
        const t2 = Date.now();
        maybePrint(`
Parse USX in ${t2 - t} msec`);
        this.postParseScripture(parser);
        maybePrint(`Total USX import time = ${Date.now() - t} msec (parse = ${(t2 - t) * 100 / (Date.now() - t)}%)`);
      }
      processTSV(tsvString) {
        const parser = this.makeParser();
        const bookCode = `T${this.processor.nextTable > 9 ? this.processor.nextTable : "0" + this.processor.nextTable}`;
        this.processor.nextTable++;
        parseTableToDocument(tsvString, parser, bookCode);
        this.headers = parser.headers;
        this.succinctPass1(parser);
        this.succinctPass2(parser);
        buildChapterVerseIndex(this);
        const tableSequence = Object.values(this.sequences).filter((s) => s.type === "table")[0];
        for (const [colN, colHead] of JSON.parse(tsvString).headings.entries()) {
          tableSequence.tags.add(`col${colN}:${colHead}`);
        }
      }
      processNodes(nodesString) {
        const parser = this.makeParser();
        const bookCode = `N${this.processor.nextNodes > 9 ? this.processor.nextNodes : "0" + this.processor.nextNodes}`;
        this.processor.nextNodes++;
        parseNodes(nodesString, parser, bookCode);
        this.headers = parser.headers;
        this.succinctPass1(parser);
        this.succinctPass2(parser);
        buildChapterVerseIndex(this);
      }
      postParseScripture(parser) {
        let t = Date.now();
        parser.tidy();
        maybePrint(`Tidy in ${Date.now() - t} msec`);
        t = Date.now();
        const fo = parser.filterOptions;
        this.headers = parser.headers;
        this.succinctPass1(parser);
        maybePrint(`Succinct pass 1 in ${Date.now() - t} msec`);
        t = Date.now();
        this.succinctPass2(parser);
        maybePrint(`Succinct pass 2 in ${Date.now() - t} msec`);
        t = Date.now();
        this.succinctFilter(fo);
        maybePrint(`Filter in ${Date.now() - t} msec`);
        t = Date.now();
        buildChapterVerseIndex(this);
        maybePrint(`CV indexes in ${Date.now() - t} msec`);
      }
      succinctFilter(filterOptions) {
        succinctFilter(this, filterOptions);
      }
      succinctPass1(parser) {
        const docSet = this.processor.docSets[this.docSetId];
        let t = Date.now();
        for (const seq of parser.allSequences()) {
          docSet.recordPreEnum("ids", seq.id);
          this.recordPreEnums(docSet, seq);
        }
        maybePrint(`   recordPreEnums in ${Date.now() - t} msec`);
        t = Date.now();
        if (docSet.enums.wordLike.length === 0) {
          docSet.sortPreEnums();
          maybePrint(`   sortPreEnums in ${Date.now() - t} msec`);
          t = Date.now();
        }
        docSet.buildEnums();
        maybePrint(`   buildEnums in ${Date.now() - t} msec`);
      }
      recordPreEnums(docSet, seq) {
        recordPreEnums(docSet, seq);
      }
      rerecordPreEnums(docSet, seq) {
        rerecordPreEnums(docSet, seq);
      }
      succinctPass2(parser) {
        const docSet = this.processor.docSets[this.docSetId];
        this.mainId = parser.sequences.main.id;
        for (const seq of parser.allSequences()) {
          this.sequences[seq.id] = {
            id: seq.id,
            type: seq.type,
            tags: new Set(seq.tags),
            isBaseType: seq.type in parser.baseSequenceTypes,
            blocks: seq.succinctifyBlocks(docSet)
          };
        }
        this.sequences[this.mainId].verseMapping = {};
      }
      modifySequence(seqId, sequenceRewriteFunc, blockFilterFunc, itemFilterFunc, blockRewriteFunc, itemRewriteFunc) {
        modifySequence(
          this,
          seqId,
          sequenceRewriteFunc,
          blockFilterFunc,
          itemFilterFunc,
          blockRewriteFunc,
          itemRewriteFunc
        );
      }
      buildChapterVerseIndex() {
        buildChapterVerseIndex(this);
      }
      chapterVerseIndexes() {
        const ret = {};
        for (const chapN of Object.keys(this.sequences[this.mainId].chapterVerses)) {
          ret[chapN] = chapterVerseIndex(this, chapN);
        }
        return ret;
      }
      chapterVerseIndex(chapN) {
        return chapterVerseIndex(this, chapN);
      }
      chapterIndexes() {
        const ret = {};
        for (const chapN of Object.keys(this.sequences[this.mainId].chapters)) {
          ret[chapN] = chapterIndex(this, chapN);
        }
        return ret;
      }
      chapterIndex(chapN) {
        return chapterIndex(this, chapN);
      }
      rewriteSequenceBlocks(sequenceId, oldToNew) {
        const sequence = this.sequences[sequenceId];
        for (const block2 of sequence.blocks) {
          this.rewriteSequenceBlock(block2, oldToNew);
        }
      }
      rewriteSequenceBlock(block2, oldToNew) {
        rewriteBlock(block2, oldToNew);
      }
      serializeSuccinct() {
        return serializeSuccinct(this);
      }
      gcSequences() {
        return gcSequences(this);
      }
      newSequence(seqType, tags) {
        return newSequence(this, seqType, tags);
      }
      deleteSequence(seqId) {
        return deleteSequence(this, seqId);
      }
      deleteBlock(seqId, blockN, buildCV) {
        return deleteBlock(this, seqId, blockN, buildCV);
      }
      newBlock(seqId, blockN, blockScope, blockGrafts, buildCV) {
        return newBlock(this, seqId, blockN, blockScope, blockGrafts, buildCV);
      }
      perf(indent2) {
        const cl = new PerfRenderFromProskomma(
          {
            proskomma: this.processor,
            actions: render.perfToPerf.renderActions.identityActions
          }
        );
        const output = {};
        cl.renderDocument(
          {
            docId: this.id,
            config: {},
            output
          }
        );
        return indent2 ? JSON.stringify(output.perf, null, indent2) : JSON.stringify(output.perf);
      }
      async usfm() {
        const perf = JSON.parse(this.perf());
        try {
          const pipelineHandler = new PipelineHandler({
            pipelines,
            transforms: customTransforms,
            proskomma: this.processor
          });
          const output = await pipelineHandler.runPipeline("perf2usfmPipeline", { perf });
          return output.usfm;
        } catch (err) {
          console.error("pipelineHandler Error :\n", err);
        }
      }
      sofria(indent2, chapter) {
        const cl = new SofriaRenderFromProskomma(
          {
            proskomma: this.processor,
            actions: render.sofriaToSofria.renderActions.identityActions
          }
        );
        const output = {};
        const config2 = {};
        if (chapter) {
          config2.chapters = [`${chapter}`];
        }
        try {
          cl.renderDocument(
            {
              docId: this.id,
              config: config2,
              output
            }
          );
        } catch (err) {
          console.log(err);
          throw err;
        }
        return indent2 ? JSON.stringify(output.sofria, null, indent2) : JSON.stringify(output.sofria);
      }
    };
    module.exports = { Document };
  }
});

// node_modules/proskomma-core/src/graph/queries/key_value.cjs
var require_key_value = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/key_value.cjs"(exports, module) {
    init_process();
    init_buffer();
    var keyValueSchemaString = `
"""Key/Value tuple"""
type KeyValue {
    """The key"""
    key: String!
    """The value"""
    value: String!
}`;
    var keyValueResolvers = {
      key: (root) => root[0],
      value: (root) => root[1]
    };
    module.exports = {
      keyValueSchemaString,
      keyValueResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cv.cjs
var require_cv = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cv.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cvSchemaString = `
"""A chapter-verse reference"""
type cv {
  """The chapter number"""
  chapter: Int
  """The verse number"""
  verse: Int
}
`;
    var cvResolvers = {
      chapter: (root) => root[0],
      verse: (root) => root[1]
    };
    module.exports = {
      cvSchemaString,
      cvResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/idParts.cjs
var require_idParts = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/idParts.cjs"(exports, module) {
    init_process();
    init_buffer();
    var idPartsSchemaString = `
"""Type-dependent parts of the ID header"""
type idParts {
  """The type of the ID"""
  type: String
  """An array of parts of the ID"""
  parts: [String]
  """A part of the ID, by index"""
  part(
    """The numeric index of the part"""
    index: Int!
  ): String
}
`;
    var idPartsResolvers = {
      type: (root) => root[0],
      parts: (root) => root[1],
      part: (root, args) => {
        if (!root[1] || args.index < 0 || args.index >= root[1].length) {
          return null;
        }
        return root[1][args.index];
      }
    };
    module.exports = {
      idPartsSchemaString,
      idPartsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/input_att_spec.cjs
var require_input_att_spec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/input_att_spec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var inputAttSpecSchemaString = `
"""Attribute Specification"""
input AttSpec {
"""The type of attribute, ie what type of thing it's connected to"""
attType: String!
"""The name of the USFM tag to which the attribute is connected"""
tagName: String!
"""The attribute key (ie the bit to the left of the equals sign in USX)"""
attKey: String!
"""The position of the value (which is 0 except for attributes with multiple values)"""
valueN: Int!
}`;
    module.exports = { inputAttSpecSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/input_key_matches.cjs
var require_input_key_matches = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/input_key_matches.cjs"(exports, module) {
    init_process();
    init_buffer();
    var keyMatchesSchemaString = `
"""Key/Regex tuple"""
input KeyMatches {
  """The key"""
  key: String!
  """The regex to match"""
  matches: String!
}
`;
    module.exports = { keyMatchesSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/input_key_value.cjs
var require_input_key_value = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/input_key_value.cjs"(exports, module) {
    init_process();
    init_buffer();
    var inputKeyValueSchemaString = `
"""Input Key/Value Object"""
input InputKeyValue {
    """The key"""
    key: String!
    """The value"""
    value: String!
}
`;
    module.exports = { inputKeyValueSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/input_key_values.cjs
var require_input_key_values = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/input_key_values.cjs"(exports, module) {
    init_process();
    init_buffer();
    var keyValuesSchemaString = `
"""Input Key/Values Object"""
input KeyValues {
    """The key"""
    key: String!
    """The values"""
    values: [String!]!
}
`;
    module.exports = { keyValuesSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/inputItemObject.cjs
var require_inputItemObject = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/inputItemObject.cjs"(exports, module) {
    init_process();
    init_buffer();
    var inputItemObjectSchemaString = `
"""Item for arguments"""
input InputItemObject {
    """The basic item type (token, scope or graft)'"""
    type: String!
    """The type-dependent subtype of the item"""
    subType: String!
    """The content of the item (the text for tokens, the label for scopes and the sequence id for grafts)"""
    payload: String!
}`;
    module.exports = { inputItemObjectSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/item.cjs
var require_item2 = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/item.cjs"(exports, module) {
    init_process();
    init_buffer();
    var scopeMatchesStartsWith = (sw, s) => {
      if (sw.length === 0) {
        return true;
      }
      for (const swv of sw) {
        if (s.startsWith(swv)) {
          return true;
        }
      }
      return false;
    };
    var itemSchemaString = `
"""Item"""
type Item {
  """The basic item type (token, scope or graft)"""
  type: String!
  """The type-dependent subtype of the item"""
  subType: String!
  """The content of the item (the text for tokens, the label for scopes and the sequence id for grafts)"""
  payload(
    """If true, turn all whitespace into a normal space"""
    normalizeSpace: Boolean
    """A whitelist of characters to include"""
    includeChars: [String!]
    """A blacklist of characters to exclude"""
    excludeChars: [String!],
  ): String!
  """If 'includeContext' was selected, and for tokens, the index of the token from the start of the sequence"""
  position(
    """Only include scopes that begin with this value"""
    startsWith: [String!]
  ): Int
  """If 'includeContext' was selected, a list of scopes that are open around the item"""
  scopes(
    """Only include scopes that begin with this value"""
    startsWith: [String!]
  ): [String!]
}
`;
    var itemResolvers = {
      type: (root) => root[0],
      subType: (root) => root[1],
      payload: (root, args) => {
        let ret = root[2];
        if (root[0] === "token") {
          if (args.normalizeSpace) {
            ret = root[2].replace(/[ \t\n\r]+/g, " ");
          }
          if (args.includeChars || args.excludeChars) {
            let retArray = ret.split("");
            retArray = retArray.filter((c) => !args.includeChars || args.includeChars.includes(c));
            retArray = retArray.filter((c) => !args.excludeChars || !args.excludeChars.includes(c));
            ret = retArray.join("");
          }
        }
        return ret;
      },
      position: (root) => root[3],
      scopes: (root, args) => root[4] ? root[4].filter((s) => !args.startsWith || scopeMatchesStartsWith(args.startsWith, s)) : []
    };
    module.exports = {
      itemSchemaString,
      itemResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/lib/dump.cjs
var require_dump = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/dump.cjs"(exports, module) {
    init_process();
    init_buffer();
    var dumpItem = (i) => {
      let wrapper;
      switch (i[0]) {
        case "token":
          return `|${i[2]}`;
        case "scope":
          wrapper = i[1] === "start" ? "+" : "-";
          return `${wrapper}${i[2]}${wrapper}`;
        case "graft":
          return `>${i[1]}<`;
      }
    };
    var dumpItems = (il) => il.map((bci) => dumpItem(bci)).join("");
    var dumpItemGroup = (ig) => {
      const ret = ["ItemGroup:"];
      ret.push(`   Open Scopes ${ig[0].join(", ")}`);
      ret.push(`   ${dumpItems(ig[1])}`);
      return ret.join("\n");
    };
    var dumpBlock = (b) => {
      const ret = ["Block:"];
      if (b.bg.length > 0) {
        b.bg.forEach((bbg) => ret.push(`   ${bbg[1]} graft to ${bbg[2]}`));
      }
      ret.push(`   Scope ${b.bs[2]}`);
      ret.push(`   ${dumpItems(b.c)}`);
      return ret.join("\n");
    };
    module.exports = {
      dumpBlock,
      dumpItemGroup,
      dumpItems,
      dumpItem
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/itemGroup.cjs
var require_itemGroup = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/itemGroup.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { dumpItemGroup } = require_dump();
    var scopeMatchesStartsWith = (sw, s) => {
      if (sw.length === 0) {
        return true;
      }
      for (const swv of sw) {
        if (s.startsWith(swv)) {
          return true;
        }
      }
      return false;
    };
    var itemGroupSchemaString = `
"""A collection of items, with scope context"""
type ItemGroup {
  """Items for this itemGroup"""
  items: [Item!]!
  """Tokens for this itemGroup"""
  tokens(
    """Return tokens whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return tokens with one of the specified subTypes"""
    withSubTypes: [String!]
  ): [Item!]!
  """The text of the itemGroup as a single string"""
  text(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
  """The labels of scopes that were open at the beginning of the itemGroup"""
  scopeLabels(
    """Only include scopes that begin with this value"""
    startsWith: [String!]
  ): [String!]!
  """The itemGroup content as a string in a compact eyeballable format"""
  dump: String!
  """A list of scopes from the items of the itemGroup"""
  includedScopes: [String!]!
} 
`;
    var itemGroupResolvers = {
      items: (root) => root[1],
      tokens: (root, args) => root[1].filter(
        (i) => i[0] === "token" && (!args.withChars || args.withChars.includes(i[2])) && (!args.withSubTypes || args.withSubTypes.includes(i[1]))
      ),
      text: (root, args) => {
        const tokensText = root[1].filter((i) => i[0] === "token").map((t) => t[2]).join("");
        return args.normalizeSpace ? tokensText.replace(/[ \t\n\r]+/g, " ") : tokensText;
      },
      scopeLabels: (root, args) => root[0].filter((s) => !args.startsWith || scopeMatchesStartsWith(args.startsWith, s)),
      dump: (root) => dumpItemGroup(root),
      includedScopes: (root) => Array.from(
        new Set(
          root[1].filter((i) => i[0] === "scope" && i[1] === "start").map((t) => t[2])
        )
      )
    };
    module.exports = {
      itemGroupSchemaString,
      itemGroupResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/kv_entry.cjs
var require_kv_entry = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/kv_entry.cjs"(exports, module) {
    init_process();
    init_buffer();
    var kvEntrySchemaString = `
"""Key/Items tuple"""
type kvEntry {
    """The key"""
    key: String!
    """The secondary keys"""
    secondaryKeys: [KeyValue!]
    """The fields as itemGroups"""
    itemGroups: [ItemGroup]!
}`;
    var kvEntryResolvers = {
      key: (root) => root[0],
      secondaryKeys: (root) => root[1],
      itemGroups: (root) => root[2]
    };
    module.exports = {
      kvEntrySchemaString,
      kvEntryResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/regex_index.cjs
var require_regex_index = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/regex_index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var regexIndexSchemaString = `
"""Information about a regex match on an enum"""
type regexIndex {
    """The index in the enum"""
    index: String!
    """The string in the enum that matched"""
    matched: String!
}`;
    var regexIndexResolvers = {
      index: (root) => root[0],
      matched: (root) => root[1]
    };
    module.exports = {
      regexIndexSchemaString,
      regexIndexResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/row_equals_spec.cjs
var require_row_equals_spec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/row_equals_spec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var rowEqualsSpecSchemaString = `
"""Row Equals Specification"""
input rowEqualsSpec {
  """The position of the column in which to search a match"""
  colN: Int!
  """The values to match"""
  values: [String!]!
}
`;
    module.exports = { rowEqualsSpecSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/row_match_spec.cjs
var require_row_match_spec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/row_match_spec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var rowMatchSpecSchemaString = `
"""Row Match Specification"""
input rowMatchSpec {
  """The position of the column in which to search a match"""
  colN: Int!
  """The regex to match"""
  matching: String!
}
`;
    module.exports = { rowMatchSpecSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/verseRange.cjs
var require_verseRange = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/verseRange.cjs"(exports, module) {
    init_process();
    init_buffer();
    var verseRangeSchemaString = `
"""Information about a verse range (which may only cover one verse)"""
type verseRange {
  """The range, as it would be printed in a Bible"""
  range: String!
  """A list of verse numbers for this range"""
  numbers: [Int!]!
}
`;
    module.exports = { verseRangeSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/orig.cjs
var require_orig = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/orig.cjs"(exports, module) {
    init_process();
    init_buffer();
    var origSchemaString = `
"""Mapped verse information"""
type orig {
  """The book code"""
  book: String
  """A list of chapter-verse references"""
  cvs: [cv!]!
}
`;
    module.exports = { origSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/verseNumber.cjs
var require_verseNumber = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/verseNumber.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var verseNumberSchemaString = `
"""Information about a verse number (which may be part of a verse range)"""
type verseNumber {
  """The verse number"""
  number: Int!
  """The verse range to which the verse number belongs"""
  range: String!
  """The reference for this verse when mapped to 'original' versification"""
  orig: orig!
}
`;
    var verseNumberResolvers = {
      orig: (root, args, context) => {
        const localBook = context.doc.headers.bookCode;
        const localChapter = context.cvIndex[0];
        const localVerse = root.number;
        const mainSequence = context.doc.sequences[context.doc.mainId];
        if (mainSequence.verseMapping && "forward" in mainSequence.verseMapping && `${localChapter}` in mainSequence.verseMapping.forward) {
          const mapping = utils.versification.mapVerse(mainSequence.verseMapping.forward[`${localChapter}`], localBook, localChapter, localVerse);
          return {
            book: mapping[0],
            cvs: mapping[1]
          };
        } else {
          return {
            book: localBook,
            cvs: [[localChapter, localVerse]]
          };
        }
      }
    };
    module.exports = {
      verseNumberSchemaString,
      verseNumberResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cell.cjs
var require_cell = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cell.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cellSchemaString = `
"""A table cell"""
type cell {
  """The row numbers"""
  rows: [Int!]!
  """The column numbers"""
  columns: [Int!]!
  """A list of items from the c (content) field of the cell"""
  items: [Item!]!
  """A list of tokens from the c (content) field of the cell"""
  tokens: [Item!]!
  """The text of the cell as a single string"""
  text(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
}
`;
    var cellResolvers = {
      rows: (root) => root[0],
      columns: (root) => root[1],
      items: (root) => root[2],
      tokens: (root) => root[2].filter((i) => i[0] === "token"),
      text: (root, args) => {
        let ret = root[2].filter((i) => i[0] === "token").map((t) => t[2]).join("").trim();
        if (args.normalizeSpace) {
          ret = ret.replace(/[ \t\n\r]+/g, " ");
        }
        return ret;
      }
    };
    module.exports = {
      cellSchemaString,
      cellResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cIndex.cjs
var require_cIndex = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cIndex.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { dumpItems } = require_dump();
    var cIndexSchemaString = `
"""A chapter index entry"""
type cIndex {
  """The chapter number"""
  chapter: Int!
  """The zero-indexed number of the block where the chapter starts"""
  startBlock: Int
  """The zero-indexed number of the block where the chapter ends"""
  endBlock: Int
  """The zero-indexed position of the item where the chapter starts"""
  startItem: Int
  """The zero-indexed position of the item where the chapter ends"""
  endItem: Int
  """The value of nextToken at the beginning of the chapter"""
  nextToken: Int
  """A list of items for this chapter"""
  items(
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [Item]!
  """The items as a string in a compact eyeballable format"""
  dumpItems: String
  """A list of tokens for this chapter"""
  tokens(
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
    """Return tokens whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return tokens with one of the specified subTypes"""
    withSubTypes: [String!]
  ): [Item]!
  """The text of the chapter as a single string"""
  text(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
}
`;
    var cIndexResolvers = {
      chapter: (root) => root[0],
      startBlock: (root) => root[1].startBlock,
      endBlock: (root) => root[1].endBlock,
      startItem: (root) => root[1].startItem,
      endItem: (root) => root[1].endItem,
      nextToken: (root) => root[1].nextToken,
      items: (root, args, context) => context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root[1], args.includeContext).reduce((a, b) => a.concat([["token", "lineSpace", " "]].concat(b)), []),
      dumpItems: (root, args, context) => {
        const items = context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root[1], false);
        if (items.length > 0) {
          return dumpItems(items.reduce((a, b) => a.concat([["token", "lineSpace", " ", null]].concat(b))));
        } else {
          return "";
        }
      },
      tokens: (root, args, context) => context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root[1], args.includeContext).reduce((a, b) => a.concat([["token", "lineSpace", " "]].concat(b)), []).filter(
        (i) => i[0] === "token" && (!args.withChars || args.withChars.includes(i[2])) && (!args.withSubTypes || args.withSubTypes.includes(i[1]))
      ),
      text: (root, args, context) => {
        let ret = context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root[1]).reduce((a, b) => a.concat([["token", "lineSpace", " "]].concat(b)), []).filter((i) => i[0] === "token").map((t) => t[1] === "lineSpace" ? " " : t[2]).join("").trim();
        if (args.normalizeSpace) {
          ret = ret.replace(/[ \t\n\r]+/g, " ");
        }
        return ret;
      }
    };
    module.exports = {
      cIndexSchemaString,
      cIndexResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvVerseElement.cjs
var require_cvVerseElement = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvVerseElement.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { dumpItems } = require_dump();
    var cvVerseElementSchemaString = `
""""""
type cvVerseElement {
  """The zero-indexed number of the block where the verse starts"""
  startBlock: Int
  """The zero-indexed number of the block where the verse ends"""
  endBlock: Int
  """The zero-indexed position of the item where the verse starts"""
  startItem: Int
  """The zero-indexed position of the item where the verse ends"""
  endItem: Int
  """The value of nextToken at the beginning of the verse"""
  nextToken: Int
  """The verse range for this verse as it would be printed in a Bible"""
  verseRange: String
  """A list of items for this verse"""
  items(
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [Item]!
  """The items as a string in a compact eyeballable format"""
  dumpItems: String
  """A list of tokens for this verse"""
  tokens(
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
    """Return tokens whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return tokens with one of the specified subTypes"""
    withSubTypes: [String!]
  ): [Item]!
  """The text of the verse as a single string"""
  text(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
}
`;
    var cvVerseElementResolvers = {
      startBlock: (root) => root.startBlock,
      endBlock: (root) => root.endBlock,
      startItem: (root) => root.startItem,
      endItem: (root) => root.endItem,
      nextToken: (root) => root.nextToken,
      verseRange: (root) => root.verses,
      items: (root, args, context) => context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root, args.includeContext).reduce((a, b) => a.concat([["token", "lineSpace", " ", null]].concat(b))),
      dumpItems: (root, args, context) => dumpItems(
        context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root, args.includeContext).reduce((a, b) => a.concat([["token", "lineSpace", " ", null]].concat(b)))
      ),
      tokens: (root, args, context) => context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root, args.includeContext).reduce((a, b) => a.concat([["token", "lineSpace", " ", null]].concat(b))).filter(
        (i) => i[0] === "token" && (!args.withChars || args.withChars.includes(i[2])) && (!args.withSubTypes || args.withSubTypes.includes(i[1]))
      ),
      text: (root, args, context) => {
        let ret = context.docSet.itemsByIndex(context.doc.sequences[context.doc.mainId], root).reduce((a, b) => a.concat([["token", "lineSpace", " ", null]].concat(b))).filter((i) => i[0] === "token").map((t) => t[1] === "lineSpace" ? " " : t[2]).join("").trim();
        if (args.normalizeSpace) {
          ret = ret.replace(/[ \t\n\r]+/g, " ");
        }
        return ret;
      }
    };
    module.exports = {
      cvVerseElementSchemaString,
      cvVerseElementResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvVerses.cjs
var require_cvVerses = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvVerses.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cvVersesSchemaString = `
"""Information about a verse in the chapter, which may be split into several pieces"""
type cvVerses {
  """The pieces of verse"""
  verse: [cvVerseElement]
}
`;
    var cvVersesResolvers = { verse: (root) => root };
    module.exports = {
      cvVersesSchemaString,
      cvVersesResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvIndex.cjs
var require_cvIndex = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvIndex.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cvIndexSchemaString = `
"""A chapterVerse index entry"""
type cvIndex {
  """The chapter number"""
  chapter: Int!
  """Information about the verses in the chapter"""
  verses: [cvVerses]
  """A list of verse number and range information, organized by verse number"""
  verseNumbers: [verseNumber!]
  """A list of verse number and range information, organized by verse range"""
  verseRanges: [verseRange!]
}
`;
    var cvIndexResolvers = {
      chapter: (root) => root[0],
      verses: (root) => root[1],
      verseNumbers: (root, args, context) => {
        context.cvIndex = root;
        return [...root[1].entries()].filter((v) => v[1].length > 0).map((v) => ({
          number: v[0],
          range: v[1][v[1].length - 1].verses
        }));
      },
      verseRanges: (root) => {
        const ret = [];
        for (const [vn, vo] of [...root[1].entries()].filter((v) => v[1].length > 0)) {
          if (ret.length === 0 || ret[ret.length - 1].range !== vo[vo.length - 1].verses) {
            ret.push({
              range: vo[vo.length - 1].verses,
              numbers: [vn]
            });
          } else {
            ret[ret.length - 1].numbers.push(vn);
          }
        }
        return ret;
      }
    };
    module.exports = {
      cvIndexSchemaString,
      cvIndexResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvNavigation.cjs
var require_cvNavigation = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvNavigation.cjs"(exports, module) {
    init_process();
    init_buffer();
    var nv = (root, newVerseRange) => {
      const chapterN = parseInt(root[0]);
      const verseN = parseInt(root[1]);
      if (root[3].length <= verseN || root[3][verseN].length === 0) {
        return null;
      }
      let ret = null;
      let nc = chapterN;
      let nv2 = verseN;
      let index = root[3];
      let startVerseRange = index[verseN][0].verses;
      let onNextChapter = false;
      while (!ret) {
        nv2 += 1;
        if (nv2 >= index.length) {
          if (onNextChapter || !root[4]) {
            break;
          }
          nv2 = -1;
          nc += 1;
          index = root[4];
          onNextChapter = true;
        } else if (index[nv2].length > 0 && (!newVerseRange || onNextChapter || index[nv2][0].verses !== startVerseRange)) {
          ret = [nc, nv2];
        }
      }
      return ret;
    };
    var pv = (root, newVerseRange) => {
      const chapterN = parseInt(root[0]);
      const verseN = parseInt(root[1]);
      if (root[3].length <= verseN || root[3][verseN].length === 0) {
        return null;
      }
      let ret = null;
      let nc = chapterN;
      let nv2 = verseN;
      let index = root[3];
      let startVerseRange = index[verseN][0].verses;
      let onPreviousChapter = false;
      while (!ret) {
        nv2 -= 1;
        if (nv2 < 0) {
          if (onPreviousChapter || !root[2]) {
            break;
          }
          nv2 = root[2].length;
          nc -= 1;
          index = root[2];
          onPreviousChapter = true;
        } else if (index[nv2].length > 0 && (!newVerseRange || onPreviousChapter || index[nv2][0].verses !== startVerseRange)) {
          ret = [nc, nv2];
        }
      }
      return ret;
    };
    var cvNavigationSchemaString = `
"""Various answers to 'previous' and 'next' with respect to a verse"""
type cvNavigation {
  """The verse number for the next verse"""
  nextVerse: cv
  """The verse number for the previous verse"""
  previousVerse: cv
  """The verse number for the next verse range"""
  nextVerseRangeVerse: cv
  """The verse number for the previous verse range"""
  previousVerseRangeVerse: cv
  """The next chapter number (as a string)"""
  nextChapter: String
  """The previous chapter number (as a string)"""
  previousChapter: String
}
`;
    var cvNavigationResolvers = {
      nextVerse: (root) => nv(root, false),
      previousVerse: (root) => pv(root, false),
      nextVerseRangeVerse: (root) => nv(root, true),
      previousVerseRangeVerse: (root) => pv(root, true),
      nextChapter: (root) => {
        if (root[3].length > 0 && root[4].length > 0) {
          return (parseInt(root[0]) + 1).toString();
        } else {
          return null;
        }
      },
      previousChapter: (root) => {
        if (root[2].length > 0 && root[3].length > 0) {
          return (parseInt(root[0]) - 1).toString();
        } else {
          return null;
        }
      }
    };
    module.exports = {
      cvNavigationSchemaString,
      cvNavigationResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/inputBlockSpec.cjs
var require_inputBlockSpec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/inputBlockSpec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var inputBlockSpecSchemaString = `
"""A specification to create or update a block"""
input inputBlockSpec {
  """The block scope as an item"""
  bs: InputItemObject!
  """The block grafts as items"""
  bg: [InputItemObject!]!
  """The open scopes as items"""
  os: [InputItemObject!]!
  """The included scopes as items"""
  is: [InputItemObject!]!
  """The items"""
  items: [InputItemObject!]!
}
`;
    module.exports = { inputBlockSpecSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/queries/node.cjs
var require_node = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/node.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var nodeSchemaString = `
"""A tree node"""
type node {
  """The node id"""
  id: String!
  """The node parent id"""
  parentId: String
  """The keys for content"""
  keys: [String!]!
  """The content as itemGroups"""
  itemGroups(
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [ItemGroup!]!
  """The node children ids"""
  childIds: [String!]!
}
`;
    var nodeResolvers = {
      id: (root, args, context) => {
        const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(root.bs, 0);
        return context.docSet.unsuccinctifyScope(root.bs, itemType, itemSubtype, 0)[2].split("/")[1];
      },
      parentId: (root, args, context) => {
        const parentId = context.docSet.unsuccinctifyScopes(root.is).filter((s) => s[2].startsWith("tTreeParent"))[0][2].split("/")[1];
        return parentId === "none" ? null : parentId;
      },
      keys: (root, args, context) => context.docSet.unsuccinctifyScopes(root.is).filter((s) => s[2].startsWith("tTreeContent")).map((s) => s[2].split("/")[1]),
      itemGroups: (root, args, context) => context.docSet.sequenceItemsByScopes([root], ["tTreeContent/"], args.includeContext || false),
      childIds: (root, args, context) => context.docSet.unsuccinctifyScopes(root.is).filter((s) => s[2].startsWith("tTreeChild")).map((s) => s[2].split("/")[2])
    };
    module.exports = {
      nodeSchemaString,
      nodeResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/kv_sequence.cjs
var require_kv_sequence = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/kv_sequence.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var kvSequenceSchemaString = `
"""A contiguous flow of content for key-values"""
type kvSequence {
  """The id of the sequence"""
  id: String!
  """The number of entries in the key-value sequence"""
  nEntries: Int!
  """The entries in the key-value sequence"""
  entries(
    """Only return entries whose key matches the specification"""
    keyMatches: String
    """Only return entries whose key equals one of the values in the specification"""
    keyEquals: [String!]
    """Only return entries whose secondary keys match the specification"""
    secondaryMatches: [KeyMatches!]
    """Only return entries whose secondary keys equal one of the values in the specification"""
    secondaryEquals: [KeyValues!]
    """Only return entries whose content matches the specification"""
    contentMatches: [KeyMatches!]
    """Only return entries whose content equals one of the values in the specification"""
    contentEquals: [KeyValues!]
  ): [kvEntry!]
  """A list of the tags of this sequence"""
  tags: [String!]!
  """A list of the tags of this sequence as key/value tuples"""
  tagsKv: [KeyValue!]!
  """Whether or not the sequence has the specified tag"""
  hasTag(
    """The tag name"""
    tagName: String
  ): Boolean!
}
`;
    var kvSequenceResolvers = {
      nEntries: (root) => root.blocks.length,
      entries: (root, args, context) => {
        let ret = root.blocks.map(
          (b) => [
            context.docSet.unsuccinctifyScopes(b.bs).map((s) => s[2].split("/")[1])[0],
            context.docSet.unsuccinctifyScopes(b.is).filter((s) => s[2].startsWith("kvSecondary/")).map((s) => [s[2].split("/")[1], s[2].split("/")[2]]),
            context.docSet.sequenceItemsByScopes([b], ["kvField/"], false)
          ]
        );
        if (args.keyMatches) {
          ret = ret.filter((e) => xre.test(e[0], xre(args.keyMatches)));
        }
        if (args.keyEquals) {
          ret = ret.filter((e) => args.keyEquals.includes(e[0]));
        }
        if (args.secondaryMatches) {
          const matchesOb = {};
          args.secondaryMatches.forEach((sm) => matchesOb[sm.key] = sm.matches);
          ret = ret.filter(
            (e) => {
              const secondaryOb = {};
              e[1].forEach((st) => secondaryOb[st[0]] = st[1]);
              for (const mo of Object.entries(matchesOb)) {
                const secondaryString = secondaryOb[mo[0]];
                if (!secondaryString || !xre.test(secondaryString, xre(mo[1]))) {
                  return false;
                }
              }
              return true;
            }
          );
        }
        if (args.secondaryEquals) {
          const equalsOb = {};
          args.secondaryEquals.forEach((sm) => equalsOb[sm.key] = sm.values);
          ret = ret.filter(
            (e) => {
              const secondaryOb = {};
              e[1].forEach((st) => secondaryOb[st[0]] = st[1]);
              for (const mo of Object.entries(equalsOb)) {
                const secondaryString = secondaryOb[mo[0]];
                if (!secondaryString || !mo[1].includes(secondaryString)) {
                  return false;
                }
              }
              return true;
            }
          );
        }
        if (args.contentMatches) {
          const matchesOb = {};
          args.contentMatches.forEach((sm) => matchesOb[sm.key] = sm.matches);
          ret = ret.filter(
            (e) => {
              const contentOb = {};
              e[2].forEach((st) => contentOb[st[0].filter((s) => s.startsWith("kvField"))[0].split("/")[1]] = st[1].filter((i) => i[0] === "token").map((t) => t[2]).join(""));
              for (const mo of Object.entries(matchesOb)) {
                const contentString = contentOb[mo[0]];
                if (!contentString || !xre.test(contentString, xre(mo[1]))) {
                  return false;
                }
              }
              return true;
            }
          );
        }
        if (args.contentEquals) {
          const equalsOb = {};
          args.contentEquals.forEach((sm) => equalsOb[sm.key] = sm.values);
          ret = ret.filter(
            (e) => {
              const contentOb = {};
              e[2].forEach((st) => contentOb[st[0].filter((s) => s.startsWith("kvField"))[0].split("/")[1]] = st[1].filter((i) => i[0] === "token").map((t) => t[2]).join(""));
              for (const mo of Object.entries(equalsOb)) {
                const contentString = contentOb[mo[0]];
                if (!contentString || !contentString.includes(mo[1])) {
                  return false;
                }
              }
              return true;
            }
          );
        }
        return ret;
      },
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName)
    };
    module.exports = {
      kvSequenceSchemaString,
      kvSequenceResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/table_sequence.cjs
var require_table_sequence = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/table_sequence.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var utils = require_util();
    var tableSequenceSchemaString = `
"""A contiguous flow of content for a table"""
type tableSequence {
  """The id of the sequence"""
  id: String!
  """The number of cells in the table sequence"""
  nCells: Int!
  """The number of rows in the table sequence"""
  nRows: Int!
  """The number of columns in the table sequence"""
  nColumns: Int!
  """The cells in the table sequence"""
  cells: [cell!]!
  """The rows in the table sequence"""
  rows(
    """Only return rows whose zero-indexed position is in the list"""
    positions: [Int!]
    """Only return columns whose zero-indexed position is in the list"""
    columns: [Int!]
    """Only return rows whose cells match the specification"""
    matches: [rowMatchSpec!]
    """'Only return rows whose cells contain one of the values in the specification"""
    equals: [rowEqualsSpec!]
  ): [[cell!]!]!
  """A list of the tags of this sequence"""
  tags: [String!]!
  """A list of the tags of this sequence as key/value tuples"""
  tagsKv: [KeyValue!]!
  """Whether or not the sequence has the specified tag"""
  hasTag(
    """The tag name"""
    tagName: String
  ): Boolean!
  """A list of column headings for this tableSequence, derived from the sequence tags"""
  headings: [String!]!
}
`;
    var tableSequenceResolvers = {
      nCells: (root) => root.blocks.length,
      nRows: (root, args, context) => {
        const rowNs = /* @__PURE__ */ new Set([]);
        for (const block2 of root.blocks) {
          const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(block2.bs, 0);
          const bsPayload = context.docSet.unsuccinctifyScope(block2.bs, itemType, itemSubtype, 0)[2];
          rowNs.add(bsPayload.split("/")[1]);
        }
        return rowNs.size;
      },
      nColumns: (root, args, context) => {
        const columnNs = /* @__PURE__ */ new Set([]);
        for (const block2 of root.blocks) {
          for (const scope of context.docSet.unsuccinctifyScopes(block2.is).map((s) => s[2])) {
            if (scope.startsWith("tTableCol")) {
              columnNs.add(scope.split("/")[1]);
            }
          }
        }
        return columnNs.size;
      },
      cells: (root, args, context) => {
        const ret = [];
        for (const block2 of root.blocks) {
          ret.push([
            context.docSet.unsuccinctifyScopes(block2.bs).map((s) => parseInt(s[2].split("/")[1])),
            Array.from(new Set(
              context.docSet.unsuccinctifyScopes(block2.is).filter((s) => s[2].startsWith("tTableCol")).map((s) => parseInt(s[2].split("/")[1]))
            )),
            context.docSet.unsuccinctifyItems(block2.c, {}, 0)
          ]);
        }
        return ret;
      },
      rows: (root, args, context) => {
        const rowMatches1 = (row2, matchSpec) => {
          if (row2[matchSpec.colN] === void 0) {
            return false;
          }
          const matchCellText = row2[matchSpec.colN][2].filter((i) => i[0] === "token").map((i) => i[2]).join("");
          return xre.test(matchCellText, xre(matchSpec.matching));
        };
        const rowMatches = (row2, matchSpecs) => {
          if (matchSpecs.length === 0) {
            return true;
          }
          if (rowMatches1(row2, matchSpecs[0])) {
            return rowMatches(row2, matchSpecs.slice(1));
          }
          return false;
        };
        const rowEquals1 = (row2, matchSpec) => {
          if (row2[matchSpec.colN] === void 0) {
            return false;
          }
          const matchCellText = row2[matchSpec.colN][2].filter((i) => i[0] === "token").map((i) => i[2]).join("");
          return matchSpec.values.includes(matchCellText);
        };
        const rowEquals = (row2, matchSpecs) => {
          if (matchSpecs.length === 0) {
            return true;
          }
          if (rowEquals1(row2, matchSpecs[0])) {
            return rowEquals(row2, matchSpecs.slice(1));
          }
          return false;
        };
        let ret = [];
        let row = -1;
        for (const block2 of root.blocks) {
          const rows = context.docSet.unsuccinctifyScopes(block2.bs).map((s) => parseInt(s[2].split("/")[1]));
          if (args.positions && !args.positions.includes(rows[0])) {
            continue;
          }
          if (rows[0] !== row) {
            ret.push([]);
            row = rows[0];
          }
          ret[ret.length - 1].push([
            rows,
            Array.from(new Set(
              context.docSet.unsuccinctifyScopes(block2.is).filter((s) => s[2].startsWith("tTableCol")).map((s) => parseInt(s[2].split("/")[1]))
            )),
            context.docSet.unsuccinctifyItems(block2.c, {}, 0)
          ]);
        }
        if (args.matches) {
          ret = ret.filter((row2) => rowMatches(row2, args.matches));
        }
        if (args.equals) {
          ret = ret.filter((row2) => rowEquals(row2, args.equals));
        }
        if (args.columns) {
          ret = ret.map(
            (row2) => [...row2.entries()].filter((re) => args.columns.includes(re[0])).map((re) => re[1])
          );
        }
        return ret;
      },
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName),
      headings: (root) => Array.from(root.tags).filter((t) => t.startsWith("col")).sort((a, b) => parseInt(a.split(":")[0].substring(3)) - parseInt(b.split(":")[0].substring(3))).map((t) => t.split(":")[1])
    };
    module.exports = {
      tableSequenceSchemaString,
      tableSequenceResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/lib/tribos_expression.cjs
var require_tribos_expression = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/tribos_expression.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var aggregateFunctions = {
      equals: (docSet, node, a, b) => a === b,
      notEqual: (docSet, node, a, b) => a !== b,
      and: (docSet, node, ...args) => args.filter((a) => !a).length === 0,
      or: (docSet, node, ...args) => args.filter((a) => a).length > 0,
      not: (docSet, node, a) => !a,
      idRef: (docSet, node) => docSet.unsuccinctifyScopes(node.bs)[0][2].split("/")[1],
      parentIdRef: (docSet, node) => docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeParent"))[0][2].split("/")[1],
      nChildren: (docSet, node) => docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeChild")).length,
      contentRef: (docSet, node, label) => {
        const labelIG = docSet.sequenceItemsByScopes([node], ["tTreeContent/"], false).filter((ig) => {
          const key = ig[0].filter((s) => s.startsWith("tTreeContent"))[0].split("/")[1];
          return key === label;
        });
        return labelIG[0] ? labelIG[0][1].filter((i) => i[0] === "token").map((t) => t[2]).join("") : "";
      },
      hasContent: (docSet, node, label) => {
        const labelIG = docSet.sequenceItemsByScopes([node], ["tTreeContent/"], false).filter((ig) => {
          const key = ig[0].filter((s) => s.startsWith("tTreeContent"))[0].split("/")[1];
          return key === label;
        });
        return labelIG.length > 0;
      },
      concat: (docSet, node, ...args) => args.join(""),
      startsWith: (docSet, node, a, b) => a.startsWith(b),
      endsWith: (docSet, node, a, b) => a.endsWith(b),
      contains: (docSet, node, a, b) => a.includes(b),
      matches: (docSet, node, a, b) => xre.test(a, xre(b)),
      int: (docSet, node, str) => parseInt(str),
      string: (docSet, node, int) => `${int}`,
      left: (docSet, node, str, int) => str.substring(0, int),
      right: (docSet, node, str, int) => str.substring(str.length - int),
      length: (docSet, node, str) => str.length,
      indexOf: (docSet, node, a, b) => a.indexOf(b),
      add: (docSet, node, ...args) => args.reduce((x, y) => x + y),
      mul: (docSet, node, ...args) => args.reduce((x, y) => x * y),
      sub: (docSet, node, a, b) => a - b,
      div: (docSet, node, a, b) => Math.floor(a / b),
      mod: (docSet, node, a, b) => a % b,
      gt: (docSet, node, a, b) => a > b,
      lt: (docSet, node, a, b) => a < b,
      ge: (docSet, node, a, b) => a >= b,
      le: (docSet, node, a, b) => a <= b
    };
    var parseFunctions = {
      quotedString: (str) => str.substring(1, str.length - 1),
      int: (str) => parseInt(str),
      true: () => true,
      false: () => false
    };
    var splitArgs = (str) => {
      const ret = [[]];
      let pos = 0;
      let nParen = 0;
      let inQuote = false;
      while (str && pos < str.length) {
        switch (str[pos]) {
          case "\\":
            ret[ret.length - 1].push(str[pos]);
            if (str[pos + 1] === "'") {
              ret[ret.length - 1].push(str[pos + 1]);
              pos++;
            }
            break;
          case "'":
            ret[ret.length - 1].push(str[pos]);
            inQuote = !inQuote;
            break;
          case "(":
            if (inQuote) {
              ret[ret.length - 1].push(str[pos]);
            } else {
              ret[ret.length - 1].push(str[pos]);
              nParen++;
            }
            break;
          case ")":
            if (inQuote) {
              ret[ret.length - 1].push(str[pos]);
            } else {
              ret[ret.length - 1].push(str[pos]);
              nParen--;
            }
            break;
          case ",":
            if (!inQuote && nParen === 0) {
              ret.push([]);
              while (str[pos + 1] === " ") {
                pos++;
              }
            } else {
              ret[ret.length - 1].push(str[pos]);
            }
            break;
          default:
            ret[ret.length - 1].push(str[pos]);
        }
        pos++;
      }
      return ret.map((e) => e.join(""));
    };
    var expressions = {
      expression: { oneOf: ["stringExpression", "intExpression", "booleanExpression"] },
      booleanExpression: { oneOf: ["booleanPrimitive", "equals", "notEqual", "and", "or", "not", "contains", "startsWith", "endsWith", "matches", "gt", "lt", "ge", "le", "hasContent"] },
      stringExpression: { oneOf: ["concat", "left", "right", "string", "idRef", "parentIdRef", "contentRef", "stringPrimitive"] },
      intExpression: { oneOf: ["length", "indexOf", "int", "nChildren", "intPrimitive", "add", "sub", "mul", "div", "mod"] },
      equals: {
        regex: xre("^==\\((.+)\\)$"),
        doc: {
          operator: "==",
          args: ["expression", "expression"],
          result: "boolean",
          description: "Are the arguments strictly equal?"
        },
        argStructure: [["expression", [2, 2]]]
      },
      notEqual: {
        regex: xre("^!=\\((.+)\\)$"),
        doc: {
          operator: "!=",
          args: ["expression", "expression"],
          result: "boolean",
          description: "Are the arguments not strictly equal?"
        },
        argStructure: [["expression", [2, 2]]]
      },
      and: {
        regex: xre("^and\\((.+)\\)$"),
        doc: {
          operator: "and",
          args: ["boolean", "boolean", "..."],
          result: "boolean",
          description: "Are all the arguments true?"
        },
        breakOn: false,
        argStructure: [["booleanExpression", [2, null]]]
      },
      or: {
        regex: xre("^or\\((.+)\\)$"),
        doc: {
          operator: "or",
          args: ["boolean", "boolean"],
          result: "boolean",
          description: "Are any arguments true?"
        },
        breakOn: true,
        argStructure: [["booleanExpression", [2, null]]]
      },
      concat: {
        regex: xre("^concat\\((.+)\\)$"),
        doc: {
          operator: "concat",
          args: ["string", "string", "..."],
          result: "string",
          description: "Concatenates string arguments"
        },
        argStructure: [["stringExpression", [2, null]]]
      },
      contentRef: {
        regex: xre("^content\\((.+)\\)$"),
        doc: {
          operator: "content",
          args: ["string"],
          result: "string",
          description: "String value of the specified content for the node"
        },
        argStructure: [["stringExpression", [1, 1]]]
      },
      hasContent: {
        regex: xre("^hasContent\\((.+)\\)$"),
        doc: {
          operator: "hasContent",
          args: ["string"],
          result: "boolean",
          description: "Does the node have this content?"
        },
        argStructure: [["stringExpression", [1, 1]]]
      },
      contains: {
        regex: xre("^contains\\((.+)\\)$"),
        doc: {
          operator: "contains",
          args: ["string", "string"],
          result: "boolean",
          description: "Does the first string contain the second string?"
        },
        argStructure: [["stringExpression", [2, 2]]]
      },
      startsWith: {
        regex: xre("^startsWith\\((.+)\\)$"),
        doc: {
          operator: "startsWith",
          args: ["string", "string"],
          result: "boolean",
          description: "Does the first string start with the second string?"
        },
        argStructure: [["stringExpression", [2, 2]]]
      },
      endsWith: {
        regex: xre("^endsWith\\((.+)\\)$"),
        doc: {
          operator: "endsWith",
          args: ["string", "string"],
          result: "boolean",
          description: "Does the first string end with the second string?"
        },
        argStructure: [["stringExpression", [2, 2]]]
      },
      matches: {
        regex: xre("^matches\\((.+)\\)$"),
        doc: {
          operator: "matches",
          args: ["string", "regex"],
          result: "boolean",
          description: "Does the first string match the regex in the second string?"
        },
        argStructure: [["stringExpression", [2, 2]]]
      },
      left: {
        regex: xre("^left\\((.+)\\)$"),
        doc: {
          operator: "left",
          args: ["string", "integer"],
          result: "string",
          description: "The first n characters of the string"
        },
        argStructure: [["stringExpression", [1, 1]], ["intExpression", [1, 1]]]
      },
      right: {
        regex: xre("^right\\((.+)\\)$"),
        doc: {
          operator: "right",
          args: ["string", "integer"],
          result: "string",
          description: "The last n characters of the string"
        },
        argStructure: [["stringExpression", [1, 1]], ["intExpression", [1, 1]]]
      },
      length: {
        regex: xre("^length\\((.+)\\)$"),
        doc: {
          operator: "length",
          args: ["string"],
          result: "integer",
          description: "The number of characters in the string"
        },
        argStructure: [["stringExpression", [1, 1]]]
      },
      indexOf: {
        regex: xre("^indexOf\\((.+)\\)$"),
        doc: {
          operator: "indexOf",
          args: ["string", "string"],
          result: "number",
          description: "The integer position at which the second string starts in the first string"
        },
        argStructure: [["stringExpression", [2, 2]]]
      },
      not: {
        regex: xre("^not\\((.+)\\)$"),
        doc: {
          operator: "not",
          args: ["boolean"],
          result: "boolean",
          description: "The inverse boolean value of the argument"
        },
        argStructure: [["booleanExpression", [1, 1]]]
      },
      int: {
        regex: xre("^int\\((.+)\\)$"),
        doc: {
          operator: "int",
          args: ["string"],
          result: "integer",
          description: "The integer value of the string"
        },
        argStructure: [["stringExpression", [1, 1]]]
      },
      string: {
        regex: xre("^string\\((.+)\\)$"),
        doc: {
          operator: "string",
          args: ["integer"],
          result: "string",
          description: "The string value of the integer"
        },
        argStructure: [["intExpression", [1, 1]]]
      },
      idRef: {
        regex: xre("^id$"),
        doc: {
          operator: "id",
          args: [],
          result: "string",
          description: "The node ID"
        },
        argStructure: []
      },
      parentIdRef: {
        regex: xre("^parentId$"),
        doc: {
          operator: "parentId",
          args: [],
          result: "string",
          description: "The node's parent ID"
        },
        argStructure: []
      },
      nChildren: {
        regex: xre("^nChildren$"),
        doc: {
          operator: "nChildren",
          args: [],
          result: "int",
          description: "The number of children of the node"
        },
        argStructure: []
      },
      add: {
        regex: xre("^add\\((.+)\\)$"),
        doc: {
          operator: "add",
          args: ["integer", "..."],
          result: "integer",
          description: "The numeric sum of the arguments"
        },
        argStructure: [["intExpression", [2, null]]]
      },
      mul: {
        regex: xre("^mul\\((.+)\\)$"),
        doc: {
          operator: "mul",
          args: ["integer", "..."],
          result: "integer",
          description: "The numeric product of the arguments"
        },
        argStructure: [["intExpression", [2, null]]]
      },
      sub: {
        regex: xre("^sub\\((.+)\\)$"),
        doc: {
          operator: "sub",
          args: ["integer", "integer"],
          result: "integer",
          description: "The first integer minus the second"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      div: {
        regex: xre("^div\\((.+)\\)$"),
        doc: {
          operator: "div",
          args: ["integer", "integer"],
          result: "integer",
          description: "The first integer divided by the second"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      mod: {
        regex: xre("^mod\\((.+)\\)$"),
        doc: {
          operator: "mod",
          args: ["integer", "integer"],
          result: "integer",
          description: "The modulus of the first integer when divided by the second"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      gt: {
        regex: xre("^>\\((.+)\\)$"),
        doc: {
          operator: ">",
          args: ["integer", "integer"],
          result: "boolean",
          description: "Is the first integer numerically greater than the second?"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      lt: {
        regex: xre("^<\\((.+)\\)$"),
        doc: {
          operator: "<",
          args: ["integer", "integer"],
          result: "boolean",
          description: "Is the first integer numerically less than the second?"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      ge: {
        regex: xre("^>=\\((.+)\\)$"),
        doc: {
          operator: ">=",
          args: ["integer", "integer"],
          result: "boolean",
          description: "Is the first integer numerically greater than or equal to the second?"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      le: {
        regex: xre("^<=\\((.+)\\)$"),
        doc: {
          operator: "<=",
          args: ["integer", "integer"],
          result: "boolean",
          description: "Is the first integer numerically less than or equal to the second?"
        },
        argStructure: [["intExpression", [2, 2]]]
      },
      stringPrimitive: {
        regex: xre("^('([^']|\\\\')*')$"),
        parseFunctions: [null, "quotedString"]
      },
      intPrimitive: {
        regex: xre("^(-?[0-9]+)$"),
        parseFunctions: [null, "int"]
      },
      booleanPrimitive: {
        regex: xre("^(true)|(false)$"),
        parseFunctions: [null, "true", "false"]
      }
    };
    var parseRegexExpression = (docSet, node, predicateString, expressionId, matches) => {
      const expressionRecord = expressions[expressionId];
      if (!expressionRecord) {
        throw new Error(`Unknown expression ${expressionId} for predicate ${predicateString}`);
      }
      const nExpectedArgs = (structure) => [
        structure.map((a) => a[1][0]).reduce((a, b) => a + b),
        structure.filter((a) => a[1][1] === null).length > 0
      ];
      if (expressionRecord.parseFunctions) {
        let found = false;
        for (const [n, parseFunction] of expressionRecord.parseFunctions.entries()) {
          if (!parseFunction || !matches[n]) {
            continue;
          }
          found = true;
          return { data: parseFunctions[parseFunction](matches[n]) };
        }
        if (!found) {
          return { errors: `Could not parse predicate ${predicateString}` };
        }
      } else {
        const argRecords = splitArgs(matches[1]);
        const argStructure = expressionRecord.argStructure;
        const argResults = [];
        if (argStructure.length > 0) {
          const nExpected = nExpectedArgs(argStructure);
          if (argRecords.length < nExpected[0]) {
            return { errors: `Expected at least ${nExpected[0]} args for '${expressionId}', found ${argRecords.length}` };
          }
          if (!nExpected[1] && argRecords.length > nExpected[0]) {
            return { errors: `Expected at most ${nExpected[0]} args for '${expressionId}', found ${argRecords.length}` };
          }
          let argRecordN = 0;
          let argStructureN = 0;
          let nOccs = 0;
          while (argRecordN < argRecords.length) {
            const argRecord = argRecords[argRecordN];
            const argResult = parseExpression(docSet, node, argRecord, argStructure[argStructureN][0]);
            if ("breakOn" in expressionRecord && !argRecord.errors && argResult.data === expressionRecord.breakOn) {
              return argResult;
            }
            argResults.push(argResult);
            argRecordN++;
            nOccs++;
            if (argStructure[argStructureN][1][1] && nOccs >= argStructure[argStructureN][1][1]) {
              argStructureN++;
              nOccs = 0;
            }
          }
        }
        if (argResults.filter((ar) => ar.errors).length === 0) {
          const args = argResults.map((ar) => ar.data);
          const aggregated = aggregateFunctions[expressionId](docSet, node, ...args);
          return { data: aggregated };
        }
        return { errors: `Could not parse arguments to ${expressionId}: ${argRecords.filter((ar) => ar.errors).map((ar) => ar.errors).join("; ")}` };
      }
    };
    var parseExpression = (docSet, node, predicate, expressionId) => {
      const expressionRecord = expressions[expressionId];
      if (!expressionRecord) {
        throw new Error(`Unknown expression ${expressionId} for predicate ${predicate}`);
      }
      if (expressionRecord.oneOf) {
        let errors = null;
        for (const option of expressionRecord.oneOf) {
          const optionResult = parseExpression(docSet, node, predicate, option);
          if (!optionResult.errors) {
            return optionResult;
          } else if (!errors || optionResult.errors.length < errors.length) {
            errors = optionResult.errors;
          }
        }
        return { errors };
      } else {
        const matches = xre.exec(predicate, expressionRecord.regex);
        if (matches) {
          const reResult = parseRegexExpression(docSet, node, predicate, expressionId, matches);
          return reResult;
        } else {
          return { errors: `Could not match ${predicate}` };
        }
      }
    };
    var doPredicate = (docSet, result, predicateString) => ({
      data: result.data.filter((node) => {
        const nodeResult = parseExpression(docSet, node, predicateString, "booleanExpression");
        if (nodeResult.errors) {
          throw new Error(`Predicate - ${nodeResult.errors}`);
        }
        return nodeResult.data;
      })
    });
    module.exports = { expressions, doPredicate };
  }
});

// node_modules/proskomma-core/src/graph/lib/tribos_step.cjs
var require_tribos_step = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/tribos_step.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var predicateRegex = "(\\[(([^\\]']|'([^']|\\\\')*')+)\\])*";
    var doAbsoluteIdStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const values = matches[1].split(",").map((v) => v.trim());
      return { data: Array.from(values).map((nid) => allNodes[nodeLookup.get(nid)]) };
    };
    var doAbsoluteRootStep = (docSet, allNodes) => ({ data: [allNodes[0]] });
    var doAbsoluteNodesStep = (docSet, allNodes) => ({ data: allNodes });
    var doChildrenStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const childNo = matches[2];
      const childNodeIds = /* @__PURE__ */ new Set([]);
      for (const parentNode of result.data) {
        const children = docSet.unsuccinctifyScopes(parentNode.is).map((s) => s[2].split("/")).filter((s) => s[0] === "tTreeChild").filter((s) => !childNo || s[1] === childNo).map((s) => s[2]);
        for (const child of children) {
          childNodeIds.add(child);
        }
      }
      return { data: Array.from(childNodeIds).map((nid) => allNodes[nodeLookup.get(nid)]) };
    };
    var doParentStep = (docSet, allNodes, nodeLookup, result) => {
      const parentNodeIds = /* @__PURE__ */ new Set([]);
      for (const childNode of result.data) {
        const parentId = docSet.unsuccinctifyScopes(childNode.is).filter((s) => s[2].startsWith("tTreeParent")).map((s) => s[2].split("/")[1])[0];
        parentNodeIds.add(parentId);
      }
      return { data: Array.from(parentNodeIds).map((nid) => allNodes[nodeLookup.get(nid)]) };
    };
    var doAncestorStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      let ancestorNo = parseInt(matches[2]);
      if (ancestorNo < 1) {
        return { errors: `Expected a positive integer argument for ancestor, found ${queryStep}` };
      }
      let nodes = result.data;
      while (ancestorNo > 0) {
        const parentNodeIds = /* @__PURE__ */ new Set([]);
        for (const childNode of nodes) {
          const parentId = docSet.unsuccinctifyScopes(childNode.is).filter((s) => s[2].startsWith("tTreeParent")).map((s) => s[2].split("/")[1])[0];
          parentNodeIds.add(parentId);
        }
        nodes = Array.from(parentNodeIds).map((nid) => allNodes[nodeLookup.get(nid)]);
        ancestorNo--;
      }
      return { data: nodes };
    };
    var doDescendantsStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const descendantIds = /* @__PURE__ */ new Set([]);
      const getDescendants = (node, depth) => {
        const childIds = docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeChild")).map((s) => s[2].split("/")[2]);
        if (depth <= 1 || depth === null) {
          childIds.forEach((n) => descendantIds.add(n));
        }
        if (depth === null || depth > 1) {
          childIds.map((nid) => allNodes[nodeLookup.get(nid)]).forEach((n) => getDescendants(n, depth - 1));
        }
      };
      let descendantGen = null;
      if (matches[3]) {
        descendantGen = parseInt(matches[3]);
      }
      let descendantNo = -1;
      if (matches[5]) {
        descendantNo = parseInt(matches[5]);
      }
      for (const node of result.data) {
        getDescendants(node, descendantGen);
      }
      return {
        data: [...Array.from(descendantIds).entries()].filter((n) => descendantNo < 0 || n[0] === descendantNo).map((n) => n[1]).map((nid) => allNodes[nodeLookup.get(nid)])
      };
    };
    var doLeavesStep = (docSet, allNodes, nodeLookup, result) => {
      const leafIds = /* @__PURE__ */ new Set([]);
      const getLeaves = (node) => {
        const childIds = docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeChild")).map((s) => s[2].split("/")[2]);
        if (childIds.length === 0) {
          leafIds.add(docSet.unsuccinctifyScopes(node.bs)[0][2].split("/")[1]);
        } else {
          childIds.map((nid) => allNodes[nodeLookup.get(nid)]).forEach((n) => getLeaves(n));
        }
      };
      for (const node of result.data) {
        getLeaves(node);
      }
      return { data: Array.from(leafIds).map((nid) => allNodes[nodeLookup.get(nid)]) };
    };
    var doSiblingsStep = (docSet, allNodes, nodeLookup, result) => {
      const parentNodeIds = /* @__PURE__ */ new Set([]);
      for (const childNode of result.data) {
        const parentId = docSet.unsuccinctifyScopes(childNode.is).filter((s) => s[2].startsWith("tTreeParent")).map((s) => s[2].split("/")[1])[0];
        parentNodeIds.add(parentId);
      }
      const parentNodes = allNodes.filter((n) => parentNodeIds.has(docSet.unsuccinctifyScopes(n.bs)[0][2].split("/")[1]));
      const childNodeIds = /* @__PURE__ */ new Set([]);
      for (const parentNode of parentNodes) {
        const children = docSet.unsuccinctifyScopes(parentNode.is).filter((s) => s[2].startsWith("tTreeChild")).map((s) => s[2].split("/")[2]);
        for (const child of children) {
          childNodeIds.add(child);
        }
      }
      return { data: Array.from(childNodeIds).map((nid) => allNodes[nodeLookup.get(nid)]) };
    };
    var nodeDetails = (docSet, node, allNodes, nodeLookup, fields, isBranch) => {
      const record = {};
      if (fields.size === 0 || fields.has("id")) {
        record.id = docSet.unsuccinctifyScopes(node.bs)[0][2].split("/")[1];
      }
      if (fields.size === 0 || fields.has("parentId")) {
        record.parentId = docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeParent")).map((s) => s[2].split("/")[1])[0];
      }
      const content = {};
      for (const [scopeLabels, items] of docSet.sequenceItemsByScopes([node], ["tTreeContent/"], false)) {
        const key = scopeLabels.filter((s) => s.startsWith("tTreeContent"))[0].split("/")[1];
        if (fields.size === 0 || fields.has("content") || fields.has(`@${key}`)) {
          content[key] = items.filter((i) => i[0] === "token").map((t) => t[2]).join("");
        }
      }
      if (Object.keys(content).length > 0) {
        record.content = content;
      }
      const children = [];
      if (fields.has("children")) {
        for (const childScope of docSet.unsuccinctifyScopes(node.is).filter((s) => s[2].startsWith("tTreeChild")).map((s) => s[2].split("/")[2])) {
          children.push(childScope);
        }
      }
      if (children.length > 0) {
        if (isBranch) {
          record.children = children.map((nid) => allNodes[nodeLookup.get(nid)]).map((n) => nodeDetails(docSet, n, allNodes, nodeLookup, fields, true));
        } else {
          record.children = children;
        }
      }
      return record;
    };
    var doBranchStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const ret = [];
      let fields = /* @__PURE__ */ new Set([]);
      if (matches[2]) {
        fields = new Set(
          matches[2].split(",").map((f) => f.trim())
        );
      }
      for (const node of result.data) {
        ret.push(nodeDetails(docSet, node, allNodes, nodeLookup, fields, true));
      }
      return { data: ret };
    };
    var doValuesStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const nodeFields = [];
      let fields = /* @__PURE__ */ new Set([]);
      if (matches[2]) {
        fields = new Set(
          matches[2].split(",").map((f) => f.trim()).filter((f) => f.startsWith("@"))
        );
      }
      for (const node of result.data) {
        nodeFields.push(nodeDetails(docSet, node, allNodes, nodeLookup, fields, true));
      }
      const values = {};
      for (const field of Array.from(fields).map((f) => f.substring(1))) {
        values[field] = Array.from(
          new Set(
            nodeFields.filter((nd) => nd.content).map((nd) => nd.content).filter((nd) => field in nd).map((nd) => nd[field]).sort()
          )
        );
      }
      return { data: values };
    };
    var doNodeStep = (docSet, allNodes, nodeLookup, result, queryStep, matches) => {
      const ret = [];
      let fields = /* @__PURE__ */ new Set([]);
      if (matches[2]) {
        fields = new Set(matches[2].split(",").map((f) => f.trim()));
      }
      for (const node of result.data) {
        ret.push(nodeDetails(docSet, node, allNodes, nodeLookup, fields, false));
      }
      return { data: ret };
    };
    var stepActions = [
      {
        regex: xre(`^#\\{([^}]+)\\}${predicateRegex}$`),
        doc: {
          title: "Nodes by Id",
          syntax: "#(id, id, ...)",
          description: "Returns nodes whose id is listed"
        },
        predicateCapture: 3,
        inputType: null,
        outputType: "nodes",
        function: doAbsoluteIdStep
      },
      {
        regex: xre(`^root${predicateRegex}$`),
        doc: {
          title: "Root Node",
          syntax: "root",
          description: "Returns the root node"
        },
        predicateCapture: 2,
        inputType: null,
        outputType: "nodes",
        function: doAbsoluteRootStep
      },
      {
        regex: xre(`^nodes${predicateRegex}$`),
        doc: {
          title: "Nodes",
          syntax: "nodes",
          description: "Returns all the nodes"
        },
        predicateCapture: 2,
        function: doAbsoluteNodesStep,
        inputType: null,
        outputType: "nodes"
      },
      {
        regex: xre(`^children(\\((\\d+)\\))?${predicateRegex}$`),
        doc: {
          title: "Children",
          syntax: "children; children(pos)",
          description: "Returns the children of the current node(s), optionally filtered by position within the parent node"
        },
        predicateCapture: 4,
        inputType: "nodes",
        outputType: "nodes",
        function: doChildrenStep
      },
      {
        regex: xre(`^descendants((\\((\\d+)(,\\s*(\\d+))?\\))?)${predicateRegex}$`),
        doc: {
          title: "Descendants",
          syntax: "descendants; descendants(depth); descendants(depth, pos)",
          description: "Returns the descendants of the current node(s), optionally at the specified level, optionally filtered by position"
        },
        predicateCapture: 7,
        inputType: "nodes",
        outputType: "nodes",
        function: doDescendantsStep
      },
      {
        regex: xre(`^leaves${predicateRegex}$`),
        doc: {
          title: "Leaves",
          syntax: "leaves",
          description: "Returns the leaves (ie the nodes with no children) below the current node"
        },
        predicateCapture: 2,
        inputType: "nodes",
        outputType: "nodes",
        function: doLeavesStep
      },
      {
        regex: xre(`^parent${predicateRegex}$`),
        doc: {
          title: "Parent",
          syntax: "parent",
          description: "Returns the parent of the current node"
        },
        predicateCapture: 2,
        inputType: "nodes",
        outputType: "nodes",
        function: doParentStep
      },
      {
        regex: xre(`^ancestor(\\((\\d+)\\))${predicateRegex}$`),
        doc: {
          title: "Ancestor",
          syntax: "ancestor(depth)",
          description: "Returns the nth ancestor of the node"
        },
        predicateCapture: 5,
        inputType: "nodes",
        outputType: "nodes",
        function: doAncestorStep
      },
      {
        regex: xre(`^siblings${predicateRegex}$`),
        doc: {
          title: "Siblings",
          syntax: "siblings",
          description: "Returns the children of the parent of the current node"
        },
        predicateCapture: 2,
        inputType: "nodes",
        outputType: "nodes",
        function: doSiblingsStep
      },
      {
        regex: xre(`^node(\\{([^}]+)\\})?${predicateRegex}$`),
        doc: {
          title: "Node Details",
          syntax: "node; node{ id, parentId, content, children, @foo }",
          description: "Returns an object containing the specified content"
        },
        predicateCapture: 4,
        inputType: "nodes",
        outputType: "node",
        function: doNodeStep
      },
      {
        regex: xre(`^branch(\\{([^}]+)\\})?${predicateRegex}$`),
        doc: {
          title: "Branch",
          syntax: "branch; branch{ id, parentId, content, children, @foo }",
          description: "Returns nested objects containing the specified content"
        },
        predicateCapture: 4,
        inputType: "nodes",
        outputType: "node",
        function: doBranchStep
      },
      {
        regex: xre(`^values(\\{([^}]+)\\})?${predicateRegex}$`),
        doc: {
          title: "Values",
          syntax: "values{ @foo ... }",
          description: "Returns all values across nodes for the specified fields"
        },
        predicateCapture: 4,
        inputType: "nodes",
        outputType: "values",
        function: doValuesStep
      }
    ];
    module.exports = { stepActions };
  }
});

// node_modules/proskomma-core/src/graph/lib/tribos.cjs
var require_tribos = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/tribos.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var { expressions, doPredicate } = require_tribos_expression();
    var { stepActions } = require_tribos_step();
    var Tribos = class {
      constructor() {
        this.currentStepType = null;
      }
      doStep(docSet, allNodes, nodeLookup, result, queryStep) {
        for (const stepAction of stepActions) {
          const matches = xre.exec(queryStep, stepAction.regex);
          if (matches && stepAction.inputType === this.currentStepType) {
            let ret = stepAction.function(docSet, allNodes, nodeLookup, result, queryStep, matches);
            if (matches[stepAction.predicateCapture]) {
              ret = doPredicate(docSet, ret, matches[stepAction.predicateCapture]);
            }
            this.currentStepType = stepAction.outputType;
            return ret;
          }
        }
        return { errors: `Unable to match step ${queryStep}` };
      }
      parse1(docSet, allNodes, nodeLookup, result, queryArray) {
        if (queryArray.length > 0) {
          const stepResult = this.doStep(docSet, allNodes, nodeLookup, result, queryArray[0]);
          if (stepResult.errors || stepResult.data.length === 0) {
            return stepResult;
          } else {
            return this.parse1(docSet, allNodes, nodeLookup, stepResult, queryArray.slice(1));
          }
        } else {
          return result;
        }
      }
      queryArray(qs) {
        const ret = [];
        for (const s of qs.split("/")) {
          ret.push(s);
        }
        return ret;
      }
      indexNodes(docSet, nodes) {
        const ret = /* @__PURE__ */ new Map();
        for (const [n, node] of nodes.entries()) {
          const nodeId = docSet.unsuccinctifyScopes(node.bs)[0][2].split("/")[1];
          ret.set(nodeId, n);
        }
        return ret;
      }
      doc() {
        return "** Steps **\n\n" + stepActions.map((sa) => sa.doc).map((d) => `* ${d.title} *
${d.syntax}
${d.description}`).join("\n\n") + "** Predicate Operators **\n\n" + Object.values(expressions).filter((e) => e.doc).map((e) => `${e.doc.operator}(${e.doc.args.map((a) => "<" + a + ">").join(", ")}) => ${e.doc.result}
${e.doc.description}`).join("\n\n");
      }
      parse(docSet, nodes, queryString) {
        const result = this.parse1(
          docSet,
          nodes,
          this.indexNodes(docSet, nodes),
          { data: nodes },
          this.queryArray(queryString)
        );
        if (result.data) {
          switch (this.currentStepType) {
            case "nodes":
              result.data = result.data.map((n) => ({ id: docSet.unsuccinctifyScopes(n.bs)[0][2].split("/")[1] }));
          }
        }
        const ret = JSON.stringify(result, null, 2);
        return ret;
      }
    };
    module.exports = Tribos;
  }
});

// node_modules/proskomma-core/src/graph/queries/tree_sequence.cjs
var require_tree_sequence = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/tree_sequence.cjs"(exports, module) {
    init_process();
    init_buffer();
    var Tribos = require_tribos();
    var treeSequenceSchemaString = `
"""The nodes of a tree"""
type treeSequence {
  """The id of the sequence"""
  id: String!
  """The number of nodes in the tree sequence"""
  nNodes: Int!
  """The nodes in the tree sequence"""
  nodes: [node!]!
  """The JSON result for a Tribos query, as a string"""
  tribos(
    """The Tribos query string"""
    query: String!
  ): String!
  """The JSON results for the Tribos queries, as an array of strings"""
  triboi(
    """The Tribos query strings"""
    queries: [String!]!
  ): [String!]!
  """Tribos documentation"""
  tribosDoc: String!
  """A list of the tags of this sequence"""
  tags: [String!]!
  """A list of the tags of this sequence as key/value tuples"""
  tagsKv: [KeyValue!]!
  """Whether or not the sequence has the specified tag"""
  hasTag(
    """The tag name"""
    tagName: String
  ): Boolean!
}
`;
    var treeSequenceResolvers = {
      nNodes: (root) => root.blocks.length,
      nodes: (root) => root.blocks,
      tribos: (root, args, context) => new Tribos().parse(context.docSet, root.blocks, args.query),
      triboi: (root, args, context) => args.queries.map((q) => new Tribos().parse(context.docSet, root.blocks, q)),
      tribosDoc: () => new Tribos().doc(),
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName)
    };
    module.exports = {
      treeSequenceSchemaString,
      treeSequenceResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/block.cjs
var require_block2 = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/block.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var utils = require_util();
    var { dumpBlock } = require_dump();
    var scopeMatchesStartsWith = (sw, s) => {
      if (sw.length === 0) {
        return true;
      }
      for (const swv of sw) {
        if (s.startsWith(swv)) {
          return true;
        }
      }
      return false;
    };
    var blockSchemaString = `
"""Part of a sequence, roughly equivalent to a USFM paragraph"""
type Block {
  """The length in bytes of the succinct representation of c (block items)"""
  cBL: Int!
  """The length in bytes of the succinct representation of bg (block grafts)"""
  bgBL: Int!
  """The length in bytes of the succinct representation of os (open scopes)"""
  osBL: Int!
  """The length in bytes of the succinct representation of is (included scopes)"""
  isBL: Int!
  """The length in bytes of the succinct representation of nt (nextToken at the start of the block)"""
  ntBL: Int!
  """The number of items in the succinct representation of c (block items)"""
  cL: Int!
  """The number of items in the succinct representation of bg (block grafts)"""
  bgL: Int!
  """The number of items in the succinct representation of os (open scopes)"""
  osL: Int!
  """The number of items in the succinct representation of is (included scopes)"""
  isL: Int!
  """A list of included scopes for this block"""
  is: [Item!]!
  """A list of open scopes for this block"""
  os: [Item!]!
  """The block scope for this block"""
  bs: Item!
  """A list of block grafts for this block"""
  bg: [Item!]!
  """The value of nextToken at the start of this block"""
  nt: Int!
  """A list of items from the c (content) field of the block"""
  items(
    """Only return items that are within specific scopes"""
    withScopes: [String!]
    """If true, withScopes filtering matches items within at least one of the specified scopes"""
    anyScope: Boolean
    """Only return items that are within a chapterVerse range (ch or ch:v or ch:v-v or ch:v-ch:v)"""
    withScriptureCV: String
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ) : [Item!]! 
  """A list of tokens from the c (content) field of the block"""
  tokens(
    """Only return tokens that are within specific scopes"""
    withScopes: [String!]
    """If true, withScopes filtering matches tokens within at least one of the specified scopes"""
    anyScope: Boolean
    """Only return tokens that are within a chapterVerse range (ch or ch:v or ch:v-v or ch:v-ch:v)"""
    withScriptureCV: String
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
    """Return tokens whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return tokens whose payload matches one of the specified regexes"""
    withMatchingChars: [String!]
    """Return tokens with one of the specified subTypes"""
    withSubTypes: [String!]
  ) : [Item!]!
  """The text of the block as a single string"""
  text(
    """Only return text that is within a chapterVerse range (ch or ch:v or ch:v-v or ch:v-ch:v)"""
    withScriptureCV: String
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
  """'Block items grouped by scopes or milestones"""
  itemGroups(
    """Produce one itemGroup for every match of the list of scopes"""
    byScopes: [String!]
    """Start a new itemGroup whenever a milestone in the list is encountered"""
    byMilestones: [String!]
  ): [ItemGroup]!
  """The block content as a string in a compact eyeballable format"""
  dump: String!
  """A list of the labels for the block\\'s bs, os and is scopes"""
  scopeLabels(
    """Only include scopes that begin with this value"""
    startsWith: [String!]
  ): [String!]!
}
`;
    var blockResolvers = {
      cBL: (root) => root.c.length,
      bgBL: (root) => root.bg.length,
      osBL: (root) => root.os.length,
      isBL: (root) => root.is.length,
      ntBL: (root) => root.nt.length,
      cL: (root, args, context) => context.docSet.countItems(root.c),
      bgL: (root, args, context) => context.docSet.countItems(root.bg),
      osL: (root, args, context) => context.docSet.countItems(root.os),
      isL: (root, args, context) => context.docSet.countItems(root.is),
      is: (root, args, context) => context.docSet.unsuccinctifyScopes(root.is),
      os: (root, args, context) => context.docSet.unsuccinctifyScopes(root.os),
      bs: (root, args, context) => {
        const [itemLength, itemType, itemSubtype] = utils.succinct.headerBytes(root.bs, 0);
        return context.docSet.unsuccinctifyScope(root.bs, itemType, itemSubtype, 0);
      },
      bg: (root, args, context) => context.docSet.unsuccinctifyGrafts(root.bg),
      nt: (root) => root.nt.nByte(0),
      items: (root, args, context) => {
        if (args.withScopes && args.withScriptureCV) {
          throw new Error("Cannot specify both withScopes and withScriptureCV");
        }
        if (args.withScriptureCV) {
          return context.docSet.unsuccinctifyItemsWithScriptureCV(root, args.withScriptureCV, {}, args.includeContext || false);
        } else {
          return context.docSet.unsuccinctifyPrunedItems(
            root,
            {
              tokens: true,
              scopes: true,
              grafts: true,
              requiredScopes: args.withScopes || [],
              anyScope: args.anyScope || false
            }
          );
        }
      },
      tokens: (root, args, context) => {
        if (Object.keys(args).filter((a) => a.includes("Chars")).length > 1) {
          throw new Error('Only one of "withChars", "withAnyCaseChars" and "withCharsMatchingRegex" may be specified');
        }
        let ret;
        if (args.withScriptureCV) {
          ret = context.docSet.unsuccinctifyItemsWithScriptureCV(
            root,
            args.withScriptureCV,
            { tokens: true },
            args.includeContext || false
          );
        } else {
          ret = context.docSet.unsuccinctifyPrunedItems(
            root,
            {
              tokens: true,
              scopes: true,
              requiredScopes: args.withScopes || [],
              anyScope: args.anyScope || false
            }
          );
        }
        if (args.withSubTypes) {
          ret = ret.filter((i) => args.withSubTypes.includes(i[1]));
        }
        if (args.withChars) {
          ret = ret.filter((i) => args.withChars.includes(i[2]));
        } else if (args.withMatchingChars) {
          ret = ret.filter((i) => {
            for (const re of args.withMatchingChars) {
              if (xre.test(i, xre(re))) {
                return true;
              }
            }
            return false;
          });
        }
        return ret.filter((i) => i[0] === "token");
      },
      text: (root, args, context) => {
        const tokens = args.withScriptureCV ? context.docSet.unsuccinctifyItemsWithScriptureCV(
          root,
          args.withScriptureCV,
          { tokens: true },
          false
        ) : context.docSet.unsuccinctifyItems(root.c, { tokens: true }, null);
        let ret = tokens.map((t) => t[2]).join("").trim();
        if (args.normalizeSpace) {
          ret = ret.replace(/[ \t\n\r]+/g, " ");
        }
        return ret;
      },
      itemGroups: (root, args, context) => {
        if (args.byScopes && args.byMilestones) {
          throw new Error("Cannot specify both byScopes and byMilestones");
        }
        if (!args.byScopes && !args.byMilestones) {
          throw new Error("Must specify either byScopes or byMilestones");
        }
        if (args.byScopes) {
          return context.docSet.sequenceItemsByScopes([root], args.byScopes);
        } else {
          return context.docSet.sequenceItemsByMilestones([root], args.byMilestones);
        }
      },
      dump: (root, args, context) => dumpBlock(context.docSet.unsuccinctifyBlock(root, {}, null)),
      scopeLabels: (root, args, context) => [...context.docSet.unsuccinctifyBlockScopeLabelsSet(root)].filter((s) => !args.startsWith || scopeMatchesStartsWith(args.startsWith, s))
    };
    module.exports = {
      blockSchemaString,
      blockResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/lib/sequence_chars.cjs
var require_sequence_chars = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/sequence_chars.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var exactSearchTermIndexes = (docSet, chars, allChars) => {
      let charsIndexesArray = [
        chars.map(
          (c) => [utils.enums.enumStringIndex(docSet.enums.wordLike, c)]
        )
      ];
      if (allChars) {
        charsIndexesArray = charsIndexesArray[0];
      } else {
        charsIndexesArray = charsIndexesArray.map((ci) => ci.reduce((a, b) => a.concat(b)));
      }
      return charsIndexesArray;
    };
    var regexSearchTermIndexes = (docSet, chars, allChars) => {
      let charsIndexesArray = [
        chars.map(
          (c) => utils.enums.enumRegexIndexTuples(docSet.enums.wordLike, c).map((tup) => tup[0])
        )
      ];
      if (allChars) {
        charsIndexesArray = charsIndexesArray[0];
      } else {
        charsIndexesArray = charsIndexesArray.map((ci) => ci.reduce((a, b) => a.concat(b)));
      }
      return charsIndexesArray;
    };
    var sequenceMatchesSearchTerms = (seq, charsIndexesArray, allChars) => {
      if (allChars && charsIndexesArray.filter((i) => i.length === 0).length > 0) {
        return false;
      }
      charsIndexesArray = charsIndexesArray.filter((i) => i.length > 0);
      if (charsIndexesArray.length === 0) {
        return false;
      }
      for (const charsIndexes of charsIndexesArray) {
        let found = false;
        for (const charsIndex of charsIndexes) {
          const isPresent = charsIndex >= 0 && seq.tokensPresent.get(charsIndex) > 0;
          if (isPresent) {
            found = true;
            break;
          }
        }
        if (allChars && !found) {
          return false;
        } else if (!allChars && found) {
          return true;
        }
      }
      return allChars;
    };
    var sequenceHasChars = (docSet, seq, chars, allChars) => {
      let charsIndexesArray = exactSearchTermIndexes(docSet, chars, allChars);
      return sequenceMatchesSearchTerms(seq, charsIndexesArray, allChars);
    };
    var sequenceHasMatchingChars = (docSet, seq, chars, allChars) => {
      let charsIndexesArray = regexSearchTermIndexes(docSet, chars, allChars);
      return sequenceMatchesSearchTerms(seq, charsIndexesArray, allChars);
    };
    module.exports = {
      sequenceHasChars,
      sequenceHasMatchingChars,
      regexSearchTermIndexes,
      exactSearchTermIndexes
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/sequence.cjs
var require_sequence = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/sequence.cjs"(exports, module) {
    init_process();
    init_buffer();
    var {
      sequenceHasChars,
      sequenceHasMatchingChars,
      regexSearchTermIndexes,
      exactSearchTermIndexes
    } = require_sequence_chars();
    var options = {
      tokens: false,
      scopes: true,
      grafts: false,
      requiredScopes: []
    };
    var blockHasAtts = (docSet, block2, attSpecsArray, attValuesArray, requireAll) => {
      let matched = /* @__PURE__ */ new Set([]);
      for (const item of docSet.unsuccinctifyPrunedItems(block2, options, false)) {
        const [att, attType, element, key, count, value] = item[2].split("/");
        for (const [n, attSpecs] of attSpecsArray.entries()) {
          for (const attSpec of attSpecs) {
            if (attType === attSpec.attType && element === attSpec.tagName && key === attSpec.attKey && parseInt(count) === attSpec.valueN && attValuesArray[n].includes(value)) {
              if (!requireAll) {
                return true;
              }
              matched.add(n);
              break;
            }
          }
          if (matched.size === attSpecsArray.length) {
            return true;
          }
        }
      }
      return false;
    };
    var sequenceSchemaString = `
"""A contiguous flow of content"""
type Sequence {
  """The id of the sequence"""
  id: String!
  """The type of the sequence (main, heading...)"""
  type: String!
  """The number of blocks in the sequence"""
  nBlocks: Int!
  """The blocks in the sequence"""
  blocks(
    """Only return blocks where the list of scopes is open"""
    withScopes: [String!]
    """Only return blocks whose zero-indexed position is in the list"""
    positions: [Int!]
    """Only return blocks with the specified block scope (eg 'blockScope/p'"""
    withBlockScope: String
    """Only return blocks that contain items within the specified chapter, verse or chapterVerse range"""
    withScriptureCV: String
    """Ordered list of attribute specs whose values must match those in 'attValues'"""
    attSpecs: [[AttSpec!]!]
    """Ordered list of attribute values, used in conjunction with \\'attSpecs\\'"""
    attValues: [[String!]!]
    """If true, blocks where all attSpecs match will be included"""
    allAtts: Boolean
    """Return blocks containing a token whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return blocks containing a token whose payload matches the specified regexes"""
    withMatchingChars: [String!]
    """If true, blocks where all regexes match will be included"""
    allChars: Boolean
  ): [Block!]!
  """The items for each block in the sequence"""
  blocksItems: [[Item!]!]
  """The tokens for each block in the sequence"""
  blocksTokens: [[Item!]!]
  """The text for each block in the sequence"""
  blocksText(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): [String!]
  """The text for the sequence"""
  text(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ) : String!
  """Sequence content grouped by scopes or milestones"""
  itemGroups(
    """Produce one itemGroup for every different match of the list of scopes"""
    byScopes: [String!]
    """Start a new itemGroup whenever a milestone in the list is encountered"""
    byMilestones: [String!]
  ) : [ItemGroup!]!
  """A list of the tags of this sequence"""
  tags: [String!]!
  """A list of the tags of this sequence as key/value tuples"""
  tagsKv: [KeyValue!]!
  """Whether or not the sequence has the specified tag"""
  hasTag(
    """The specified tag"""
    tagName: String!
  ): Boolean!
  """A list of wordLike token strings in a main sequence"""
  wordLikes(
    """Whether to coerce the strings (toLower|toUpper|none)"""
    coerceCase: String
  ) : [String!]!
  """Returns true if a main sequence contains the specified tokens"""
  hasChars(
    """Token strings to be matched exactly"""
    chars: [String!]
    """If true all tokens must match"""
    allChars: Boolean
  ): Boolean!
  """Returns true if a main sequence contains a match for specified regexes"""
  hasMatchingChars(
    """Regexes to be matched"""
    chars: [String!]
    """If true all regexes must match"""
    allChars: Boolean
  ): Boolean!
}
`;
    var sequenceResolvers = {
      nBlocks: (root) => root.blocks.length,
      blocks: (root, args, context) => {
        context.docSet.maybeBuildEnumIndexes();
        if (args.withScopes && args.withScriptureCV) {
          throw new Error("Cannot specify both withScopes and withScriptureCV");
        }
        if (args.attSpecs && !args.attValues) {
          throw new Error("Cannot specify attSpecs without attValues");
        }
        if (!args.attSpecs && args.attValues) {
          throw new Error("Cannot specify attValues without attSpecs");
        }
        if (args.attSpecs && args.attValues && args.attSpecs.length !== args.attValues.length) {
          throw new Error("attSpecs and attValues must be same length");
        }
        if (args.withChars && args.withMatchingChars) {
          throw new Error("Cannot specify both withChars and withMatchingChars");
        }
        let ret = root.blocks;
        if (args.positions) {
          ret = Array.from(ret.entries()).filter((b) => args.positions.includes(b[0])).map((b) => b[1]);
        }
        if (args.withScopes) {
          ret = ret.filter((b) => context.docSet.allScopesInBlock(b, args.withScopes));
        }
        if (args.withScriptureCV) {
          ret = context.docSet.blocksWithScriptureCV(ret, args.withScriptureCV);
        }
        if (args.attSpecs) {
          ret = ret.filter((b) => blockHasAtts(context.docSet, b, args.attSpecs, args.attValues, args.allAtts || false));
        }
        if (args.withBlockScope) {
          ret = ret.filter((b) => context.docSet.blockHasBlockScope(b, args.withBlockScope));
        }
        if (args.withChars) {
          if (root.type === "main" && !sequenceHasChars(context.docSet, root, args.withChars, args.allChars)) {
            return [];
          }
          let charsIndexesArray = exactSearchTermIndexes(context.docSet, args.withChars, args.allChars);
          for (const charsIndexes of charsIndexesArray) {
            ret = ret.filter((b) => context.docSet.blockHasChars(b, charsIndexes));
          }
        }
        if (args.withMatchingChars) {
          if (root.type === "main" && !sequenceHasMatchingChars(context.docSet, root, args.withMatchingChars, args.allChars)) {
            return [];
          }
          let charsIndexesArray = regexSearchTermIndexes(context.docSet, args.withMatchingChars, args.allChars);
          for (const charsIndexes of charsIndexesArray) {
            ret = ret.filter((b) => context.docSet.blockHasChars(b, charsIndexes));
          }
        }
        return ret;
      },
      blocksItems: (root, args, context) => root.blocks.map((b) => context.docSet.unsuccinctifyItems(b.c, {}, null)),
      blocksTokens: (root, args, context) => root.blocks.map((b) => context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null)),
      blocksText: (root, args, context) => root.blocks.map(
        (b) => {
          let ret = context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null).map((t) => t[2]).join("");
          if (args.normalizeSpace) {
            ret = ret.replace(/[ \t\n\r]+/g, " ");
          }
          return ret;
        }
      ),
      text: (root, args, context) => {
        let ret = root.blocks.map(
          (b) => context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null).map((t) => t[2]).join("")
        ).join("\n");
        if (args.normalizeSpace) {
          ret = ret.replace(/[ \t\n\r]+/g, " ");
        }
        return ret;
      },
      itemGroups: (root, args, context) => {
        if (args.byScopes && args.byMilestones) {
          throw new Error("Cannot specify both byScopes and byMilestones");
        }
        if (!args.byScopes && !args.byMilestones) {
          throw new Error("Must specify either byScopes or byMilestones");
        }
        if (args.byScopes) {
          return context.docSet.sequenceItemsByScopes(
            root.blocks,
            args.byScopes
          );
        } else {
          return context.docSet.sequenceItemsByMilestones(root.blocks, args.byMilestones);
        }
      },
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName),
      wordLikes: (root, args, context) => {
        if (root.type !== "main") {
          throw new Error(`Only available for the main sequence, not ${root.type}`);
        }
        if (args.coerceCase && !["toLower", "toUpper", "none"].includes(args.coerceCase)) {
          throw new Error(`coerceCase, when present, must be 'toLower', 'toUpper' or 'none', not '${args.coerceCase}'`);
        }
        context.docSet.maybeBuildEnumIndexes();
        let tokens = /* @__PURE__ */ new Set();
        let n = 0;
        for (const b of root.tokensPresent) {
          if (b) {
            const enumOffset = context.docSet.enumIndexes["wordLike"][n];
            let tokenString = context.docSet.enums["wordLike"].countedString(enumOffset);
            if (args.coerceCase === "toLower") {
              tokenString = tokenString.toLowerCase();
            }
            if (args.coerceCase === "toUpper") {
              tokenString = tokenString.toUpperCase();
            }
            tokens.add(tokenString);
          }
          n++;
        }
        return Array.from(tokens).sort();
      },
      hasChars: (root, args, context) => {
        if (root.type !== "main") {
          throw new Error(`Only available for the main sequence, not ${root.type}`);
        }
        return sequenceHasChars(context.docSet, root, args.chars, args.allChars || false);
      },
      hasMatchingChars: (root, args, context) => {
        if (root.type !== "main") {
          throw new Error(`Only available for the main sequence, not ${root.type}`);
        }
        return sequenceHasMatchingChars(context.docSet, root, args.chars, args.allChars);
      }
    };
    module.exports = {
      sequenceSchemaString,
      sequenceResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/lib/do_cv.cjs
var require_do_cv = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/do_cv.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var utils = require_util();
    var updatedOpenScopes = (openScopes, items) => {
      let ret = openScopes;
      for (const item of items) {
        if (item[0] === "scope") {
          if (item[1] === "start") {
            const existingScopes = ret.filter((s) => s === item[2]);
            if (existingScopes.length === 0) {
              ret.push(item[2]);
            }
          } else {
            ret = ret.filter((s) => s !== item[2]);
          }
        }
      }
      return ret;
    };
    var do_chapter_cv = (root, context, mainSequence, chapterN, includeContext) => {
      const ci = root.chapterIndex(chapterN);
      if (ci) {
        const block2 = mainSequence.blocks[ci.startBlock];
        return [[
          updatedOpenScopes(
            context.docSet.unsuccinctifyScopes(block2.os).map((s) => s[2]),
            context.docSet.unsuccinctifyItems(block2.c, {}, 0, []).slice(0, ci.startItem + 1).filter((i) => i[0] === "scope")
          ),
          context.docSet.itemsByIndex(mainSequence, ci, includeContext || false).reduce((a, b) => a.concat([["token", "lineSpace", " "]].concat(b)))
        ]];
      } else {
        return [];
      }
    };
    var do_chapter_verse_array = (root, context, mainSequence, chapterN, verses, includeContext, doMap, mappedDocSetId) => {
      let docSet = context.docSet;
      let book = root.headers.bookCode;
      let chapterVerses = verses.map((v) => [parseInt(chapterN), parseInt(v)]);
      if (doMap) {
        const mappedDocSet = root.processor.docSets[mappedDocSetId];
        if (mappedDocSet) {
          docSet = mappedDocSet;
        }
        if ("forward" in mainSequence.verseMapping && chapterN in mainSequence.verseMapping.forward) {
          let mappings = [];
          for (const verse of verses) {
            mappings.push(
              utils.versification.mapVerse(
                mainSequence.verseMapping.forward[chapterN],
                root.headers.bookCode,
                chapterN,
                verse
              )
            );
          }
          const mapping = mappings[0];
          book = mapping[0];
          chapterVerses = mapping[1];
        }
        const mappedDocument = docSet.documentWithBook(book);
        if (mappedDocument) {
          const mappedMainSequence = mappedDocument.sequences[mappedDocument.mainId];
          if (mappedMainSequence.verseMapping && "reversed" in mappedMainSequence.verseMapping) {
            const doubleMappings = [];
            for (const [origC, origV] of chapterVerses) {
              if (`${origC}` in mappedMainSequence.verseMapping.reversed) {
                doubleMappings.push(
                  utils.versification.mapVerse(
                    mappedMainSequence.verseMapping.reversed[`${origC}`],
                    book,
                    origC,
                    origV
                  )
                );
              } else {
                doubleMappings.push([book, [[origC, origV]]]);
              }
              book = doubleMappings[0][0];
              chapterVerses = doubleMappings.map((bcv) => bcv[1]).reduce((a, b) => a.concat(b));
            }
          }
        }
      }
      const cvis = {};
      const document2 = docSet.documentWithBook(book);
      if (!document2) {
        return [];
      }
      const documentMainSequence = document2.sequences[document2.mainId];
      for (const chapter of chapterVerses.map((cv) => cv[0])) {
        if (!(chapter in cvis)) {
          cvis[chapter] = document2.chapterVerseIndex(chapter);
        }
      }
      const retItemGroups = [];
      for (const [chapter, verse] of chapterVerses) {
        if (cvis[chapter]) {
          let retItems = [];
          let firstStartBlock;
          let firstStartItem;
          if (cvis[chapter][verse]) {
            for (const ve of cvis[chapter][verse]) {
              if (!firstStartBlock) {
                firstStartBlock = ve.startBlock;
                firstStartItem = ve.startItem;
              }
              retItems = retItems.concat(docSet.itemsByIndex(documentMainSequence, ve, includeContext || null).reduce((a, b) => a.concat([["token", "lineSpace", " "]].concat(b))));
            }
            const block2 = documentMainSequence.blocks[firstStartBlock];
            retItemGroups.push([
              updatedOpenScopes(
                docSet.unsuccinctifyScopes(block2.os).map((s) => s[2]),
                docSet.unsuccinctifyItems(block2.c, {}, 0, []).slice(0, firstStartItem + 1).filter((i) => i[0] === "scope")
              ),
              retItems
            ]);
          }
        }
      }
      return retItemGroups;
    };
    var scopesMatchAChapterSpec = (scopes, chapterSpecs) => {
      if (chapterSpecs.length === 0) {
        return false;
      } else if (scopes.includes(`chapter/${chapterSpecs[0][0]}`) && (!chapterSpecs[0][1] || scopes.filter((s) => s.startsWith("verse/") && parseInt(s.split("/")[1]) >= chapterSpecs[0][1]).length > 0) && (!chapterSpecs[0][2] || scopes.filter((s) => s.startsWith("verse/") && parseInt(s.split("/")[1]) <= chapterSpecs[0][2]).length > 0)) {
        return true;
      } else {
        return scopesMatchAChapterSpec(scopes, chapterSpecs.slice(1));
      }
    };
    var do_chapterVerses = (root, context, mainSequence, fromCV, toCV, includeContext) => {
      const [fromCInt, fromVInt] = fromCV.split(":").map((str) => parseInt(str));
      const [toCInt, toVInt] = toCV.split(":").map((str) => parseInt(str));
      if (toCInt < fromCInt) {
        throw new Error(`cv chapterVerses requires fromChapter <= toChapter, not ${fromCInt} to ${toCInt}`);
      }
      const chapterSpecs = [];
      let ch = fromCInt;
      while (ch <= toCInt) {
        chapterSpecs.push([
          ch,
          ch === fromCInt ? fromVInt : null,
          ch === toCInt ? toVInt : null
        ]);
        ch++;
      }
      return context.docSet.sequenceItemsByScopes(mainSequence.blocks, ["chapter/", "verse/"], includeContext).filter((ig) => scopesMatchAChapterSpec(ig[0], chapterSpecs));
    };
    var do_cv_separate_args = (root, args, context, mainSequence, doMap, mappedDocSetId) => {
      if (args.chapter && !args.verses) {
        return do_chapter_cv(root, context, mainSequence, args.chapter, args.includeContext);
      } else if (args.verses) {
        return do_chapter_verse_array(root, context, mainSequence, args.chapter, args.verses, args.includeContext, doMap, mappedDocSetId);
      } else {
        throw new Error("Unexpected args to do_cv_separate_args");
      }
    };
    var do_cv_string_arg = (root, args, context, mainSequence) => {
      if (xre.test(args.chapterVerses, xre("^[0-9]+:[0-9]+-[0-9]+:[0-9]+$"))) {
        const [fromSpec, toSpec] = args.chapterVerses.split("-");
        return do_chapterVerses(root, context, mainSequence, fromSpec, toSpec, args.includeContext);
      } else if (xre.test(args.chapterVerses, xre("^[0-9]+:[0-9]+-[0-9]+$"))) {
        const [ch, vRange] = args.chapterVerses.split(":");
        const [fromV, toV] = vRange.split("-");
        return do_chapterVerses(root, context, mainSequence, `${ch}:${fromV}`, `${ch}:${toV}`, args.includeContext);
      } else if (xre.test(args.chapterVerses, xre("^[0-9]+:[0-9]+$"))) {
        const [ch, v] = args.chapterVerses.split(":");
        return do_chapterVerses(root, context, mainSequence, `${ch}:${v}`, `${ch}:${v}`, args.includeContext);
      } else if (xre.test(args.chapterVerses, xre("^[0-9]+$"))) {
        const ch = args.chapterVerses;
        const cvi = root.chapterVerseIndex(ch);
        if (!cvi) {
          throw new Error(`No chapter ${ch} found`);
        }
        const verseNs = cvi.map((c, n) => [n, c]).filter((nc) => nc[1].length > 0).map((nc) => nc[0]);
        return do_chapterVerses(root, context, mainSequence, `${ch}:${Math.min(verseNs)}`, `${ch}:${Math.max(verseNs)}`, args.includeContext);
      } else {
        throw new Error(`Could not parse chapterVerses string '${args.chapterVerses}'`);
      }
    };
    var do_cv = (root, args, context, doMap, mappedDocSetId) => {
      context.docSet = root.processor.docSets[root.docSetId];
      const mainSequence = root.sequences[root.mainId];
      if (!args.chapter && !args.chapterVerses) {
        throw new Error("Must specify either chapter or chapterVerses for cv");
      }
      if (args.chapter && args.chapterVerses) {
        throw new Error("Must not specify both chapter and chapterVerses for cv");
      }
      if (args.chapterVerses && args.verses) {
        throw new Error("Must not specify both chapterVerses and verses for cv");
      }
      if (args.chapter) {
        return do_cv_separate_args(root, args, context, mainSequence, doMap, mappedDocSetId);
      } else {
        return do_cv_string_arg(root, args, context, mainSequence);
      }
    };
    module.exports = { do_cv };
  }
});

// node_modules/proskomma-core/src/graph/queries/document.cjs
var require_document2 = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/document.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var { do_cv } = require_do_cv();
    var headerById = (root, id) => id in root.headers ? root.headers[id] : null;
    var documentSchemaString = `
"""A document, typically corresponding to USFM for one book"""
type Document {
  """The id of the document"""
  id: String!
  """A parsed version of the id header"""
  idParts: idParts!
  """The id of the docSet to which this document belongs"""
  docSetId: String!
  """USFM header information such as TOC"""
  headers: [KeyValue!]!
  """One USFM header"""
  header(
    """The header id, corresponding to the tag name minus any trailing '1'"""
    id: String!
  ): String
  """The main sequence"""
  mainSequence: Sequence!
  """The number of sequences"""
  nSequences: Int!
  """A list of sequences for this document"""
  sequences(
    """ids of sequences to include, if found"""
    ids: [String!]
    """types of sequences to include, if found"""
    types: [String!]
    """Only return sequences with all the specified tags"""
    withTags: [String!]
    """Only return sequences with none of the specified tags"""
    withoutTags: [String!]
  ): [Sequence!]!
  """A list of table sequences for this document"""
  tableSequences(
    """ids of sequences to include, if found"""
    ids: [String!]
    """Only return sequences with all the specified tags"""
    withTags: [String!]
    """Only return sequences with none of the specified tags"""
    withoutTags: [String!]
  ): [tableSequence!]!
  """A list of tree sequences for this document"""
  treeSequences(
    """ids of sequences to include, if found"""
    ids: [String!]
    """Only return sequences with all the specified tags"""
    withTags: [String!]
    """Only return sequences with none of the specified tags"""
    withoutTags: [String!]
  ): [treeSequence!]!
  """A list of key-value sequences for this document"""
  kvSequences(
    """ids of sequences to include, if found"""
    ids: [String!]
    """Only return sequences with all the specified tags"""
    withTags: [String!]
    """Only return sequences with none of the specified tags"""
    withoutTags: [String!]
  ): [kvSequence!]!
  """A list of text (ie non-table, non-tree, non-kv) sequences for this document"""
  textSequences(
    """ids of sequences to include, if found"""
    ids: [String!]
    """Only return sequences with all the specified tags"""
    withTags: [String!]
    """Only return sequences with none of the specified tags"""
    withoutTags: [String!]
  ): [Sequence!]!
  """The sequence with the specified id"""
  sequence(
    """id of the sequence"""
    id: String!
  ): Sequence
  """The table sequence with the specified id"""
  tableSequence(
    """id of the sequence"""
    id: String!
  ): tableSequence
  """The tree sequence with the specified id"""
  treeSequence(
    """id of the sequence"""
    id: String!
  ): treeSequence
  """The key-value sequence with the specified id"""
  kvSequence(
    """id of the sequence"""
    id: String!
  ): kvSequence
  """The blocks of the main sequence"""
  mainBlocks: [Block!]!
  """The items for each block of the main sequence"""
  mainBlocksItems: [[Item!]!]!
  """The tokens for each block of the main sequence"""
  mainBlocksTokens: [[Item!]!]!
  """The text for each block of the main sequence"""
  mainBlocksText(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): [String!]!
  """The text for the main sequence"""
  mainText(
    """If true, converts each whitespace character to a single space"""
    normalizeSpace: Boolean
  ): String!
  """A list of the tags of this document"""
  tags: [String!]!
  """A list of the tags of this document as key/value tuples"""
  tagsKv: [KeyValue!]!
  """'Whether or not the document has the specified tag"""
  hasTag(
    tagName: String!
  ): Boolean!
  """Content for a Scripture reference within this document, using local versification"""
  cv(
    """The chapter number (as a string)"""
    chapter: String
    """'A list of verse numbers (as strings)"""
    verses: [String!]
    """A chapterVerse Reference (ch:v-ch:v)"""
    chapterVerses: String
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [ItemGroup!]!
  """Content for a Scripture reference within this document, using the versification of the specified docSet"""
  mappedCv(
    """The chapter number (as a string)"""
    chapter: String!
    """The id of the mapped docSet"""
    mappedDocSetId: String!
    """A list of verse numbers (as strings)"""
    verses: [String!]!
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [ItemGroup!]!
  """Content for each verse of a chapter within this document, using the versification of the specified docSet"""
  mappedCvs(
    """The chapter number (as a string)"""
    chapter: String!
    """The id of the mapped docSet"""
    mappedDocSetId: String!
    """If true, adds scope and nextToken information to each token"""
    includeContext: Boolean
  ): [[ItemGroup!]!]!
  """What's previous and next with respect to the specified verse"""
  cvNavigation(
    """The chapter number (as a string)"""
    chapter: String!
    """A verse number (as a string)"""
    verse: String!
  ): cvNavigation
  """The content of the main sequence indexed by chapterVerse"""
  cvIndexes: [cvIndex]!
  """The content of the specified chapter indexed by chapterVerse"""
  cvIndex(
    """The chapter number"""
    chapter: Int!
  ): cvIndex!
  """The content of the main sequence indexed by chapter"""
  cIndexes: [cIndex]!
  """The content of a chapter"""
  cIndex(
    """'The chapter number"""
    chapter: Int!
  ): cIndex!
  """Verses matching the arguments"""
  cvMatching(
    """Return verses containing a token whose payload is an exact match to one of the specified strings"""
    withChars: [String!]
    """Return verses containing a token whose payload matches the specified regexes"""
    withMatchingChars: [String!]
    """Only return blocks where the list of scopes is open"""
    withScopes: [String!]
    """If true, verses where all regexes match will be included"""
    allChars: Boolean
    """If true, verses where all scopes match will be included"""
    allScopes: Boolean
  ): [ItemGroup!]!
  """A string of PERF JSON for this document"""
  perf(
    """Format JSON string with this indent"""
    indent: Int
  ): String! 
  """A string of USFM for this document"""
  usfm: String! 
  """A string of SOFRIA JSON for this document"""
  sofria(
    """Format JSON string with this indent"""
    indent: Int
    """Return SOFRIA for this chapter only"""
    chapter: Int
  ): String! 
}
`;
    var documentResolvers = {
      idParts: (root) => {
        const idHeader = headerById(root, "id");
        if (!idHeader) {
          return [null, null];
        }
        const periphMatch = xre.exec(idHeader, /^(P\d\d)\s+([A-Z0-6]{3})\s+(\S+)\s+-\s+(.*)/);
        if (periphMatch) {
          return ["periph", periphMatch.slice(1)];
        }
        const bookMatch = xre.exec(idHeader, /^([A-Z0-6]{3})\s+(.*)/);
        if (bookMatch) {
          return ["book", bookMatch.slice(1)];
        }
        return [null, [idHeader]];
      },
      headers: (root) => Object.entries(root.headers),
      header: (root, args) => headerById(root, args.id),
      mainSequence: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId];
      },
      nSequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return Object.keys(root.sequences).length;
      },
      sequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        if (args.ids) {
          ret = ret.filter((s) => args.ids.includes(s.id));
        }
        if (args.types) {
          ret = ret.filter((s) => args.types.includes(s.type));
        }
        if (args.withTags) {
          ret = ret.filter((s) => args.withTags.filter((t) => s.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((s) => args.withoutTags.filter((t) => s.tags.has(t)).length === 0);
        }
        return ret;
      },
      tableSequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => s.type === "table");
        if (args.ids) {
          ret = ret.filter((s) => args.ids.includes(s.id));
        }
        if (args.withTags) {
          ret = ret.filter((s) => args.withTags.filter((t) => s.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((s) => args.withoutTags.filter((t) => s.tags.has(t)).length === 0);
        }
        return ret;
      },
      treeSequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => s.type === "tree");
        if (args.ids) {
          ret = ret.filter((s) => args.ids.includes(s.id));
        }
        if (args.withTags) {
          ret = ret.filter((s) => args.withTags.filter((t) => s.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((s) => args.withoutTags.filter((t) => s.tags.has(t)).length === 0);
        }
        return ret;
      },
      kvSequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => s.type === "kv");
        if (args.ids) {
          ret = ret.filter((s) => args.ids.includes(s.id));
        }
        if (args.withTags) {
          ret = ret.filter((s) => args.withTags.filter((t) => s.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((s) => args.withoutTags.filter((t) => s.tags.has(t)).length === 0);
        }
        return ret;
      },
      textSequences: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => s.type !== "tree" && s.type !== "table" && s.type !== "kv");
        if (args.ids) {
          ret = ret.filter((s) => args.ids.includes(s.id));
        }
        if (args.withTags) {
          ret = ret.filter((s) => args.withTags.filter((t) => s.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((s) => args.withoutTags.filter((t) => s.tags.has(t)).length === 0);
        }
        return ret;
      },
      sequence: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => args.id.includes(s.id));
        return ret[0] || null;
      },
      tableSequence: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => args.id.includes(s.id));
        if (ret[0] && ret[0].type !== "table") {
          throw new Error(`Expected sequence id ${ret[0].id} to be of type 'table', not '${ret[0].type}'`);
        }
        return ret[0] || null;
      },
      treeSequence: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => args.id.includes(s.id));
        if (ret[0] && ret[0].type !== "tree") {
          throw new Error(`Expected sequence id ${ret[0].id} to be of type 'tree', not '${ret[0].type}'`);
        }
        return ret[0] || null;
      },
      kvSequence: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        let ret = Object.values(root.sequences);
        ret = ret.filter((s) => args.id.includes(s.id));
        if (ret[0] && ret[0].type !== "vk") {
          throw new Error(`Expected sequence id ${ret[0].id} to be of type 'kv', not '${ret[0].type}'`);
        }
        return ret[0] || null;
      },
      mainBlocks: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId].blocks;
      },
      mainBlocksItems: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId].blocks.map(
          (b) => context.docSet.unsuccinctifyItems(b.c, {}, null)
        );
      },
      mainBlocksTokens: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId].blocks.map(
          (b) => context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null)
        );
      },
      mainBlocksText: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId].blocks.map(
          (b) => {
            const tokens = context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null);
            let ret = tokens.map((t) => t[2]).join("").trim();
            if (args.normalizeSpace) {
              ret = ret.replace(/[ \t\n\r]+/g, " ");
            }
            return ret;
          }
        );
      },
      mainText: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        return root.sequences[root.mainId].blocks.map(
          (b) => {
            const tokens = context.docSet.unsuccinctifyItems(b.c, { tokens: true }, null);
            let ret = tokens.map((t) => t[2]).join("").trim();
            if (args.normalizeSpace) {
              ret = ret.replace(/[ \t\n\r]+/g, " ");
            }
            return ret;
          }
        ).join("\n");
      },
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName),
      cv: (root, args, context) => do_cv(root, args, context, false),
      mappedCv: (root, args, context) => {
        if (args.verses.length !== 1) {
          throw new Error(`mappedCv expects exactly one verse, not ${args.verses.length}`);
        }
        return do_cv(root, args, context, true, args.mappedDocSetId);
      },
      mappedCvs: (root, args, context) => {
        const cvIndex = root.chapterVerseIndex(args.chapter);
        const verses = cvIndex.filter((ve) => ve.length > 0).map((ve) => ve[0].verses);
        let ret = [];
        for (const verse of verses) {
          ret.push(
            do_cv(root, {
              ...args,
              verses: [verse]
            }, context, true, args.mappedDocSetId).map((ig) => [[`fromChapter/${args.chapter}`, `fromVerse/${verse}`, ...ig[0]], ig[1]])
          );
        }
        return ret;
      },
      cvNavigation: (root, args) => [
        args.chapter,
        args.verse,
        root.chapterVerseIndex((parseInt(args.chapter) - 1).toString()),
        root.chapterVerseIndex(args.chapter),
        root.chapterVerseIndex((parseInt(args.chapter) + 1).toString())
      ],
      cvIndexes: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        context.doc = root;
        return Object.entries(root.chapterVerseIndexes());
      },
      cvIndex: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        context.doc = root;
        return [args.chapter, root.chapterVerseIndex(args.chapter) || []];
      },
      cIndexes: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        context.doc = root;
        return Object.entries(root.chapterIndexes());
      },
      cIndex: (root, args, context) => {
        context.docSet = root.processor.docSets[root.docSetId];
        context.doc = root;
        const ci = root.chapterIndex(args.chapter);
        return [args.chapter, ci || {}];
      },
      cvMatching: (root, args, context) => {
        if (!args.withChars && !args.withMatchingChars && !args.withScopes) {
          throw new Error("Must specify at least one of withChars or withMatchingChars or withScopes");
        }
        if (args.withChars && args.withMatchingChars) {
          throw new Error("Must not specify both withChars and withMatchingChars");
        }
        context.docSet = root.processor.docSets[root.docSetId];
        let charsRegexes;
        if (args.withChars && args.allChars) {
          charsRegexes = args.withChars.map((s) => xre(`^${s}$`));
        } else if (args.withChars) {
          charsRegexes = [xre.union(args.withChars.map((s) => xre(`^${s}$`, "i")))];
        } else if (args.withMatchingChars && args.allChars) {
          charsRegexes = args.withMatchingChars.map((s) => xre(s, "i"));
        } else if (args.withMatchingChars) {
          charsRegexes = [xre.union(args.withMatchingChars.map((s) => xre(s, "i")))];
        }
        const allScopesInGroup = (scopes) => {
          for (const expectedScope of args.withScopes || []) {
            if (!scopes.includes(expectedScope)) {
              return false;
            }
          }
          return true;
        };
        const anyScopesInGroup = (scopes) => {
          const expectedScopes = args.withScopes || [];
          for (const expectedScope of expectedScopes) {
            if (scopes.includes(expectedScope)) {
              return true;
            }
          }
          return expectedScopes.length === 0;
        };
        const allRegexesInGroup = (items) => {
          for (const regex of charsRegexes || []) {
            let found = false;
            for (const item of items) {
              if (xre.test(item[2], regex)) {
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
          return true;
        };
        const itemGroups = context.docSet.sequenceItemsByScopes(
          root.sequences[root.mainId].blocks,
          ["chapter/", "verses/"]
        );
        return itemGroups.filter(
          (ig) => (args.allScopes ? allScopesInGroup : anyScopesInGroup)(
            ig[1].filter((i) => i[0] === "scope" && i[1] === "start").map((s) => s[2])
          ) && allRegexesInGroup(ig[1])
        );
      },
      perf: (root, args) => root.perf(args.indent),
      usfm: (root) => root.usfm(),
      sofria: (root, args) => root.sofria(args.indent, args.chapter)
    };
    module.exports = {
      documentSchemaString,
      documentResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/lib/sort.cjs
var require_sort5 = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/sort.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var ptCompare = (a, b) => {
      const bcA = a.headers.bookCode || "GEN";
      const bcB = b.headers.bookCode || "GEN";
      const posA = utils.canons.ptBooks[bcA] ? utils.canons.ptBooks[bcA].position : 999;
      const posB = utils.canons.ptBooks[bcB] ? utils.canons.ptBooks[bcB].position : 999;
      return posA - posB;
    };
    var alphaCompare = (a, b) => {
      const bcA = a.headers.bookCode || "GEN";
      const bcB = b.headers.bookCode || "GEN";
      return bcA.localeCompare(bcB);
    };
    var alpha2Compare = (a, b) => {
      const digits = [1, 2, 3, 4, 5, 6];
      let bcA = a.headers.bookCode || "GEN";
      if (digits.includes(bcA[0])) {
        bcA = bcA.substring(1) + bcA[0];
      }
      let bcB = b.headers.bookCode || "GEN";
      if (digits.includes(bcB[0])) {
        bcB = bcB.substring(1) + bcB[0];
      }
      return bcA.localeCompare(bcB);
    };
    var bookCodeCompareFunctions = {
      paratext: ptCompare,
      alpha: alphaCompare,
      alpha2: alpha2Compare
    };
    module.exports = { bookCodeCompareFunctions };
  }
});

// node_modules/proskomma-core/src/graph/queries/doc_set.cjs
var require_doc_set2 = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/doc_set.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { bookCodeCompareFunctions } = require_sort5();
    var {
      sequenceHasChars,
      sequenceHasMatchingChars
    } = require_sequence_chars();
    var docSetSchemaString = `
"""A collection of documents that share the same set of selector values"""
type DocSet {
  """The id of the docSet, which is formed by concatenating the docSet's selector values"""
  id: String!
  """The selectors of the docSet"""
  selectors: [KeyValue!]!
  """A selector for this docSet"""
  selector(
    """The id of the selector"""
    id: String!
  ): String!
  """A list of the tags of this docSet"""
  tags: [String!]!
  """A list of the tags of this docSet as key/value tuples"""
  tagsKv: [KeyValue!]!
  """Whether or not the docSet has the specified tag"""
  hasTag(
    """The tag"""
    tagName: String!
  ): Boolean!
  """The documents in the docSet"""
  documents(
    """A whitelist of ids of documents to include"""
    ids: [String!]
    """A whitelist of ids of documents to include"""
    withChars: [String!]
    """Return documents whose main sequence contains a token whose payload is an exact match to one of the specified strings"""
    withMatchingChars: [String!]
    """If true, documents where all search terms match will be included"""
    allChars: Boolean
    """Only return documents where the list of scopes is used"""
    withScopes: [String!]
    """If true, documents where all scopes are found will be included"""
    allScopes: Boolean
    """Only return documents with the specified header key/values"""
    withHeaderValues: [InputKeyValue!]
    """Only return documents with all the specified tags"""
    withTags: [String!]
    """Only return documents with none of the specified tags"""
    withoutTags: [String!]
    """Sort returned documents by the designated method (currently ${Object.keys(bookCodeCompareFunctions).join(", ")})\`"""
    sortedBy: String
  ): [Document!]!
  """The number of documents in the docSet"""
  nDocuments: Int!
  """A document in the docSet, if present"""
  document(
    """The book code of the required document"""
    bookCode: String!
  ): Document
  """Whether the docSet has versification information loaded"""
  hasMapping: Boolean!
  """The internal index number corresponding to a string in a given docSet enum"""
  enumIndexForString(
    """The enum to be searched"""
    enumType: String!
    """The string to match"""
    searchString: String!
  ): Int!
  """Information about internal indexes matching the case-insensitive regex in a given docSet enum"""
  enumRegexIndexesForString(
    """The enum to be searched"""
    enumType: String!
    """The regex to match"""
    searchRegex: String!
  ): [regexIndex!]!
  """A list of wordLike token strings in the docSet"""
  wordLikes(
    """Whether to coerce the strings (toLower|toUpper|none)"""
    coerceCase: String
  ): [String!]!
  """A list of unique characters in the docSet"""
  uniqueChars: [String!]!
  """A string containing the unique characters in the docSet"""
  uniqueCharsString: String!
  }
`;
    var docSetResolvers = {
      selectors: (root) => Object.entries(root.selectors),
      selector: (root, args) => root.selectors[args.id],
      tags: (root) => Array.from(root.tags),
      tagsKv: (root) => Array.from(root.tags).map((t) => {
        if (t.includes(":")) {
          return [t.substring(0, t.indexOf(":")), t.substring(t.indexOf(":") + 1)];
        } else {
          return [t, ""];
        }
      }),
      hasTag: (root, args) => root.tags.has(args.tagName),
      documents: (root, args, context) => {
        const headerValuesMatch = (docHeaders, requiredHeaders) => {
          for (const requiredHeader of requiredHeaders || []) {
            if (!(requiredHeader.key in docHeaders) || docHeaders[requiredHeader.key] !== requiredHeader.value) {
              return false;
            }
          }
          return true;
        };
        if (args.withChars && args.withMatchingChars) {
          throw new Error("Cannot specify both withChars and withMatchingChars");
        }
        context.docSet = root;
        let ret = root.documents();
        if (args.ids) {
          ret = ret.filter((d) => args.ids.includes(d.id));
        }
        if (args.withChars) {
          ret = ret.filter((d) => sequenceHasChars(root, d.sequences[d.mainId], args.withChars, args.allChars));
        }
        if (args.withMatchingChars) {
          ret = ret.filter((d) => sequenceHasMatchingChars(root, d.sequences[d.mainId], args.withMatchingChars, args.allChars));
        }
        if (args.withScopes) {
          const allSequenceScopes = (doc) => new Set(
            doc.sequences[doc.mainId].blocks.map((b) => context.docSet.unsuccinctifyBlockScopeLabelsSet(b)).map((s) => Array.from(s)).reduce((a, b) => a.concat(b))
          );
          ret = ret.filter(
            (d) => {
              const docScopes = allSequenceScopes(d);
              const minHits = args.allScopes ? args.withScopes.length : 1;
              return args.withScopes.filter((s) => docScopes.has(s)).length >= minHits;
            }
          );
        }
        if (args.withHeaderValues) {
          ret = ret.filter((d) => headerValuesMatch(d.headers, args.withHeaderValues));
        }
        if (args.withTags) {
          ret = ret.filter((d) => args.withTags.filter((t) => d.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((d) => args.withoutTags.filter((t) => d.tags.has(t)).length === 0);
        }
        if (args.sortedBy) {
          if (!(args.sortedBy in bookCodeCompareFunctions)) {
            throw new Error(`sortedBy value must be one of [${Object.keys(bookCodeCompareFunctions)}], not ${args.sortedBy}`);
          }
          ret.sort(bookCodeCompareFunctions[args.sortedBy]);
        }
        return ret;
      },
      nDocuments: (root, args, context) => {
        context.docSet = root;
        return root.documents().length;
      },
      document: (root, args) => root.documentWithBook(args.bookCode),
      hasMapping: (root) => root.tags.has("hasMapping"),
      enumIndexForString: (root, args) => utils.enums.enumStringIndex(root.enums[args.enumType], args.searchString),
      enumRegexIndexesForString: (root, args) => utils.enums.enumRegexIndexTuples(root.enums[args.enumType], args.searchRegex),
      wordLikes: (root, args) => {
        if (args.coerceCase && !["toLower", "toUpper", "none"].includes(args.coerceCase)) {
          throw new Error(`coerceCase, when present, must be 'toLower', 'toUpper' or 'none', not '${args.coerceCase}'`);
        }
        let tokens = utils.succinct.unpackEnum(root.enums.wordLike);
        if (args.coerceCase === "toLower") {
          tokens = tokens.map((t) => t.toLowerCase());
        }
        if (args.coerceCase === "toUpper") {
          tokens = tokens.map((t) => t.toUpperCase());
        }
        return Array.from(new Set(tokens));
      },
      uniqueChars: (root) => {
        const retSet = /* @__PURE__ */ new Set([]);
        for (const token of [...utils.succinct.unpackEnum(root.enums.wordLike), ...utils.succinct.unpackEnum(root.enums.notWordLike)]) {
          for (const char of token.split("")) {
            retSet.add(char);
          }
        }
        return Array.from(retSet).sort();
      },
      uniqueCharsString: (root) => {
        const retSet = /* @__PURE__ */ new Set([]);
        for (const token of [...utils.succinct.unpackEnum(root.enums.wordLike), ...utils.succinct.unpackEnum(root.enums.notWordLike)]) {
          for (const char of token.split("")) {
            retSet.add(char);
          }
        }
        return Array.from(retSet).sort().join("");
      }
    };
    module.exports = {
      docSetSchemaString,
      docSetResolvers
    };
  }
});

// node_modules/proskomma-core/src/model/versifications/eng_vrs.cjs
var require_eng_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/eng_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    var vrs = `# Versification  "English"
# Version=2.0
#
# modifications by Reinier de Blois 13/March/2012
# modified mappings Psalms by adding verse #0 to the mappings
# many of the subscripts that are part of verses 1,2 in the original text end up as verse #0 in English translations

# modifications by Studge 26/June/2009
# book definitions are for all books printed in any English of Spanish Bible
# this includes books for Protestant, Catholic and Protestant-Catholic-EasternOrthodox Interconfessional editions
#
# This is the versification used by most English (e.g. RSV) and Spanish Bibles (e.g. RVR)
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
#--------------------------------------------------
# Old Testament
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:55 32:32 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:33 50:26
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:25 8:32 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:36 22:31 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:29 38:31 39:43 40:38
LEV 1:17 2:16 3:17 4:35 5:19 6:30 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:57 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:46 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:27 7:89 8:26 9:23 10:36 11:35 12:16 13:33 14:45 15:41 16:50 17:13 18:32 19:22 20:29 21:35 22:41 23:30 24:25 25:18 26:65 27:23 28:31 29:40 30:16 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:32 13:18 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:30 23:25 24:22 25:19 26:19 27:26 28:68 29:29 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDG 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:58 18:30 19:24 20:42 21:15 22:23 23:29 24:22 25:44 26:25 27:12 28:25 29:11 30:31 31:13
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:33 19:43 20:26 21:22 22:51 23:39 24:25
1KI 1:53 2:46 3:28 4:34 5:18 6:38 7:51 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:43 21:29 22:53
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:21 12:21 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
1CH 1:54 2:55 3:24 4:43 5:26 6:81 7:40 8:40 9:44 10:14 11:47 12:40 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:8 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:17 2:18 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:22 14:15 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44
NEH 1:11 2:20 3:32 4:23 5:19 6:19 7:73 8:18 9:38 10:39 11:36 12:47 13:31
EST 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:22 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:30 40:24 41:34 42:17
PSA 1:6 2:12 3:8 4:8 5:12 6:10 7:17 8:9 9:20 10:18 11:7 12:8 13:6 14:7 15:5 16:11 17:15 18:50 19:14 20:9 21:13 22:31 23:6 24:10 25:22 26:12 27:14 28:9 29:11 30:12 31:24 32:11 33:22 34:22 35:28 36:12 37:40 38:22 39:13 40:17 41:13 42:11 43:5 44:26 45:17 46:11 47:9 48:14 49:20 50:23 51:19 52:9 53:6 54:7 55:23 56:13 57:11 58:11 59:17 60:12 61:8 62:12 63:11 64:10 65:13 66:20 67:7 68:35 69:36 70:5 71:24 72:20 73:28 74:23 75:10 76:12 77:20 78:72 79:13 80:19 81:16 82:8 83:18 84:12 85:13 86:17 87:7 88:18 89:52 90:17 91:16 92:15 93:5 94:23 95:11 96:13 97:12 98:9 99:9 100:5 101:8 102:28 103:22 104:35 105:45 106:48 107:43 108:13 109:31 110:7 111:10 112:10 113:9 114:8 115:18 116:19 117:2 118:29 119:176 120:7 121:8 122:9 123:4 124:8 125:5 126:6 127:5 128:6 129:8 130:8 131:3 132:18 133:3 134:3 135:21 136:26 137:9 138:8 139:24 140:13 141:10 142:7 143:12 144:15 145:21 146:10 147:20 148:14 149:9 150:6
PRO 1:33 2:22 3:35 4:27 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:25 14:35 15:33 16:33 17:28 18:24 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:16 5:20 6:12 7:29 8:17 9:18 10:20 11:10 12:14
SNG 1:17 2:17 3:11 4:16 5:16 6:13 7:13 8:14
ISA 1:31 2:22 3:26 4:6 5:30 6:13 7:25 8:22 9:21 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:12 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:12 65:25 66:24
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:22 9:26 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:21 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:10 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:49 21:32 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
DAN 1:21 2:49 3:30 4:37 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13
HOS 1:11 2:23 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:12 12:14 13:16 14:9
JOL 1:20 2:32 3:21
AMO 1:15 2:16 3:15 4:13 5:27 6:14 7:17 8:14 9:15
OBA 1:21
JON 1:17 2:10 3:10 4:11
MIC 1:16 2:13 3:12 4:13 5:15 6:16 7:20
NAM 1:15 2:13 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:15 2:23
ZEC 1:21 2:13 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:18 4:6
#-----------------------------------------------
# New Testament
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:27 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:41 5:43 6:56 7:37 8:38 9:50 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:71 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:60 8:40 9:43 10:48 11:30 12:25 13:52 14:28 15:41 16:40 17:34 18:28 19:41 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:23 15:33 16:27
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
#2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:33 12:21 13:14
# Note sometimes 2CO 13 has 14 verses e.g. KJV. but 13 verses in modern translations
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:33 12:21 13:14
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:18 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
# sometimes called the Apocalypse
#---------------------------------------------------------
# Deuterocanonical books
TOB 1:22 2:14 3:17 4:21 5:21 6:17 7:18 8:21 9:6 10:13 11:19 12:22 13:18 14:15
JDT 1:16 2:28 3:10 4:15 5:24 6:21 7:32 8:36 9:14 10:23 11:23 12:20 13:20 14:19 15:13 16:25
#-----------------------
# This is the definition for "Additions to Daniel" as in the KJV [Studge]
# ESG 1:13 2:12 3:6 4:18 5:19 6:16 7:24
# more commonly UBS Bibles have ESG which is the full Esther Greek for modern Bibles e.g. RSV, CEV, GNB etc
ESG 1:39 2:23 3:22 4:47 5:28 6:14 7:10 8:39 9:32 10:13
#-----------------------
WIS 1:16 2:24 3:19 4:20 5:23 6:25 7:30 8:21 9:18 10:21 11:26 12:27 13:19 14:31 15:19 16:29 17:21 18:25 19:22
SIR 1:30 2:18 3:31 4:31 5:15 6:37 7:36 8:19 9:18 10:31 11:34 12:18 13:26 14:27 15:20 16:30 17:32 18:33 19:30 20:32 21:28 22:27 23:27 24:34 25:26 26:29 27:30 28:26 29:28 30:25 31:31 32:24 33:31 34:26 35:20 36:26 37:31 38:34 39:35 40:30 41:23 42:25 43:33 44:23 45:26 46:20 47:25 48:25 49:16 50:29 51:30
#
# In English Bibles Baruch sometimes has 5 chapters and sometimes 6 in Catholic Bibles [Studge]
BAR 1:21 2:35 3:37 4:37 5:9 6:73
#
LJE 1:73
S3Y 1:68
SUS 1:64
BEL 1:42
1MA 1:64 2:70 3:60 4:61 5:68 6:63 7:50 8:32 9:73 10:89 11:74 12:53 13:53 14:49 15:41 16:24
2MA 1:36 2:32 3:40 4:50 5:27 6:31 7:42 8:36 9:29 10:38 11:38 12:45 13:26 14:46 15:39
#-----------------------------------------------------
# Additional Orthodox Books in Interconfessional Bibles e.g. RSV, NRSV
3MA 1:29 2:33 3:30 4:21 5:51 6:41 7:23
4MA 1:35 2:24 3:21 4:26 5:38 6:35 7:23 8:29 9:32 10:21 11:27 12:19 13:27 14:20 15:32 16:25 17:24 18:24
1ES 1:58 2:30 3:24 4:63 5:73 6:34 7:15 8:96 9:55
2ES 1:40 2:48 3:36 4:52 5:56 6:59 7:140 8:63 9:47 10:59 11:46 12:51 13:58 14:48 15:63 16:78
MAN 1:15
PS2 1:7
#-----------------------------------------------------
# ODA and PSS are only used in LXX and SYR projects and are not needed here
# ODA 1:19 2:43 3:10 4:19 5:12 6:8 7:20 8:37 9:22 10:9 11:11 12:15 13:4 14:46
# PSS 1:8 2:37 3:12 4:25 5:19 6:6 7:10 8:34 9:11 10:8 11:9 12:6 13:12 14:10 15:13 16:15 17:46 18:12
#-----------------------------------------------------
# Obselete books used for LXX variant texts, in LXX only in PT 6, and obselete in PT 7, not used in English, Spanish or any other Bibles.  If these codes were used they were used for the wrong books and these definitions were not relevant
JSA 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDB 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
TBS 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
SST 1:64
DNT 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
BLT 1:42
#------------------------------------------------------
# Daniel Greek used in some English Catholic Bibles
DAG 1:21 2:49 3:97 4:37 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13 13:64 14:42
# Letter to the Laodiceans which was in the John Wycliffe Bible
LAO 1:20
#
#-----------------------------------------------------
# Mapping
#-----------------------------------------------------
# English = BHS (see org.vrs)
#
# (Note: ranges must not span a chapter, e.g. 4:10-5:11 is illegal)
#
GEN 31:55 = GEN 32:1
GEN 32:1-32 = GEN 32:2-33
EXO 8:1-4 = EXO 7:26-29
EXO 8:5-32 = EXO 8:1-28
EXO 22:1 = EXO 21:37
EXO 22:2-31 = EXO 22:1-30
LEV 6:1-7 = LEV 5:20-26
LEV 6:8-30 = LEV 6:1-23
NUM 16:36-50 = NUM 17:1-15
NUM 17:1-13 = NUM 17:16-28
# NUM 26:1a = NUM 25:19b  # no support for splits yet
# NUM 26:1b = NUM 26:1  # no support for splits yet
NUM 29:40 = NUM 30:1
NUM 30:1-16 = NUM 30:2-17
DEU 12:32 = DEU 13:1
DEU 13:1-18 = DEU 13:2-19
DEU 22:30 = DEU 23:1
DEU 23:1-25 = DEU 23:2-26
DEU 29:1 = DEU 28:69
DEU 29:2-29 = DEU 29:1-28
#
# removed see PTSIL-113
#1SA 20:42 = 1SA 20:41
#
1SA 20:42 = 1SA 21:1
1SA 21:1-15 = 1SA 21:2-16
1SA 23:29 = 1SA 24:1
1SA 24:1-22 = 1SA 24:2-23
2SA 18:33 = 2SA 19:1
2SA 19:1-43 = 2SA 19:2-44
1KI 4:21-34 = 1KI 5:1-14
1KI 5:1-18 = 1KI 5:15-32
# 1KI 18:33a = 1KI 18:33  # no support for splits yet
# 1KI 18:33b = 1KI 18:34  # no support for splits yet
# 1KI 22:43a = 1KI 22:43b  # no support for splits yet
1KI 22:43-53 = 1KI 22:44-54
2KI 11:21 = 2KI 12:1
2KI 12:1-21 = 2KI 12:2-22
1CH 6:1-15 = 1CH 5:27-41
1CH 6:16-81 = 1CH 6:1-66
# 1CH 12:4b = 1CH 12:4  # no support for splits yet
1CH 12:4-40 = 1CH 12:5-41
2CH 2:1 = 2CH 1:18
2CH 2:2-18 = 2CH 2:1-17
2CH 14:1 = 2CH 13:23
2CH 14:2-15 = 2CH 14:1-14
NEH 4:1-6 = NEH 3:33-38
NEH 4:7-23 = NEH 4:1-17
NEH 7:69-73 = NEH 7:68-72
NEH 9:38 = NEH 10:1
NEH 10:1-39 = NEH 10:2-40
JOB 41:1-8 = JOB 40:25-32
JOB 41:9-34 = JOB 41:1-26
PSA 3:0-8 = PSA 3:1-9
PSA 4:0-8 = PSA 4:1-9
PSA 5:0-12 = PSA 5:1-13
PSA 6:0-10 = PSA 6:1-11
PSA 7:0-17 = PSA 7:1-18
PSA 8:0-9 = PSA 8:1-10
PSA 9:0-20 = PSA 9:1-21
PSA 12:0-8 = PSA 12:1-9
PSA 13:0-5 = PSA 13:1-6
PSA 18:0-50 = PSA 18:1-51
PSA 19:0-14 = PSA 19:1-15
PSA 20:0-9 = PSA 20:1-10
PSA 21:0-13 = PSA 21:1-14
PSA 22:0-31 = PSA 22:1-32
PSA 30:0-12 = PSA 30:1-13
PSA 31:0-24 = PSA 31:1-25
PSA 34:0-22 = PSA 34:1-23
PSA 36:0-12 = PSA 36:1-13
PSA 38:0-22 = PSA 38:1-23
PSA 39:0-13 = PSA 39:1-14
PSA 40:0-17 = PSA 40:1-18
PSA 41:0-13 = PSA 41:1-14
PSA 42:0-11 = PSA 42:1-12
PSA 44:0-26 = PSA 44:1-27
PSA 45:0-17 = PSA 45:1-18
PSA 46:0-11 = PSA 46:1-12
PSA 47:0-9 = PSA 47:1-10
PSA 48:0-14 = PSA 48:1-15
PSA 49:0-20 = PSA 49:1-21
PSA 51:0 = PSA 51:1
PSA 51:0 = PSA 51:2
PSA 51:1-19 = PSA 51:3-21
PSA 52:0 = PSA 52:1
PSA 52:0 = PSA 52:2
PSA 52:1-9 = PSA 52:3-11
PSA 53:0-6 = PSA 53:1-7
PSA 54:0 = PSA 54:1
PSA 54:0 = PSA 54:2
PSA 54:1-7 = PSA 54:3-9
PSA 55:0-23 = PSA 55:1-24
PSA 56:0-13 = PSA 56:1-14
PSA 57:0-11 = PSA 57:1-12
PSA 58:0-11 = PSA 58:1-12
PSA 59:0-17 = PSA 59:1-18
PSA 60:0 = PSA 60:1
PSA 60:0 = PSA 60:2
PSA 60:1-12 = PSA 60:3-14
PSA 61:0-8 = PSA 61:1-9
PSA 62:0-12 = PSA 62:1-13
PSA 63:0-11 = PSA 63:1-12
PSA 64:0-10 = PSA 64:1-11
PSA 65:0-13 = PSA 65:1-14
PSA 67:0-7 = PSA 67:1-8
PSA 68:0-35 = PSA 68:1-36
PSA 69:0-36 = PSA 69:1-37
PSA 70:0-5 = PSA 70:1-6
PSA 75:0-10 = PSA 75:1-11
PSA 76:0-12 = PSA 76:1-13
PSA 77:0-20 = PSA 77:1-21
PSA 80:0-19 = PSA 80:1-20
PSA 81:0-16 = PSA 81:1-17
PSA 83:0-18 = PSA 83:1-19
PSA 84:0-12 = PSA 84:1-13
PSA 85:0-13 = PSA 85:1-14
PSA 88:0-18 = PSA 88:1-19
PSA 89:0-52 = PSA 89:1-53
PSA 92:0-15 = PSA 92:1-16
PSA 102:0-28 = PSA 102:1-29
PSA 108:0-13 = PSA 108:1-14
PSA 140:0-13 = PSA 140:1-14
PSA 142:0-7 = PSA 142:1-8
ECC 5:1 = ECC 4:17
ECC 5:2-20 = ECC 5:1-19
SNG 6:13 = SNG 7:1
SNG 7:1-13 = SNG 7:2-14
ISA 9:1 = ISA 8:23
ISA 9:2-21 = ISA 9:1-20
ISA 64:2-12 = ISA 64:1-11
JER 9:1 = JER 8:23
JER 9:2-26 = JER 9:1-25
EZK 20:45-46 = EZK 21:1-2
EZK 20:47 = EZK 21:3
EZK 20:48-49 = EZK 21:4-5
EZK 21:1-32 = EZK 21:6-37
DAN 4:1-3 = DAN 3:31-33
DAN 4:4-37 = DAN 4:1-34
DAN 5:31 = DAN 6:1
DAN 6:1-28 = DAN 6:2-29
HOS 1:10-11 = HOS 2:1-2
HOS 2:1-23 = HOS 2:3-25
HOS 11:12 = HOS 12:1
HOS 12:1-14 = HOS 12:2-15
HOS 13:16 = HOS 14:1
HOS 14:1-9 = HOS 14:2-10
JOL 2:28-32 = JOL 3:1-5
JOL 3:1-21 = JOL 4:1-21
JON 1:17 = JON 2:1
JON 2:1-10 = JON 2:2-11
MIC 5:1 = MIC 4:14
MIC 5:2-15 = MIC 5:1-14
NAM 1:15 = NAM 2:1
NAM 2:1-13 = NAM 2:2-14
ZEC 1:18-21 = ZEC 2:1-4
ZEC 2:1-13 = ZEC 2:5-17
MAL 4:1-6 = MAL 3:19-24
# 40 + 41 -> 40 (per Peter Kirk)
#! &ACT 19:40-41 = ACT 19:40
#
#---------------------------------
# map Baruch 6 onto Letter of Jeremiah [Studge]
BAR 6:1-73 = LJE 1:1-73
#
#------------------------------
# Susanna
DAG 13:1-63 = SUS 1:1-63
# Bel and the Dragon
DAG 14:1-42 = BEL 1:1-42
#----------------------------------
# Mapping Esther Greek onto LXX Esther Greek
#
# This maps the standard verses generated by Create Book
# to the actual verse numbers and segments found in the LXX
# ESG chapter 1
ESG 1:1 = ESG 1:1a
ESG 1:2 = ESG 1:1b
ESG 1:3 = ESG 1:1c
ESG 1:4 = ESG 1:1d
ESG 1:5 = ESG 1:1e
ESG 1:6 = ESG 1:1f
ESG 1:7 = ESG 1:1g
ESG 1:8 = ESG 1:1h
ESG 1:9 = ESG 1:1i
ESG 1:10 = ESG 1:1k
ESG 1:11 = ESG 1:1l
ESG 1:12 = ESG 1:1m
ESG 1:13 = ESG 1:1n
ESG 1:14 = ESG 1:1o
ESG 1:15 = ESG 1:1p
ESG 1:16 = ESG 1:1q
ESG 1:17 = ESG 1:1r
ESG 1:18 = ESG 1:1s
ESG 1:19-39 = ESG 1:2-22
# ESG chapter 3
ESG 3:14 = ESG 3:13a
ESG 3:15 = ESG 3:13b
ESG 3:16 = ESG 3:13c
ESG 3:17 = ESG 3:13d
ESG 3:18 = ESG 3:13e
ESG 3:19 = ESG 3:13f
ESG 3:20 = ESG 3:13g
ESG 3:21 = ESG 3:14
ESG 3:22 = ESG 3:15
# ESG chapter 4
ESG 4:18 = ESG 4:17a
ESG 4:19 = ESG 4:17b
ESG 4:20 = ESG 4:17c
ESG 4:21 = ESG 4:17c
ESG 4:22 = ESG 4:17d
ESG 4:23 = ESG 4:17d
ESG 4:24 = ESG 4:17e
ESG 4:25 = ESG 4:17f
ESG 4:26 = ESG 4:17g
ESG 4:27 = ESG 4:17h
ESG 4:28 = ESG 4:17i
ESG 4:29 = ESG 4:17k
ESG 4:30 = ESG 4:17k
ESG 4:31 = ESG 4:17k
ESG 4:32 = ESG 4:17l
ESG 4:33 = ESG 4:17m
ESG 4:34 = ESG 4:17n
ESG 4:35 = ESG 4:17n
ESG 4:36 = ESG 4:17o
ESG 4:37 = ESG 4:17o
ESG 4:38 = ESG 4:17p
ESG 4:39 = ESG 4:17q
ESG 4:40 = ESG 4:17r
ESG 4:41 = ESG 4:17s
ESG 4:42 = ESG 4:17t
ESG 4:43 = ESG 4:17u
ESG 4:44 = ESG 4:17w
ESG 4:45 = ESG 4:17x
ESG 4:46 = ESG 4:17y
ESG 4:47 = ESG 4:17z
# ESG chapter 5
ESG 5:2 = ESG 5:1a
ESG 5:3 = ESG 5:1a
ESG 5:4 = ESG 5:1a
ESG 5:5 = ESG 5:1b
ESG 5:6 = ESG 5:1c
ESG 5:7 = ESG 5:1d
ESG 5:8 = ESG 5:1e
ESG 5:9 = ESG 5:1f
ESG 5:10 = ESG 5:1f
ESG 5:11 = ESG 5:2
ESG 5:12 = ESG 5:2
ESG 5:13 = ESG 5:2a
ESG 5:14 = ESG 5:2a
ESG 5:15 = ESG 5:2b
ESG 5:16 = ESG 5:2b
ESG 5:17-28 = ESG 5:3-14
# ESG chapter 8
ESG 8:13 = ESG 8:12a
ESG 8:14 = ESG 8:12b
ESG 8:15 = ESG 8:12c
ESG 8:16 = ESG 8:12d
ESG 8:17 = ESG 8:12e
ESG 8:18 = ESG 8:12f
ESG 8:19 = ESG 8:12g
ESG 8:20 = ESG 8:12h
ESG 8:21 = ESG 8:12i
ESG 8:22 = ESG 8:12k
ESG 8:23 = ESG 8:12l
ESG 8:24 = ESG 8:12m
ESG 8:25 = ESG 8:12n
ESG 8:26 = ESG 8:12o
ESG 8:27 = ESG 8:12p
ESG 8:28 = ESG 8:12q
ESG 8:29 = ESG 8:12r
ESG 8:30 = ESG 8:12s
ESG 8:31 = ESG 8:12t
ESG 8:32 = ESG 8:12u
ESG 8:33 = ESG 8:12x
ESG 8:34 = ESG 8:12y
ESG 8:35 = ESG 8:12y
ESG 8:36 = ESG 8:12y
ESG 8:37-41 = ESG 8:13-17
# ESG chapter 10
ESG 10:4 = ESG 10:3a
ESG 10:5 = ESG 10:3b
ESG 10:6 = ESG 10:3c
ESG 10:7 = ESG 10:3d
ESG 10:8 = ESG 10:3e
ESG 10:9 = ESG 10:3f
ESG 10:10 = ESG 10:3g
ESG 10:11 = ESG 10:3h
ESG 10:12 = ESG 10:3i
ESG 10:13 = ESG 10:3k
ESG 10:14 = ESG 10:3l
# S3Y is a small section of the DAG LXX pulled out and translated as a separate book.
# Map it back to the LXX.  This section allow's texts such as TOB (French) which do
# this to scroll correctly with the LXX.
# S3Y is not present in the GRK, HEB, or LXX(Ralphs) text.
# If a text has DAG present, this section must NOT be included in its versification file because
# that would cause references in other texts to DAG to be redirected to a non-existant S3Y.
S3Y 1:1-29 = DAG 3:24-52
S3Y 1:30-31 = DAG 3:52-53
S3Y 1:33 = DAG 3:54
S3Y 1:32 = DAG 3:55
S3Y 1:34-35 = DAG 3:56-57
S3Y 1:37 = DAG 3:58
S3Y 1:36 = DAG 3:59
S3Y 1:38-68 = DAG 3:60-90
`;
    module.exports = vrs;
  }
});

// node_modules/proskomma-core/src/model/versifications/lxx_vrs.cjs
var require_lxx_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/lxx_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = `# Versification  "Septuagint"
# Version=1.7
# 
# modifications by Studge 26/ June/ 2009
# This should include the versifications for Bibles which follow LXX versificatio mainly Orthodox Bibles. [Studge]
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
# modifications by Reinier 20/ April/ 2010
# all data that are not part of the LXX itself have been commented out with ##
#
# modifications by Michael Lothers 1/ June/ 2011
# added verse segment information in the format: *GEN 1:22,-,a,b
# which indicates GEN 1:22 has three segments, the first has no marking followed by two segments: 1a and 1b
# The lines are preceded by #! so that versions of Paratext prior to 7.3 will ignore them rather than crash.
#
# modifications by Tim Steenwyk 15/ September/ 2011
# removed mapping references to PS3 since they shouldn't be in LXX (Septuagint)
#------------------------------------------------
# Old Testament
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:54 32:33 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:33 50:26
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:29 8:28 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:37 22:30 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:21 38:27 39:23 40:38
LEV 1:17 2:16 3:17 4:35 5:26 6:23 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:57 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:46 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:26 7:89 8:26 9:23 10:36 11:35 12:16 13:33 14:45 15:41 16:35 17:28 18:32 19:22 20:29 21:35 22:41 23:30 24:25 25:18 26:65 27:23 28:31 29:39 30:17 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:31 13:19 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:29 23:26 24:22 25:19 26:19 27:26 28:69 29:28 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:29 9:27 10:42 11:23 12:24 13:32 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDG 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:54 18:29 19:24 20:42 21:16 22:23 23:28 24:23 25:44 26:25 27:12 28:25 29:11 30:31 31:13
# 1SA called 1 Kings in the Orthodox tradition
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:32 19:44 20:26 21:22 22:51 23:39 24:25
# 2SA called 2 Kings in the Orthodox tradition
1KI 1:53 2:46 3:28 4:19 5:32 6:36 7:50 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:29 21:43 22:54
# 1KI called 3 Kings in the Orthodox tradition
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:20 12:22 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
# 2KI called 4 Kings in the Orthodox tradition
1CH 1:54 2:55 3:24 4:43 5:41 6:66 7:40 8:40 9:44 10:14 11:47 12:41 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:8 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:18 2:17 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:23 14:14 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23
#
# Edited by Studge
# Added EZR which is Ezra-Nehemiah, which had been put under 2ES by mistake
# Edited chapters 13 and 20 / SS 14.6.2014
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44 11:11 12:20 13:37 14:23 15:19 16:19 17:73 18:18 19:38 20:40 21:36 22:47 23:31
#
# most projects based on LXX will use Nehemiah so we ought to add it in.
##NEH 1:11 2:20 3:32 4:23 5:19 6:19 7:73 8:18 9:38 10:39 11:36 12:47 13:31
#
# Edited by Studge
# should not have ESG here but amongst the Deuterocanonical books for PT order
# ESG 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
#
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:22 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:30 40:32 41:26 42:17
PSA 1:6 2:12 3:9 4:9 5:13 6:11 7:18 8:10 9:39 10:7 11:9 12:6 13:7 14:5 15:11 16:15 17:51 18:15 19:10 20:14 21:32 22:6 23:10 24:22 25:12 26:14 27:9 28:11 29:13 30:25 31:11 32:22 33:23 34:28 35:13 36:40 37:23 38:14 39:18 40:14 41:12 42:5 43:27 44:18 45:12 46:10 47:15 48:21 49:23 50:21 51:11 52:7 53:9 54:24 55:14 56:12 57:12 58:18 59:14 60:9 61:13 62:12 63:11 64:14 65:20 66:8 67:36 68:37 69:6 70:24 71:20 72:28 73:23 74:11 75:13 76:21 77:72 78:13 79:20 80:17 81:8 82:19 83:13 84:14 85:17 86:7 87:19 88:53 89:17 90:16 91:16 92:5 93:23 94:11 95:13 96:12 97:9 98:9 99:5 100:8 101:29 102:22 103:35 104:45 105:48 106:43 107:14 108:31 109:7 110:10 111:10 112:9 113:26 114:9 115:10 116:2 117:29 118:176 119:7 120:8 121:9 122:4 123:8 124:5 125:6 126:5 127:6 128:8 129:8 130:3 131:18 132:3 133:3 134:21 135:26 136:9 137:8 138:24 139:14 140:10 141:8 142:12 143:15 144:21 145:10 146:11 147:9 148:14 149:9 150:6 151:7
# Psalms has 151 psalms in the Septuagint tradition
PRO 1:33 2:22 3:35 4:27 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:25 14:35 15:33 16:33 17:28 18:22 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:17 5:19 6:12 7:29 8:17 9:18 10:20 11:10 12:14
SNG 1:17 2:17 3:11 4:16 5:16 6:12 7:14 8:14
ISA 1:31 2:21 3:26 4:6 5:30 6:13 7:25 8:23 9:20 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:11 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:11 65:25 66:24
#
# Edited by SS 25.3.2003
# Original: JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:23 9:25 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:21 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
#
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:23 9:25 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:20 26:28 27:46 28:64 29:7 30:33 31:44 32:38 33:24 34:22 35:17 36:32 37:24 38:40 39:44 40:13 41:22 42:19 43:32 44:21 45:28 46:18 47:16 48:18 49:22 50:13 51:35 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:10 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:44 21:37 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
#
# There really should not be an entry for DAN in the LXX.vrs. All this material should be in DAG to match Ralhfs.
# However, there are no doubt many projects that incorrectly but the material in DAN so we leave this here
# for backward compatibility
# Following line commented out and DAG-DAN mapping brought up from end of file to allow DAG text to sychronize with HEB where they match
# Edited by Sarah Lind Oct 6 2015
# DAN 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
DAG 1:1-21 = DAN 1:1-21 
DAG 2:1-49 = DAN 2:1-49
DAG 3:1-23 = DAN 3:1-23
DAG 3:91-97 = DAN 3:24-30
DAG 4:1-3 = DAN 3:31-33
DAG 4:4-37 = DAN 4:1-34
DAG 4:1-2 = DAN 4:4-5
DAG 5:1-30 = DAN 5:1-30
DAG 6:1-29 = DAN 6:1-29
DAG 7:1-28 = DAN 7:1-28
DAG 8:1-27 = DAN 8:1-27
DAG 9:1-27 = DAN 9:1-27
DAG 10:1-21 = DAN 10:1-21
DAG 11:1-45 = DAN 11:1-45
DAG 12:1-13 = DAN 12:1-13
#
HOS 1:9 2:25 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:11 12:15 13:15 14:10
JOL 1:20 2:27 3:5 4:21
AMO 1:15 2:16 3:15 4:13 5:27 6:14 7:17 8:14 9:15
OBA 1:21
JON 1:16 2:11 3:10 4:11
MIC 1:16 2:13 3:12 4:14 5:14 6:16 7:20
NAM 1:14 2:14 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:15 2:23
ZEC 1:17 2:17 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:24
#
#  It feels a bit odd to include NT in "Septuagint" but I think there are
#  Bibles that follow the _versification_ of OT LXX but also have a NT.
#
# ------------------------------------------------------
# New Testament books
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:27 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:41 5:43 6:56 7:37 8:38 9:50 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:71 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:60 8:40 9:43 10:48 11:30 12:25 13:52 14:28 15:41 16:40 17:34 18:28 19:40 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:23 15:33 16:27
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:33 12:21 13:13
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:18 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
#--------------------------------------------------
# Deuterocanonical Books
TOB 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
JDT 1:16 2:28 3:10 4:15 5:24 6:21 7:32 8:36 9:14 10:23 11:23 12:20 13:20 14:19 15:14 16:25
# added ESG definition in its right PT order
ESG 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
# note chapter 4 v17 is 17a-z
# note chapter 8 v12 is 12a-x
# note chapter 10 v3 is 3a-l
WIS 1:16 2:24 3:19 4:20 5:23 6:25 7:30 8:21 9:18 10:21 11:26 12:27 13:19 14:31 15:19 16:29 17:20 18:25 19:22
SIR 1:30 2:18 3:31 4:31 5:15 6:37 7:36 8:19 9:18 10:31 11:34 12:18 13:26 14:27 15:20 16:30 17:32 18:33 19:30 20:31 21:28 22:27 23:27 24:34 25:26 26:29 27:30 28:26 29:28 30:25 31:31 32:24 33:33 34:26 35:24 36:27 37:31 38:34 39:35 40:30 41:27 42:25 43:33 44:23 45:26 46:20 47:25 48:25 49:16 50:29 51:30
BAR 1:22 2:35 3:38 4:37 5:9
LJE 1:72
# Edited SUS / SS 14.6.2014
SUS 1:64
BEL 1:42
1MA 1:64 2:70 3:60 4:61 5:68 6:63 7:50 8:32 9:73 10:89 11:74 12:53 13:53 14:49 15:41 16:24
2MA 1:36 2:32 3:40 4:50 5:27 6:31 7:42 8:36 9:29 10:38 11:38 12:45 13:26 14:46 15:39
3MA 1:29 2:33 3:30 4:21 5:51 6:41 7:23
4MA 1:35 2:24 3:21 4:26 5:38 6:35 7:23 8:29 9:32 10:21 11:27 12:19 13:27 14:20 15:32 16:25 17:24 18:24
# 1ES Ezra (Greek)
1ES 1:55 2:26 3:24 4:63 5:71 6:33 7:15 8:92 9:55
#-----------------------------------------------------
# Edited by Studge - Had the wrong definition of 2ES
# 2ES 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44 11:11 12:20 13:37 14:17 15:19 16:19 17:73 18:18 19:37 20:40 21:36 22:47 23:31
# 2ES is not a LXX book but is from the Vulgate and has 16 chapters
# edited by Studge added the correct definition of 2ES
2ES 1:40 2:48 3:36 4:52 5:56 6:59 7:140 8:63 9:47 10:59 11:46 12:51 13:58 14:48 15:63 16:78
#
# Edited by Studge
#MAN and PS2 were not defined which are in LXX
MAN 1:15
PS2 1:7
#-------------------------------------------------------
# ODA and PSS are in the PT 6 files but now missing from the LXX files in PT 7
ODA 1:19 2:43 3:10 4:19 5:12 6:8 7:20 8:37 9:22 10:9 11:11 12:15 13:4 14:46
PSS 1:8 2:37 3:12 4:25 5:19 6:6 7:10 8:34 9:11 10:8 11:9 12:6 13:12 14:10 15:13 16:15 17:46 18:12
#-------------------------------------------------------
# NR: LXX variant texts now obselete, kep for backward compatability
JSA 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:45 20:9 21:45 22:34 23:16 24:33
JDB 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
TBS 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
SST 1:64
DNT 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
BLT 1:42
#--------------------------------------------------------
# Greek Daniel
# Edited chapter 5 and 6 and removed chapters 13 and 14 that are not in Rahlfs / SS 14.6.2014
DAG 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
#--------------------------------------------------------
# Syriac books for Peshitta projects SYR and SYA
#
# Syriac Psalms 152-155
##PS3 1:17 2:20 3:6 4:6
#
# Apocalypse of Baruch
##2BA 1:5 2:2 3:9 4:7 5:7 6:10 7:2 8:5 9:1 10:19 11:7 12:5 13:12 14:19 15:8 16:1 17:4 18:2 19:8 20:6 21:26 22:8 23:7 24:4 25:4 26:1 27:15 28:7 29:8 30:5 31:5 32:9 33:3 34:1 35:5 36:10 37:1 38:4 39:8 40:4 41:6 42:8 43:3 44:15 45:2 46:7 47:2 48:50 49:3 50:4 51:16 52:8 53:12 54:22 55:8 56:16 57:3 58:2 59:12 60:2 61:8 62:8 63:11 64:10 65:2 66:8 67:9 68:8 69:5 70:10 71:3 72:6 73:7 74:4 75:8 76:5 77:26
#
# Letter of Baruch
##LBA 78:7 79:3 80:7 81:4 82:9 83:23 84:11 85:15 86:3
#--------------------------------------------------------
# Books for Ethiopian Canon
# Jubilees (Ethiopian canon)
##JUB 1:26 2:17 3:19 4:24 5:36 6:34 7:37 8:40 9:27 10:48 11:39 12:56 13:34 14:55 15:20 16:28 17:30 18:31 19:59 20:66 21:30 22:38 23:59 24:30 25:50 26:48 27:37 28:38 29:27 30:29 31:31 32:24 33:30 34:20
# Enoch (Ethiopian canon)
##ENO 1:28 2:42 3:30 4:88 5:40 6:42 7:39 8:46 9:42 10:16 11:19 12:40 13:34 14:35 15:45 16:41 17:69 18:42 19:29 20:53 21:57 22:14 23:26 24:16 25:30 26:37 27:21 28:34 29:28 30:23 31:29 32:82 33:59 34:49 35:36 36:30 37:34 38:36 39:24 40:40 41:22 42:16
# 1 Meqabyan (Ethiopian canon)
##1MQ 1:28 2:28 3:38 4:37 5:39 6:38 7:33 8:35 9:10 10:8 11:8 12:44 13:27 14:23 15:20 16:9 17:8 18:12 19:17 20:4 21:31 22:11 23:7 4:22 25:18 26:5 27:20 28:49 29:17 30:16 31:7 32:4 33:11 34:18 35:8 36:46
# 2 Meqabyan (Ethiopian canon)
##2MQ 1:13 2:11 3:29 4:32 5:18 6:24 7:9 8:24 9:27 10:28 11:25 12:15 13:14 14:36 15:21 16:15 17:12 18:14 19:15 20:14 
# 3 Meqabyan (Ethiopian canon)
##3MQ 1:24 2:23 3:11 4:36 5:16 6:16 7:5 8:12 9:36 10:29
# Reproof (Ethiopian canon)
##REP 1:28 2:28 3:27 4:28 5:27 6:22
# 4 Baruch / Rest of the Words of Baruch (Ethiopian canon)
##4BA 1:30 2:29 3:30 4:33 5:62
#---------------------------------------------------------
# Edited by SS 14.6.2014 added deliberatelly omitted verses
-GEN 31:51
-GEN 35:21

-EXO 25:6
-EXO 28:23
-EXO 28:24
-EXO 28:25
-EXO 28:26
-EXO 28:27
-EXO 28:28
-EXO 32:9
-EXO 35:8
-EXO 35:15
-EXO 35:17
-EXO 35:18
-EXO 40:7
-EXO 40:11
-EXO 40:28
-EXO 40:30
-EXO 40:31
-EXO 40:32

-JOS 6:4
-JOS 8:13
-JOS 8:26
-JOS 10:15
-JOS 20:4
-JOS 20:5
-JOS 20:6

-1SA 13:1
-1SA 17:21
-1SA 17:22
-1SA 17:23
-1SA 17:24
-1SA 17:25
-1SA 17:26
-1SA 17:27
-1SA 17:28
-1SA 17:29
-1SA 17:30
-1SA 17:31
-1SA 17:41
-1SA 17:50
-1SA 18:1
-1SA 18:2
-1SA 18:3
-1SA 18:4
-1SA 18:5
-1SA 18:10
-1SA 18:11
-1SA 18:17
-1SA 18:18
-1SA 18:19
-1SA 23:12

-1KI 3:1
-1KI 5:5
-1KI 5:6
-1KI 5:7
-1KI 5:8
-1KI 5:31
-1KI 6:11
-1KI 6:12
-1KI 6:13
-1KI 6:14
-1KI 6:18
-1KI 8:12
-1KI 8:13
-1KI 9:15
-1KI 9:16
-1KI 9:17
-1KI 9:18
-1KI 9:19
-1KI 9:20
-1KI 9:21
-1KI 9:22
-1KI 9:23
-1KI 9:24
-1KI 9:25
-1KI 11:3
-1KI 11:23
-1KI 11:24
-1KI 11:39
-1KI 12:2
-1KI 12:17
-1KI 13:27
-1KI 14:1
-1KI 14:2
-1KI 14:3
-1KI 14:4
-1KI 14:5
-1KI 14:6
-1KI 14:7
-1KI 14:8
-1KI 14:9
-1KI 14:10
-1KI 14:11
-1KI 14:12
-1KI 14:13
-1KI 14:14
-1KI 14:15
-1KI 14:16
-1KI 14:17
-1KI 14:18
-1KI 14:19
-1KI 14:20
-1KI 15:6
-1KI 15:32
-1KI 22:47
-1KI 22:48
-1KI 22:49
-1KI 22:50

-1SA 17:12
-1SA 17:13
-1SA 17:14
-1SA 17:15
-1SA 17:16
-1SA 17:17
-1SA 17:18
-1SA 17:19
-1SA 17:20

-1CH 1:11
-1CH 1:12
-1CH 1:13
-1CH 1:14
-1CH 1:15
-1CH 1:16
-1CH 1:18
-1CH 1:19
-1CH 1:20
-1CH 1:21
-1CH 1:22
-1CH 1:23
-1CH 16:24

-2CH 27:8

-EZR 13:7
-EZR 14:18
-EZR 14:19
-EZR 14:20
-EZR 14:21
-EZR 14:22
-EZR 14:23
-EZR 19:38
-EZR 21:16
-EZR 21:20
-EZR 21:21
-EZR 21:28
-EZR 21:29
-EZR 21:32
-EZR 21:33
-EZR 21:34
-EZR 21:35
-EZR 22:4
-EZR 22:5
-EZR 22:6

-JOB 23:14

-PSA 115:5

-PRO 4:7
-PRO 8:33
-PRO 11:4
-PRO 15:31
-PRO 16:1
-PRO 16:3
-PRO 16:4
-PRO 16:6
-PRO 19:1
-PRO 19:2
-PRO 20:14
-PRO 20:15
-PRO 20:16
-PRO 20:17
-PRO 20:18
-PRO 20:19
-PRO 20:20
-PRO 20:21
-PRO 20:22
-PRO 21:5
-PRO 22:6
-PRO 23:23

-JER 2:1
-JER 7:1
-JER 8:11
-JER 8:12
-JER 10:6
-JER 10:7
-JER 10:8
-JER 10:10
-JER 11:7
-JER 17:1
-JER 17:2
-JER 17:3
-JER 17:4
-JER 26:1
-JER 26:26
-JER 28:45
-JER 28:46
-JER 28:47
-JER 28:48
-JER 30:22
-JER 32:1
-JER 32:2
-JER 32:3
-JER 32:4
-JER 32:5
-JER 32:6
-JER 32:7
-JER 32:8
-JER 32:9
-JER 32:10
-JER 32:11
-JER 32:12
-JER 32:14
-JER 34:1
-JER 34:7
-JER 34:13
-JER 34:17
-JER 34:21
-JER 36:16
-JER 36:17
-JER 36:18
-JER 36:19
-JER 36:20
-JER 37:10
-JER 37:11
-JER 37:15
-JER 37:22
-JER 46:4
-JER 46:5
-JER 46:6
-JER 46:7
-JER 46:8
-JER 46:9
-JER 46:10
-JER 46:11
-JER 46:12
-JER 46:13
-JER 52:2
-JER 52:3
-JER 52:15
-JER 52:28
-JER 52:29
-JER 52:30

-LAM 3:22
-LAM 3:23
-LAM 3:24
-LAM 3:29

-EZK 1:14
-EZK 10:14
-EZK 27:31
-EZK 32:19
-EZK 33:26
-EZK 40:30

#------------- DC books ------------

-TOB 4:8
-TOB 4:9
-TOB 4:10
-TOB 4:11
-TOB 4:12
-TOB 4:13
-TOB 4:14
-TOB 4:15
-TOB 4:16
-TOB 4:17
-TOB 4:18
-TOB 13:8
-TOB 13:9
-TOB 13:10

-ESG 4:6
-ESG 9:5
-ESG 9:30

-SIR 1:5
-SIR 1:7
-SIR 1:21
-SIR 3:19
-SIR 3:25
-SIR 6:1
-SIR 10:21
-SIR 11:15
-SIR 11:16
-SIR 13:14
-SIR 16:15
-SIR 16:16
-SIR 17:5
-SIR 17:9
-SIR 17:16
-SIR 17:18
-SIR 17:21
-SIR 18:3
-SIR 19:18
-SIR 19:19
-SIR 19:21
-SIR 22:7
-SIR 22:8
-SIR 24:18
-SIR 24:24
-SIR 25:12
-SIR 26:19
-SIR 26:20
-SIR 26:21
-SIR 26:22
-SIR 26:23
-SIR 26:24
-SIR 26:25
-SIR 26:26
-SIR 26:27

-4MA 10:4
-4MA 11:7
-4MA 11:8

#---------------------------------------------------------
# Mapping
# LXX = BHS (see org.vrs)
#
# (Note: for performance reasons ranges must not span a chapter, e.g. 4:10-5:11 is illegal)
#
# 2ES = EZR and NEH
#
EXO 20:13 = EXO 20:14
EXO 20:14 = EXO 20:15
EXO 20:15 = EXO 20:13
EXO 21:16 = EXO 21:17
EXO 21:17 = EXO 21:16
EXO 36:9 = EXO 39:2
EXO 36:10 = EXO 39:3
EXO 36:11 = EXO 39:4
EXO 36:12 = EXO 39:5
EXO 36:13 = EXO 39:6
EXO 36:14 = EXO 39:7
EXO 36:15 = EXO 39:8
EXO 36:16 = EXO 39:9
EXO 36:17 = EXO 39:10
EXO 36:20 = EXO 39:13
EXO 36:21 = EXO 39:14
EXO 36:22 = EXO 39:15
EXO 36:23 = EXO 39:16
EXO 36:25 = EXO 39:17
EXO 36:26 = EXO 39:18
EXO 36:27 = EXO 39:19
EXO 36:28 = EXO 39:20
EXO 36:29 = EXO 39:21
EXO 36:30 = EXO 39:22
EXO 36:31 = EXO 39:23
EXO 36:32 = EXO 39:24
EXO 36:33 = EXO 39:25
EXO 36:34 = EXO 39:26
EXO 36:35 = EXO 39:27
EXO 36:36 = EXO 39:28
EXO 36:37 = EXO 39:29
EXO 36:38 = EXO 39:30

DEU 5:17 = DEU 5:18
DEU 5:18 = DEU 5:17

1KI 20:1-29 = 1KI 21:1-29 
1KI 21:1-43 = 1KI 20:1-43

#
# Map The Greek versioin of Esther onto the Hebrew version of Esther
# using the Hebrew version as the reference point.
# Normally DC material would not have any entries in this part of the lxx.vrs file
# because the LXX serves as the reference point for DC material.
# Material which is placed in separate books in HEB and LXX (i.e. EST and ESG)
# is however placed here and referenced to the HEB reference points.
ESG 1:1-22 = EST 1:1-22
ESG 2:1-23 = EST 2:1-23
ESG 3:1-15 = EST 3:1-15
ESG 4:1-17 = EST 4:1-17
ESG 5:1-14 = EST 5:1-14
ESG 6:1-14 = EST 6:1-14
ESG 7:1-10 = EST 7:1-10
ESG 8:1-17 = EST 8:1-17
ESG 9:1-32 = EST 9:1-32
ESG 10:1-3 = EST 10:1-3
#
# PSA 9 = 9+10
PSA 9:22 = PSA 10:0
PSA 9:22-39 = PSA 10:1-18
PSA 10:0-7 = PSA 11:0-7
PSA 11:0-9 = PSA 12:0-9
PSA 12:0-6 = PSA 13:0-6
PSA 13:0-7 = PSA 14:0-7
PSA 14:0-5 = PSA 15:0-5
PSA 15:0-11 = PSA 16:0-11
PSA 16:0-15 = PSA 17:0-15
PSA 17:0-51 = PSA 18:0-51
PSA 18:0-15 = PSA 19:0-15
PSA 19:0-10 = PSA 20:0-10
PSA 20:0-14 = PSA 21:0-14
PSA 21:0-32 = PSA 22:0-32
PSA 22:0-6 = PSA 23:0-6
PSA 23:0-10 = PSA 24:0-10
PSA 24:0-22 = PSA 25:0-22
PSA 25:0-12 = PSA 26:0-12
PSA 26:0-14 = PSA 27:0-14
PSA 27:0-9 = PSA 28:0-9
PSA 28:0-11 = PSA 29:0-11
PSA 29:0-13 = PSA 30:0-13
PSA 30:0-25 = PSA 31:0-25
PSA 31:0-11 = PSA 32:0-11
PSA 32:0-22 = PSA 33:0-22
PSA 33:0-23 = PSA 34:0-23
PSA 34:0-28 = PSA 35:0-28
PSA 35:0-13 = PSA 36:0-13
PSA 36:0-40 = PSA 37:0-40
PSA 37:0-23 = PSA 38:0-23
PSA 38:0-14 = PSA 39:0-14
PSA 39:0-18 = PSA 40:0-18
PSA 40:0-14 = PSA 41:0-14
PSA 41:0-12 = PSA 42:0-12
PSA 42:0-5 = PSA 43:0-5
PSA 43:0-27 = PSA 44:0-27
PSA 44:0-18 = PSA 45:0-18
PSA 45:0-12 = PSA 46:0-12
PSA 46:0-10 = PSA 47:0-10
PSA 47:0-15 = PSA 48:0-15
PSA 48:0-21 = PSA 49:0-21
PSA 49:0-23 = PSA 50:0-23
PSA 50:0-21 = PSA 51:0-21
PSA 51:0-11 = PSA 52:0-11
PSA 52:0-7 = PSA 53:0-7
PSA 53:0-9 = PSA 54:0-9
PSA 54:0-24 = PSA 55:0-24
PSA 55:0-14 = PSA 56:0-14
PSA 56:0-12 = PSA 57:0-12
PSA 57:0-12 = PSA 58:0-12
PSA 58:0-18 = PSA 59:0-18
PSA 59:0-14 = PSA 60:0-14
PSA 60:0-9 = PSA 61:0-9
PSA 61:0-13 = PSA 62:0-13
PSA 62:0-12 = PSA 63:0-12
PSA 63:0-11 = PSA 64:0-11
PSA 64:0-14 = PSA 65:0-14
PSA 65:0-20 = PSA 66:0-20
PSA 66:0-8 = PSA 67:0-8
PSA 67:0-36 = PSA 68:0-36
PSA 68:0-37 = PSA 69:0-37
PSA 69:0-6 = PSA 70:0-6
PSA 70:0-24 = PSA 71:0-24
PSA 71:0-20 = PSA 72:0-20
PSA 72:0-28 = PSA 73:0-28
PSA 73:0-23 = PSA 74:0-23
PSA 74:0-11 = PSA 75:0-11
PSA 75:0-13 = PSA 76:0-13
PSA 76:0-21 = PSA 77:0-21
PSA 77:0-72 = PSA 78:0-72
PSA 78:0-13 = PSA 79:0-13
PSA 79:0-20 = PSA 80:0-20
PSA 80:0-17 = PSA 81:0-17
PSA 81:0-8 = PSA 82:0-8
PSA 82:0-19 = PSA 83:0-19
PSA 83:0-13 = PSA 84:0-13
PSA 84:0-14 = PSA 85:0-14
PSA 85:0-17 = PSA 86:0-17
PSA 86:0-7 = PSA 87:0-7
PSA 87:0-19 = PSA 88:0-19
PSA 88:0-53 = PSA 89:0-53
PSA 89:0-17 = PSA 90:0-17
PSA 90:0-16 = PSA 91:0-16
PSA 91:0-16 = PSA 92:0-16
PSA 92:0-5 = PSA 93:0-5
PSA 93:0-23 = PSA 94:0-23
PSA 94:0-11 = PSA 95:0-11
PSA 95:0-13 = PSA 96:0-13
PSA 96:0-12 = PSA 97:0-12
PSA 97:0-9 = PSA 98:0-9
PSA 98:0-9 = PSA 99:0-9
PSA 99:0-5 = PSA 100:0-5
PSA 100:0-8 = PSA 101:0-8
PSA 101:0-29 = PSA 102:0-29
PSA 102:0-22 = PSA 103:0-22
PSA 103:0-35 = PSA 104:0-35
PSA 104:0-45 = PSA 105:0-45
PSA 105:0-48 = PSA 106:0-48
PSA 106:0-43 = PSA 107:0-43
PSA 107:0-14 = PSA 108:0-14
PSA 108:0-31 = PSA 109:0-31
PSA 109:0-7 = PSA 110:0-7
PSA 110:0-10 = PSA 111:0-10
PSA 111:0-10 = PSA 112:0-10
PSA 112:0-9 = PSA 113:0-9
PSA 113:0-8 = PSA 114:0-8
PSA 113:9 = PSA 115:0
PSA 113:9-26 = PSA 115:1-18
PSA 114:0-9 = PSA 116:0-9
PSA 115:0 = PSA 116:10
PSA 115:1-10 = PSA 116:10-19	
PSA 116:0-2 = PSA 117:0-2
PSA 117:0-29 = PSA 118:0-29
PSA 118:0-176 = PSA 119:0-176
PSA 119:0-7 = PSA 120:0-7
PSA 120:0-8 = PSA 121:0-8
PSA 121:0-9 = PSA 122:0-9
PSA 122:0-4 = PSA 123:0-4
PSA 123:0-8 = PSA 124:0-8
PSA 124:0-5 = PSA 125:0-5
PSA 125:0-6 = PSA 126:0-6
PSA 126:0-5 = PSA 127:0-5
PSA 127:0-6 = PSA 128:0-6
PSA 128:0-8 = PSA 129:0-8
PSA 129:0-8 = PSA 130:0-8
PSA 130:0-3 = PSA 131:0-3
PSA 131:0-18 = PSA 132:0-18
PSA 132:0-3 = PSA 133:0-3
PSA 133:0-3 = PSA 134:0-3
PSA 134:0-21 = PSA 135:0-21
PSA 135:0-26 = PSA 136:0-26
PSA 136:0-9 = PSA 137:0-9
PSA 137:0-8 = PSA 138:0-8
PSA 138:0-24 = PSA 139:0-24
PSA 139:0-14 = PSA 140:0-14
PSA 140:0-10 = PSA 141:0-10
PSA 141:0-8 = PSA 142:0-8
PSA 142:0-12 = PSA 143:0-12
PSA 143:0-15 = PSA 144:0-15
PSA 144:0-21 = PSA 145:0-21
PSA 145:0-10 = PSA 146:0-10
# 146 + 147 -> 147
PSA 146:0-11 = PSA 147:0-11
PSA 147:0 = PSA 147:12
PSA 147:1-9 = PSA 147:12-20
# PSA 151 -> PS2
PSA 151:0-7 = PS2 1:0-7
#
# Jeremiah according to Rahlfs
# Added by SS 25.3.2003
#
# JER 1-25:13 = JER 1-25:13
# JER 25:14 = part of JER 49:34
# JER 25:20 = part of JER 49:34
# JER 52 = JER 52
#
JER 25:14-19 = JER 49:34-39
JER 25:20 = JER 49:34
JER 26:1-28 = JER 46:1-28
JER 27:1-46 = JER 50:1-46
JER 28:1-64 = JER 51:1-64
JER 29:1-7 = JER 47:1-7
JER 30:1-16 = JER 49:7-22
JER 30:17-22 = JER 49:1-6
JER 30:23-28 = JER 49:28-33
JER 30:29-33 = JER 49:23-27
JER 31:1-44 = JER 48:1-44
# Verses 31:1-13 do not exist
JER 32:13 = JER 25:13
# Verse 32:14 does not exist
JER 32:15-38 = JER 25:15-38
JER 33:1-24 = JER 26:1-24
JER 34:1-22 = JER 27:1-22
JER 35:1-17 = JER 28:1-17
JER 36:1-32 = JER 29:1-32
JER 37:1-24 = JER 30:1-24
JER 38:1-40 = JER 31:1-40
JER 39:1-44 = JER 32:1-44
JER 40:1-13 = JER 33:1-13
JER 41:1-22 = JER 34:1-22
JER 42:1-19 = JER 35:1-19
JER 43:1-32 = JER 36:1-32
JER 44:1-21 = JER 37:1-21
JER 45:1-28 = JER 38:1-28
JER 46:1-3 = JER 39:1-3
# Verses 46:4-13 do not exist
JER 46:14-18 = JER 39:14-18
JER 47:1-16 = JER 40:1-16
JER 48:1-18 = JER 41:1-18
JER 49:1-22 = JER 42:1-22
JER 50:1-13 = JER 43:1-13
JER 51:1-30 = JER 44:1-30
JER 51:31-35 = JER 45:1-5
#
# Map The Greek versioin of Daniel onto the Hebrew version of Daniel
# using the Hebrew version as the reference point.
# Normally DC material would not have any entries in this part of the lxx.vrs file
# because the LXX serves as the reference point for DC material.
# Material which is placed in separate books in HEB and LXX (i.e. DAN and DAG)
# is however placed here and referenced to the HEB reference point.
#
# If you have a text in which the DAG material has been (incorrectly) placed into DAN
# you must create a versification file in which DAN appears as the first book in 
# the following section.  You cannot have both DAN = DAN and DAG = DAN entries
# in a single file.
DAG 1:1-21 = DAN 1:1-21
DAG 2:1-49 = DAN 2:1-49
DAG 3:1-23 = DAN 3:1-23
DAG 3:91-97 = DAN 3:24-30
DAG 4:1-3 = DAN 3:31-33
DAG 4:4-37 = DAN 4:1-34
DAG 5:1-31 = DAN 5:1-31
DAG 6:1-28 = DAN 6:1-28
DAG 7:1-28 = DAN 7:1-28
DAG 8:1-27 = DAN 8:1-27
DAG 9:1-27 = DAN 9:1-27
DAG 10:1-21 = DAN 10:1-21
DAG 11:1-45 = DAN 11:1-45 
DAG 12:1-13 = DAN 12:1-13
#
# No entries present for S3Y because this book would not normally be present in a text based
# on the LXX versification. The S3Y material would instead start at DAG 3:24.
#
# When Ezra-Nehemiah is one book Ezra 11-23 maps onto Nehemiah
# LXX mapping onto BHS
EZR 11:1-11 = NEH 1:1-11
EZR 12:1-20 = NEH 2:1-20
EZR 13:1-38 = NEH 3:1-38
EZR 14:1-17 = NEH 4:1-17
EZR 15:1-19 = NEH 5:1-19
EZR 16:1-19 = NEH 6:1-19
EZR 17:1-72 = NEH 7:1-72
EZR 18:1-18 = NEH 8:1-18
EZR 19:1-37 = NEH 9:1-37
EZR 20:1-40 = NEH 10:1-40
EZR 21:1-36 = NEH 11:1-36
EZR 22:1-47 = NEH 12:1-47
EZR 23:1-31 = NEH 13:1-31
#---------------------------
# Mapping 2 Esdras onto the older Apocalypse of Ezra [Studge]
2ES 3:1-36 = EZA 1:1-36
2ES 4:1-52 = EZA 2:1-52
2ES 5:1-56 = EZA 3:1-56
2ES 6:1-59 = EZA 4:1-59
2ES 7:1-35 = EZA 5:1-35
2ES 7:106-140 = EZA 5:36-70
2ES 8:1-63 = EZA 6:1-63
2ES 9:1-47 = EZA 7:1-47
2ES 10:1-60 = EZA 8:1-60
2ES 11:1-46 = EZA 9:1-46
2ES 12:1-51 = EZA 10:1-51
2ES 13:1-58 = EZA 11:1-58
2ES 14:1-48 = EZA 12:1-48
#----------------------------
# Some texts (but not LXX) contain SUS and BEL as chapters 13 and 14 of DAG.
# There should not be any entries for DAG 13 and DAG 14 in the lxx.vrs because these chapters do not 
# exist in the LXX.
# If you have a text which has DAG 13 and 14 you will need to have a .vrs file that includes the following
# two mapping.
#
# Susanna
# DAG 13:1-63 = SUS 1:1-63
# Bel and the Dragon
# DAG 14:1-42 = BEL 1:1-42
#
#----------------------------
# Verse segment information for the Septuagint.
# The verse segment information is preceded by a '#!' so that it will be ignored by versions 
# of Paratext prior to Paratext 7.3 (and thus avoid crashing it with an unexpected format). 
#! *EXO 28:29,-,a 
#! *EXO 35:12,-,a 
#! *JOS 9:2,-,a,b,c,d,e,f 
#! *JOS 15:59,-,a 
#! *JOS 19:47,-,a 
#! *JOS 19:48,-,a 
#! *JOS 21:42,-,a,b,c,d 
#! *JOS 24:31,-,a 
#! *JOS 24:33,-,a,b 
#! *1SA 30:28,-,a 
#! *2SA 5:16,-,a 
#! *1KI 2:35,-,a,b,c,d,e,f,g,h,i,k,l,m,n,o 
#! *1KI 2:46,-,a,b,c,d,e,f,g,h,i,k,l 
#! *1KI 5:14,-,a,b 
#! *1KI 6:1,-,a,b,c,d 
#! *1KI 6:36,-,a 
#! *1KI 8:53,-,a 
#! *1KI 9:9,-,a 
#! *1KI 10:22,-,a,b,c 
#! *1KI 10:26,-,a 
#! *1KI 12:24,-,a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u,x,y,z 
#! *1KI 16:28,-,a,b,c,d,e,f,g,h 
#! *2KI 1:18,-,a,b,c,d 
#! *2CH 35:19,-,a,b,c,d 
#! *2CH 36:2,-,a,b,c 
#! *2CH 36:4,-,a 
#! *2CH 36:5,-,a,b,c,d 
#! *JOB 2:9,-,a,b,c,d,e 
#! *JOB 19:4,-,a 
#! *JOB 23:15,-,a 
#! *JOB 36:28,-,a,b 
#! *JOB 42:17,-,a,b,c,d,e 
#! *PSA 144:13,-,a 
#! *PRO 3:16,-,a 
#! *PRO 3:22,-,a 
#! *PRO 4:27,-,a,b 
#! *PRO 6:8,-,a,b,c 
#! *PRO 6:11,-,a 
#! *PRO 7:1,-,a 
#! *PRO 8:21,-,a 
#! *PRO 9:10,-,a 
#! *PRO 9:12,-,a,b,c 
#! *PRO 9:18,-,a,b,c,d 
#! *PRO 10:4,-,a 
#! *PRO 12:11,-,a 
#! *PRO 12:13,-,a 
#! *PRO 13:9,-,a 
#! *PRO 13:13,-,a 
#! *PRO 15:18,-,a 
#! *PRO 15:27,-,a 
#! *PRO 15:28,-,a 
#! *PRO 15:29,-,a,b 
#! *PRO 17:6,-,a 
#! *PRO 17:16,-,a 
#! *PRO 18:22,-,a 
#! *PRO 20:9,-,a,b,c 
#! *PRO 22:8,-,a 
#! *PRO 22:9,-,a 
#! *PRO 22:14,-,a 
#! *PRO 24:22,-,a,b,c,d,e 
#! *PRO 25:10,-,a 
#! *PRO 25:20,-,a 
#! *PRO 26:11,-,a 
#! *PRO 27:20,-,a 
#! *PRO 27:21,-,a 
#! *PRO 28:17,-,a 
#! *ESG 1:1,-,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s 
#! *ESG 3:13,-,a,b,c,d,e,f,g 
#! *ESG 4:17,-,a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u,w,x,y,z 
#! *ESG 5:1,-,a,b,c,d,e,f 
#! *ESG 5:2,-,a,b 
#! *ESG 8:12,-,a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u,x 
#! *ESG 10:3,-,a,b,c,d,e,f,g,h,i,k,l 
#! *SIR 1:1,-,a,b,c,d,e,f,g,h 
`;
  }
});

// node_modules/proskomma-core/src/model/versifications/org_vrs.cjs
var require_org_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/org_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = `# Versification  "Original" 
# Version=1.200
# (not a very good name but I have not heard a better suggestion)
#
# modifications by Studge 26/June/2009
#
# BHS versification for OT, UBS GNT versification for NT
# following the Masoretic order
# OT translations using Masorteic verse structures should map onto this text
# NT versifications maps onto Nestle-Aland
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
#---------------------------------------------------------------
# Old Testament
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:54 32:33 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:33 50:26
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:29 8:28 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:37 22:30 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:29 38:31 39:43 40:38
LEV 1:17 2:16 3:17 4:35 5:26 6:23 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:57 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:46 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:27 7:89 8:26 9:23 10:36 11:35 12:16 13:33 14:45 15:41 16:35 17:28 18:32 19:22 20:29 21:35 22:41 23:30 24:25 25:19 26:65 27:23 28:31 29:39 30:17 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:31 13:19 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:29 23:26 24:22 25:19 26:19 27:26 28:69 29:28 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDG 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:58 18:30 19:24 20:42 21:16 22:23 23:28 24:23 25:44 26:25 27:12 28:25 29:11 30:31 31:13
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:32 19:44 20:26 21:22 22:51 23:39 24:25
1KI 1:53 2:46 3:28 4:20 5:32 6:38 7:51 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:43 21:29 22:54
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:20 12:22 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
1CH 1:54 2:55 3:24 4:43 5:41 6:66 7:40 8:40 9:44 10:14 11:47 12:41 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:8 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:18 2:17 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:23 14:14 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44
NEH 1:11 2:20 3:38 4:17 5:19 6:19 7:72 8:18 9:37 10:40 11:36 12:47 13:31
EST 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:22 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:30 40:32 41:26 42:17
PSA 1:6 2:12 3:9 4:9 5:13 6:11 7:18 8:10 9:21 10:18 11:7 12:9 13:6 14:7 15:5 16:11 17:15 18:51 19:15 20:10 21:14 22:32 23:6 24:10 25:22 26:12 27:14 28:9 29:11 30:13 31:25 32:11 33:22 34:23 35:28 36:13 37:40 38:23 39:14 40:18 41:14 42:12 43:5 44:27 45:18 46:12 47:10 48:15 49:21 50:23 51:21 52:11 53:7 54:9 55:24 56:14 57:12 58:12 59:18 60:14 61:9 62:13 63:12 64:11 65:14 66:20 67:8 68:36 69:37 70:6 71:24 72:20 73:28 74:23 75:11 76:13 77:21 78:72 79:13 80:20 81:17 82:8 83:19 84:13 85:14 86:17 87:7 88:19 89:53 90:17 91:16 92:16 93:5 94:23 95:11 96:13 97:12 98:9 99:9 100:5 101:8 102:29 103:22 104:35 105:45 106:48 107:43 108:14 109:31 110:7 111:10 112:10 113:9 114:8 115:18 116:19 117:2 118:29 119:176 120:7 121:8 122:9 123:4 124:8 125:5 126:6 127:5 128:6 129:8 130:8 131:3 132:18 133:3 134:3 135:21 136:26 137:9 138:8 139:24 140:14 141:10 142:8 143:12 144:15 145:21 146:10 147:20 148:14 149:9 150:6
PRO 1:33 2:22 3:35 4:27 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:25 14:35 15:33 16:33 17:28 18:24 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:17 5:19 6:12 7:29 8:17 9:18 10:20 11:10 12:14
SNG 1:17 2:17 3:11 4:16 5:16 6:12 7:14 8:14
ISA 1:31 2:22 3:26 4:6 5:30 6:13 7:25 8:23 9:20 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:12 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:11 65:25 66:24
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:23 9:25 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:21 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:10 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:44 21:37 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
DAN 1:21 2:49 3:33 4:34 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
HOS 1:9 2:25 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:11 12:15 13:15 14:10
JOL 1:20 2:27 3:5 4:21
AMO 1:15 2:16 3:15 4:13 5:27 6:14 7:17 8:14 9:15
OBA 1:21
JON 1:16 2:11 3:10 4:11
MIC 1:16 2:13 3:12 4:14 5:14 6:16 7:20
NAM 1:14 2:14 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:15 2:23
ZEC 1:17 2:17 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:24
#---------------------------------------------------------
# New Testament books
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:27 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:41 5:43 6:56 7:37 8:38 9:50 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:71 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:60 8:40 9:43 10:48 11:30 12:25 13:52 14:28 15:41 16:40 17:34 18:28 19:40 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:23 15:33 16:27
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:33 12:21 13:13
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:18 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
#------------------------------------------------
# Deuterocanonical books from the LXX which are in the Catholic tradition
TOB 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
JDT 1:16 2:28 3:10 4:15 5:24 6:21 7:32 8:36 9:14 10:23 11:23 12:20 13:20 14:19 15:14 16:25
ESG 1:39 2:23 3:22 4:47 5:28 6:14 7:10 8:39 9:32 10:13
WIS 1:16 2:24 3:19 4:20 5:23 6:25 7:30 8:21 9:18 10:21 11:26 12:27 13:19 14:31 15:19 16:29 17:20 18:25 19:22
SIR 1:30 2:18 3:31 4:31 5:15 6:37 7:36 8:19 9:18 10:31 11:34 12:18 13:26 14:27 15:20 16:30 17:32 18:33 19:30 20:31 21:28 22:27 23:27 24:34 25:26 26:29 27:30 28:26 29:28 30:25 31:31 32:24 33:33 34:26 35:24 36:27 37:31 38:34 39:35 40:30 41:27 42:25 43:33 44:23 45:26 46:20 47:25 48:25 49:16 50:29 51:30
BAR 1:22 2:35 3:38 4:37 5:9
LJE 1:72
S3Y 1:67
SUS 1:64
BEL 1:42
1MA 1:64 2:70 3:60 4:61 5:68 6:63 7:50 8:32 9:73 10:89 11:74 12:53 13:53 14:49 15:41 16:24
2MA 1:36 2:32 3:40 4:50 5:27 6:31 7:42 8:36 9:29 10:38 11:38 12:45 13:26 14:46 15:39
#---------------------------------------------------
# Additional Orthodox books from the LXX
3MA 1:29 2:33 3:30 4:21 5:51 6:41 7:23
4MA 1:35 2:24 3:21 4:26 5:38 6:35 7:23 8:29 9:32 10:21 11:27 12:19 13:27 14:20 15:32 16:25 17:24 18:24
1ES 1:55 2:26 3:24 4:63 5:71 6:33 7:15 8:92 9:55
# This was the wrong definition for 2ES
# 2ES 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44 11:11 12:20 13:37 14:17 15:19 16:19 17:73 18:18 19:37 20:40 21:36 22:47 23:31
# This is the correct definition of 2ES, the "original" book was EZA
2ES 1:40 2:48 3:36 4:52 5:56 6:59 7:140 8:63 9:47 10:59 11:46 12:51 13:58 14:48 15:63 16:78
MAN 1:15
PS2 1:7
#-------------------------------------------------------
# ODA and PSS are only in the LXX and SYR projects. 
ODA 1:19 2:43 3:10 4:19 5:12 6:8 7:20 8:37 9:22 10:9 11:11 12:15 13:4 14:46
PSS 1:8 2:37 3:12 4:25 5:19 6:6 7:10 8:34 9:11 10:8 11:9 12:6 13:12 14:10 15:13 16:15 17:46 18:12
#-------------------------------------------------------
# the following codes are for obselete LXX variants only in LXX and not supported in PT 7
JSA 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDB 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
TBS 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
SST 1:64
DNT 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
BLT 1:42
#
# No mappings are present for this versification since it represents
# the "standard" versification to which all OT and NT texts are mapped in these files.
# (DC texts follow the LXX)
#
#-------------------------------------------------------
# Apocalypse of Ezra [Studge]
EZA 1:36 2:52 3:56 4:59 5:139 6:63 7:47 8:60 9:46 10:51 11:58 12:48
#--------------------------------------------------------
# Jubilees and Enoch have both been found in the Hebrew [Studge]
# might be needed if we add Dead Sea Scrolls
# Jubilees (Ethiopian canon)
JUB 1:26 2:17 3:19 4:24 5:36 6:34 7:37 8:40 9:27 10:48 11:39 12:56 13:34 14:55 15:20 16:28 17:30 18:31 19:59 20:66 21:30 22:38 23:59 24:30 25:50 26:48 27:37 28:38 29:27 30:29 31:31 32:24 33:30 34:20
# Enoch (Ethiopian canon)
ENO 1:28 2:42 3:30 4:88 5:40 6:42 7:39 8:46 9:42 10:16 11:19 12:40 13:34 14:35 15:45 16:41 17:69 18:42 19:29 20:53 21:57 22:14 23:26 24:16 25:30 26:37 27:21 28:34 29:28 30:23 31:29 32:82 33:59 34:49 35:36 36:30 37:34 38:36 39:24 40:40 41:22 42:16
#
# S3Y is a small section of the DAG LXX pulled out and translated as a separate book.
# Map it back to the LXX.  This section allow's texts such as TOB (French) which do
# this to scroll correctly with the LXX.
# S3Y is not present in the GRK, HEB, or LXX(Ralphs) text.
# If a text has DAG present, this section must NOT be included in its versification file because
# that would cause references in other texts to DAG to be redirected to a non-existant S3Y.
S3Y 1:1-29 = DAG 3:24-52
S3Y 1:30-31 = DAG 3:52-53
S3Y 1:33 = DAG 3:54
S3Y 1:32 = DAG 3:55
S3Y 1:34-35 = DAG 3:56-57
S3Y 1:37 = DAG 3:58
S3Y 1:36 = DAG 3:59
S3Y 1:38-68 = DAG 3:60-90
`;
  }
});

// node_modules/proskomma-core/src/model/versifications/rsc_vrs.cjs
var require_rsc_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/rsc_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = `# Versification  "Russian Protestant"
# Version=1.4
#
# This is the versification used by the "Canonical" (Protestant) edition of the Russian Synodal Bible
# Initial version provided by Peter_Kirk@sil.org
# Corrected 27/May/2003 by matjaz.crnivec@drustvo-svds.si:
#   Number of vss: ISA 3; REV 12
#   Mappings: LEV 14; 1KI 22; 1CH 12; NEH 7; ISA 3; 2CO 11; REV 13
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
#------------------------------------------------------------
# Old Testament
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:55 32:32 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:33 50:26
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:25 8:32 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:36 22:31 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:29 38:31 39:43 40:38
LEV 1:17 2:16 3:17 4:35 5:19 6:30 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:56 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:46 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:27 7:89 8:26 9:23 10:36 11:35 12:15 13:34 14:45 15:41 16:50 17:13 18:32 19:22 20:29 21:35 22:41 23:30 24:25 25:18 26:65 27:23 28:31 29:39 30:17 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:32 13:18 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:30 23:25 24:22 25:19 26:19 27:26 28:68 29:29 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:24 5:16 6:26 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
JDG 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:58 18:30 19:24 20:43 21:15 22:23 23:28 24:23 25:44 26:25 27:12 28:25 29:11 30:31 31:13
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:33 19:43 20:26 21:22 22:51 23:39 24:25
1KI 1:53 2:46 3:28 4:34 5:18 6:38 7:51 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:43 21:29 22:53
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:21 12:21 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
1CH 1:54 2:55 3:24 4:43 5:26 6:81 7:40 8:40 9:44 10:14 11:47 12:40 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:8 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:17 2:18 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:22 14:15 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44
NEH 1:11 2:20 3:32 4:23 5:19 6:19 7:73 8:18 9:38 10:39 11:36 12:47 13:31
EST 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:22 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:35 40:27 41:26 42:17
PSA 1:6 2:12 3:9 4:9 5:13 6:11 7:18 8:10 9:39 10:7 11:9 12:6 13:7 14:5 15:11 16:15 17:51 18:15 19:10 20:14 21:32 22:6 23:10 24:22 25:12 26:14 27:9 28:11 29:13 30:25 31:11 32:22 33:23 34:28 35:13 36:40 37:23 38:14 39:18 40:14 41:12 42:5 43:27 44:18 45:12 46:10 47:15 48:21 49:23 50:21 51:11 52:7 53:9 54:24 55:14 56:12 57:12 58:18 59:14 60:9 61:13 62:12 63:11 64:14 65:20 66:8 67:36 68:37 69:6 70:24 71:20 72:28 73:23 74:11 75:13 76:21 77:72 78:13 79:20 80:17 81:8 82:19 83:13 84:14 85:17 86:7 87:19 88:53 89:17 90:16 91:16 92:5 93:23 94:11 95:13 96:12 97:9 98:9 99:5 100:8 101:29 102:22 103:35 104:45 105:48 106:43 107:14 108:31 109:7 110:10 111:10 112:9 113:26 114:9 115:10 116:2 117:29 118:176 119:7 120:8 121:9 122:4 123:8 124:5 125:6 126:5 127:6 128:8 129:8 130:3 131:18 132:3 133:3 134:21 135:26 136:9 137:8 138:24 139:14 140:10 141:7 142:12 143:15 144:21 145:10 146:11 147:9 148:14 149:9 150:6
PRO 1:33 2:22 3:35 4:27 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:25 14:35 15:33 16:33 17:28 18:24 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:17 5:19 6:12 7:29 8:17 9:18 10:20 11:10 12:14
SNG 1:16 2:17 3:11 4:16 5:16 6:12 7:14 8:14
ISA 1:31 2:22 3:25 4:6 5:30 6:13 7:25 8:22 9:21 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:12 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:12 65:25 66:24
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:22 9:26 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:21 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:10 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:49 21:32 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
DAN 1:21 2:49 3:33 4:34 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13
HOS 1:11 2:23 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:12 12:14 13:15 14:10
JOL 1:20 2:32 3:21
AMO 1:15 2:16 3:15 4:13 5:27 6:14 7:17 8:14 9:15
OBA 1:21
JON 1:16 2:11 3:10 4:11
MIC 1:16 2:13 3:12 4:13 5:15 6:16 7:20
NAM 1:15 2:13 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:15 2:23
ZEC 1:21 2:13 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:18 4:6
#-------------------------------------------------------
# New Testament books
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:27 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:41 5:43 6:56 7:37 8:38 9:50 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:71 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:60 8:40 9:43 10:48 11:30 12:25 13:52 14:28 15:41 16:40 17:34 18:28 19:40 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:26 15:33 16:24
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:32 12:21 13:13
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:17 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
#
#------------------------------------------------------------
# Mapping
#-------------------------------------------------------------
# Russian = BHS (see org.vrs)
#
# (Note: ranges must not span a chapter, e.g. 4:10-5:11 is illegal)
#
GEN 31:55 = GEN 32:1
GEN 32:1-32 = GEN 32:2-33
EXO 8:1-4 = EXO 7:26-29
EXO 8:5-32 = EXO 8:1-28
EXO 22:1 = EXO 21:37
EXO 22:2-31 = EXO 22:1-30
LEV 6:1-7 = LEV 5:20-26
LEV 6:8-30 = LEV 6:1-23
# LEV 14:55b = LEV 14:56   # cant handle split verses yet
LEV 14:55 = LEV 14:55
LEV 14:55 = LEV 14:56
LEV 14:56 = LEV 14:57
NUM 13:1 = NUM 12:16
NUM 13:2-34 = NUM 13:1-33
NUM 16:36-50 = NUM 17:1-15
NUM 17:1-13 = NUM 17:16-28
NUM 26:1 = NUM 25:19
NUM 26:1 = NUM 26:1
DEU 12:32 = DEU 13:1
DEU 13:1-18 = DEU 13:2-19
DEU 22:30 = DEU 23:1
DEU 23:1-25 = DEU 23:2-26
DEU 29:1 = DEU 28:69
DEU 29:2-29 = DEU 29:1-28
JOS 5:16 = JOS 6:1
JOS 6:1-26 = JOS 6:2-27
1SA 20:43 = 1SA 21:1
1SA 21:1-15 = 1SA 21:2-16
2SA 18:33 = 2SA 19:1
2SA 19:1-43 = 2SA 19:2-44
1KI 4:21-34 = 1KI 5:1-14
1KI 5:1-18 = 1KI 5:15-32
#1KI 22:43b = 1KI 22:44   # cant handle split verses yet
1KI 22:43 = 1KI 22:43
1KI 22:43 = 1KI 22:44
1KI 22:44-53 = 1KI 22:45-54
2KI 11:21 = 2KI 12:1
2KI 12:1-21 = 2KI 12:2-22
1CH 6:1-15 = 1CH 5:27-41
1CH 6:16-81 = 1CH 6:1-66
# 1CH 12:4b = 1CH 12:5   # cant handle split verses yet
1CH 12:4 = 1CH 12:4
1CH 12:4 = 1CH 12:5
1CH 12:5-40 = 1CH 12:6-41
2CH 2:1 = 2CH 1:18
2CH 2:2-18 = 2CH 2:1-17
2CH 14:1 = 2CH 13:23
2CH 14:2-15 = 2CH 14:1-14
NEH 4:1-6 = NEH 3:33-38
NEH 4:7-23 = NEH 4:1-17
# NEH 7:68 = NEH 7:67b   # cant handle split verses yet
NEH 7:67 = NEH 7:67
NEH 7:68 = NEH 7:67
NEH 7:69-73 = NEH 7:68-72
NEH 9:38 = NEH 10:1
NEH 10:1-39 = NEH 10:2-40
JOB 39:31-35 = JOB 40:1-5
JOB 40:1-19 = JOB 40:6-24
JOB 40:20-27 = JOB 40:25-32
# PSA 9 = 9+10
PSA 9:22 = PSA 10:0
PSA 9:22-39 = PSA 10:1-18
PSA 10:0-7 = PSA 11:0-7
PSA 11:0-9 = PSA 12:0-9
PSA 12:0-6 = PSA 13:0-6
PSA 13:0-7 = PSA 14:0-7
PSA 14:0-5 = PSA 15:0-5
PSA 15:0-11 = PSA 16:0-11
PSA 16:0-15 = PSA 17:0-15
PSA 17:0-51 = PSA 18:0-51
PSA 18:0-15 = PSA 19:0-15
PSA 19:0-10 = PSA 20:0-10
PSA 20:0-14 = PSA 21:0-14
PSA 21:0-32 = PSA 22:0-32
PSA 22:0-6 = PSA 23:0-6
PSA 23:0-10 = PSA 24:0-10
PSA 24:0-22 = PSA 25:0-22
PSA 25:0-12 = PSA 26:0-12
PSA 26:0-14 = PSA 27:0-14
PSA 27:0-9 = PSA 28:0-9
PSA 28:0-11 = PSA 29:0-11
PSA 29:0-13 = PSA 30:0-13
PSA 30:0-25 = PSA 31:0-25
PSA 31:0-11 = PSA 32:0-11
PSA 32:0-22 = PSA 33:0-22
PSA 33:0-23 = PSA 34:0-23
PSA 34:0-28 = PSA 35:0-28
PSA 35:0-13 = PSA 36:0-13
PSA 36:0-40 = PSA 37:0-40
PSA 37:0-23 = PSA 38:0-23
PSA 38:0-14 = PSA 39:0-14
PSA 39:0-18 = PSA 40:0-18
PSA 40:0-14 = PSA 41:0-14
PSA 41:0-12 = PSA 42:0-12
PSA 42:0-5 = PSA 43:0-5
PSA 43:0-27 = PSA 44:0-27
PSA 44:0-18 = PSA 45:0-18
PSA 45:0-12 = PSA 46:0-12
PSA 46:0-10 = PSA 47:0-10
PSA 47:0-15 = PSA 48:0-15
PSA 48:0-21 = PSA 49:0-21
PSA 49:0-23 = PSA 50:0-23
PSA 50:0-21 = PSA 51:0-21
PSA 51:0-11 = PSA 52:0-11
PSA 52:0-7 = PSA 53:0-7
PSA 53:0-9 = PSA 54:0-9
PSA 54:0-24 = PSA 55:0-24
PSA 55:0-14 = PSA 56:0-14
PSA 56:0-12 = PSA 57:0-12
PSA 57:0-12 = PSA 58:0-12
PSA 58:0-18 = PSA 59:0-18
PSA 59:0-14 = PSA 60:0-14
PSA 60:0-9 = PSA 61:0-9
PSA 61:0-13 = PSA 62:0-13
PSA 62:0-12 = PSA 63:0-12
PSA 63:0-11 = PSA 64:0-11
PSA 64:0-14 = PSA 65:0-14
PSA 65:0-20 = PSA 66:0-20
PSA 66:0-8 = PSA 67:0-8
PSA 67:0-36 = PSA 68:0-36
PSA 68:0-37 = PSA 69:0-37
PSA 69:0-6 = PSA 70:0-6
PSA 70:0-24 = PSA 71:0-24
PSA 71:0-20 = PSA 72:0-20
PSA 72:0-28 = PSA 73:0-28
PSA 73:0-23 = PSA 74:0-23
PSA 74:0-11 = PSA 75:0-11
PSA 75:0-13 = PSA 76:0-13
PSA 76:0-21 = PSA 77:0-21
PSA 77:0-72 = PSA 78:0-72
PSA 78:0-13 = PSA 79:0-13
PSA 79:0-20 = PSA 80:0-20
PSA 80:0-17 = PSA 81:0-17
PSA 81:0-8 = PSA 82:0-8
PSA 82:0-19 = PSA 83:0-19
PSA 83:0-13 = PSA 84:0-13
PSA 84:0-14 = PSA 85:0-14
PSA 85:0-17 = PSA 86:0-17
PSA 86:0-1 = PSA 87:0-1
PSA 86:2 = PSA 87:1
PSA 86:2-7 = PSA 87:2-7
PSA 87:0-19 = PSA 88:0-19
PSA 88:0-53 = PSA 89:0-53
PSA 89:0-1 = PSA 90:0
PSA 89:2-6 = PSA 90:1-5
PSA 89:6 = PSA 90:6
PSA 89:7-17 = PSA 90:7-17
PSA 90:0-16 = PSA 91:0-16
PSA 91:0-16 = PSA 92:0-16
PSA 92:0-5 = PSA 93:0-5
PSA 93:0-23 = PSA 94:0-23
PSA 94:0-11 = PSA 95:0-11
PSA 95:0-13 = PSA 96:0-13
PSA 96:0-12 = PSA 97:0-12
PSA 97:0-9 = PSA 98:0-9
PSA 98:0-9 = PSA 99:0-9
PSA 99:0-5 = PSA 100:0-5
PSA 100:0-8 = PSA 101:0-8
PSA 101:0-29 = PSA 102:0-29
PSA 102:0-22 = PSA 103:0-22
PSA 103:0-35 = PSA 104:0-35
PSA 104:0-45 = PSA 105:0-45
PSA 105:0-48 = PSA 106:0-48
PSA 106:0-43 = PSA 107:0-43
PSA 107:0-14 = PSA 108:0-14
PSA 108:0-31 = PSA 109:0-31
PSA 109:0-7 = PSA 110:0-7
PSA 110:0-10 = PSA 111:0-10
PSA 111:0-10 = PSA 112:0-10
PSA 112:0-9 = PSA 113:0-9
PSA 113:0-8 = PSA 114:0-8
PSA 113:9 = PSA 115:0
PSA 113:9-26 = PSA 115:1-18
PSA 114:0-9 = PSA 116:0-9
PSA 115:0 = PSA 116:10
PSA 115:1-10 = PSA 116:10-19	
PSA 116:0-2 = PSA 117:0-2
PSA 117:0-29 = PSA 118:0-29
PSA 118:0-176 = PSA 119:0-176
PSA 119:0-7 = PSA 120:0-7
PSA 120:0-8 = PSA 121:0-8
PSA 121:0-9 = PSA 122:0-9
PSA 122:0-4 = PSA 123:0-4
PSA 123:0-8 = PSA 124:0-8
PSA 124:0-5 = PSA 125:0-5
PSA 125:0-6 = PSA 126:0-6
PSA 126:0-5 = PSA 127:0-5
PSA 127:0-6 = PSA 128:0-6
PSA 128:0-8 = PSA 129:0-8
PSA 129:0-8 = PSA 130:0-8
PSA 130:0-3 = PSA 131:0-3
PSA 131:0-18 = PSA 132:0-18
PSA 132:0-3 = PSA 133:0-3
PSA 133:0-3 = PSA 134:0-3
PSA 134:0-21 = PSA 135:0-21
PSA 135:0-26 = PSA 136:0-26
PSA 136:0-9 = PSA 137:0-9
PSA 137:0-8 = PSA 138:0-8
PSA 138:0-24 = PSA 139:0-24
PSA 139:0-14 = PSA 140:0-14
PSA 140:0-10 = PSA 141:0-10
PSA 141:0 = PSA 142:0-1
PSA 141:1-7 = PSA 142:2-8
PSA 142:0-12 = PSA 143:0-12
PSA 143:0-15 = PSA 144:0-15
PSA 144:0-21 = PSA 145:0-21
PSA 145:0-10 = PSA 146:0-10
# 146 + 147 -> 147
PSA 146:0-11 = PSA 147:0-11
PSA 147:0 = PSA 147:12
PSA 147:1-9 = PSA 147:12-20
SNG 1:1-16 = SNG 1:2-17
# ISA 3:19b = ISA 3:20   # cant handle split verses yet
ISA 3:19 = ISA 3:19
ISA 3:19 = ISA 3:20
ISA 3:20-25 = ISA 3:21-26
ISA 9:1 = ISA 8:23
ISA 9:2-21 = ISA 9:1-20
ISA 63:19 = ISA 63:19
ISA 64:1 = ISA 63:19
ISA 64:2-12 = ISA 64:1-11
JER 9:1 = JER 8:23
JER 9:2-26 = JER 9:1-25
EZK 20:45-49 = EZK 21:1-5
EZK 21:1-32 = EZK 21:6-37
DAN 5:31 = DAN 6:1
DAN 6:1-28 = DAN 6:2-29
HOS 1:10-11 = HOS 2:1-2
HOS 2:1-23 = HOS 2:3-25
HOS 11:12 = HOS 12:1
HOS 12:1-14 = HOS 12:2-15
JOL 2:28-32 = JOL 3:1-5
JOL 3:1-21 = JOL 4:1-21
MIC 5:1 = MIC 4:14
MIC 5:2-15 = MIC 5:1-14
NAM 1:15 = NAM 2:1
NAM 2:1-13 = NAM 2:2-14
ZEC 1:18-21 = ZEC 2:1-4
ZEC 2:1-13 = ZEC 2:5-17
MAL 4:1-6 = MAL 3:19-24
ROM 14:24-26 = ROM 16:25-27
# 2CO 11:32b = 2CO 11:33   # cant handle split verses yet
2CO 11:32 = 2CO 11:32
2CO 11:32 = 2CO 11:33
# REV 13:1a = REV 12:18   # cant handle split verses yet
# REV 13:1b = REV 13:1    # cant handle split verses yet
REV 13:1 = REV 12:18
REV 13:1 = REV 13:1
`;
  }
});

// node_modules/proskomma-core/src/model/versifications/rso_vrs.cjs
var require_rso_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/rso_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = `# Versification  "Russian Orthodox"
# Version=1.3
#
# This is the versification used by the Orthodox (or "non-canonical") edition of the Russian Synodal Bible
# Initial version provided by Peter_Kirk@sil.org
# Corrected 27/May/2003 by matjaz.crnivec@drustvo-svds.si:
#   Number of vss: 2CH 37; PSA 114; ISA 3; REV 12; 2ES (whole book added),
#   Mappings: LEV 14; 1KI 22; 1CH 12; 2CH 37; NEH 7; PSA 114; ISA 3; 2CO 11; REV 13; 2ES 7; 10
#
# modifications by Studge 26/June/2009
# amended by HAB April 2010
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
#----------------------------------------------------------
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:55 32:32 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:33 50:26
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:25 8:32 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:36 22:31 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:29 38:31 39:43 40:38
LEV 1:17 2:16 3:17 4:35 5:19 6:30 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:56 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:46 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:27 7:89 8:26 9:23 10:36 11:35 12:15 13:34 14:45 15:41 16:50 17:13 18:32 19:22 20:29 21:35 22:41 23:30 24:25 25:18 26:65 27:23 28:31 29:39 30:17 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:32 13:18 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:30 23:25 24:22 25:19 26:19 27:26 28:68 29:29 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:24 5:16 6:26 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:36
JDG 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:58 18:30 19:24 20:43 21:15 22:23 23:28 24:23 25:44 26:25 27:12 28:25 29:11 30:31 31:13
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:33 19:43 20:26 21:22 22:51 23:39 24:25
1KI 1:53 2:46 3:28 4:34 5:18 6:38 7:51 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:43 21:29 22:53
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:21 12:21 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
1CH 1:54 2:55 3:24 4:43 5:26 6:81 7:40 8:40 9:44 10:14 11:47 12:40 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:8 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:17 2:18 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:22 14:15 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23 37:12
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44
NEH 1:11 2:20 3:32 4:23 5:19 6:19 7:73 8:18 9:38 10:39 11:36 12:47 13:31
#--------------
# Notes EST is the Greek Esther which should have been under ESG
EST 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
#--------------
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:22 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:35 40:27 41:26 42:17
PSA 1:6 2:12 3:9 4:9 5:13 6:11 7:18 8:10 9:39 10:7 11:9 12:6 13:7 14:5 15:11 16:15 17:51 18:15 19:10 20:14 21:32 22:6 23:10 24:22 25:12 26:14 27:9 28:11 29:13 30:25 31:11 32:22 33:23 34:28 35:13 36:40 37:23 38:14 39:18 40:14 41:12 42:5 43:27 44:18 45:12 46:10 47:15 48:21 49:23 50:21 51:11 52:7 53:9 54:24 55:14 56:12 57:12 58:18 59:14 60:9 61:13 62:12 63:11 64:14 65:20 66:8 67:36 68:37 69:6 70:24 71:20 72:28 73:23 74:11 75:13 76:21 77:72 78:13 79:20 80:17 81:8 82:19 83:13 84:14 85:17 86:7 87:19 88:53 89:17 90:16 91:16 92:5 93:23 94:11 95:13 96:12 97:9 98:9 99:5 100:8 101:29 102:22 103:35 104:45 105:48 106:43 107:14 108:31 109:7 110:10 111:10 112:9 113:26 114:8 115:10 116:2 117:29 118:176 119:7 120:8 121:9 122:4 123:8 124:5 125:6 126:5 127:6 128:8 129:8 130:3 131:18 132:3 133:3 134:21 135:26 136:9 137:8 138:24 139:14 140:10 141:7 142:12 143:15 144:21 145:10 146:11 147:9 148:14 149:9 150:6 151:7
PRO 1:33 2:22 3:35 4:29 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:26 14:35 15:33 16:33 17:28 18:25 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:17 5:19 6:12 7:29 8:17 9:18 10:20 11:10 12:14
SNG 1:16 2:17 3:11 4:16 5:16 6:12 7:14 8:14
ISA 1:31 2:22 3:25 4:6 5:30 6:13 7:25 8:22 9:21 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:12 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:12 65:25 66:24
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:22 9:26 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:21 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:10 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:49 21:32 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
DAN 1:21 2:49 3:100 4:34 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13 13:64 14:42
HOS 1:11 2:23 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:12 12:14 13:15 14:10
JOL 1:20 2:32 3:21
AMO 1:15 2:16 3:15 4:13 5:27 6:14 7:17 8:14 9:15
OBA 1:21
JON 1:16 2:11 3:10 4:11
MIC 1:16 2:13 3:12 4:13 5:15 6:16 7:20
NAM 1:15 2:13 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:15 2:23
ZEC 1:21 2:13 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:18 4:6
#----------------------------------------------------
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:27 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:41 5:43 6:56 7:37 8:38 9:50 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:71 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:60 8:40 9:43 10:48 11:30 12:25 13:52 14:28 15:41 16:40 17:34 18:28 19:40 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:26 15:33 16:24
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:32 12:21 13:13
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:17 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
#---------------------------------------------
TOB 1:22 2:14 3:17 4:21 5:22 6:18 7:17 8:21 9:6 10:13 11:18 12:22 13:18 14:15
JDT 1:16 2:28 3:10 4:15 5:24 6:21 7:32 8:36 9:14 10:23 11:23 12:20 13:20 14:19 15:14 16:25
# ESG added which ought to replace EST
ESG 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:3
WIS 1:16 2:24 3:19 4:20 5:24 6:27 7:30 8:21 9:19 10:21 11:27 12:28 13:19 14:31 15:19 16:29 17:20 18:25 19:21
SIR 1:30 2:18 3:31 4:35 5:18 6:37 7:39 8:22 9:23 10:34 11:34 12:18 13:32 14:27 15:20 16:31 17:31 18:33 19:28 20:31 21:31 22:31 23:37 24:37 25:29 26:27 27:33 28:30 29:31 30:27 31:37 32:25 33:33 34:26 35:23 36:29 37:34 38:39 39:42 40:32 41:29 42:26 43:36 44:27 45:31 46:23 47:31 48:28 49:18 50:31 51:38
BAR 1:22 2:35 3:38 4:37 5:9
LJE 1:72
1MA 1:64 2:70 3:60 4:61 5:68 6:63 7:50 8:32 9:73 10:89 11:74 12:53 13:53 14:49 15:41 16:24
2MA 1:36 2:33 3:40 4:50 5:27 6:31 7:42 8:36 9:29 10:38 11:38 12:45 13:26 14:46 15:39
3MA 1:25 2:24 3:22 4:16 5:36 6:37 7:20
1ES 1:58 2:31 3:24 4:63 5:70 6:34 7:15 8:92 9:55
# in the Russian tradition the book of 1ES is called 2 Esdras [Studge]
2ES 1:40 2:48 3:36 4:52 5:56 6:59 7:70 8:63 9:47 10:60 11:46 12:51 13:58 14:48 15:63 16:78
# in the Russian tradition the book of 2ES is called 3 Esdras [Studge]
# added Prayer of Manasseh which is appended to 2 Chronicles in RSO
MAN 1:15
#
#----------------------------------------------
# Mapping
#----------------------------------------------
# Russian = BHS (see org.vrs)
#
# (Note: ranges must not span a chapter, e.g. 4:10-5:11 is illegal)
#
GEN 31:55 = GEN 32:1
GEN 32:1-32 = GEN 32:2-33
EXO 8:1-4 = EXO 7:26-29
EXO 8:5-32 = EXO 8:1-28
EXO 22:1 = EXO 21:37
EXO 22:2-31 = EXO 22:1-30
LEV 6:1-7 = LEV 5:20-26
LEV 6:8-30 = LEV 6:1-23
# LEV 14:55 = LEV 14:55-56
LEV 14:55 = LEV 14:55
LEV 14:55 = LEV 14:56
LEV 14:56 = LEV 14:57
NUM 13:1 = NUM 12:16
NUM 13:2-34 = NUM 13:1-33
NUM 16:36-50 = NUM 17:1-15
NUM 17:1-13 = NUM 17:16-28
NUM 26:1 = NUM 25:19
NUM 26:1 = NUM 26:1
DEU 12:32 = DEU 13:1
DEU 13:1-18 = DEU 13:2-19
DEU 22:30 = DEU 23:1
DEU 23:1-25 = DEU 23:2-26
DEU 29:1 = DEU 28:69
DEU 29:2-29 = DEU 29:1-28
JOS 5:16 = JOS 6:1
JOS 6:1-26 = JOS 6:2-27
1SA 20:43 = 1SA 21:1
1SA 21:1-15 = 1SA 21:2-16
2SA 18:33 = 2SA 19:1
2SA 19:1-43 = 2SA 19:2-44
1KI 4:21-34 = 1KI 5:1-14
1KI 5:1-18 = 1KI 5:15-32
# 1KI 22:43 = 1KI 22:43-44
1KI 22:43 = 1KI 22:43
1KI 22:43 = 1KI 22:44
1KI 22:44-53 = 1KI 22:45-54
2KI 11:21 = 2KI 12:1
2KI 12:1-21 = 2KI 12:2-22
1CH 6:1-15 = 1CH 5:27-41
1CH 6:16-81 = 1CH 6:1-66
# 1CH 12:4 = 1CH 12:4-5
1CH 12:4 = 1CH 12:4
1CH 12:4 = 1CH 12:5
1CH 12:5-40 = 1CH 12:6-41
2CH 2:1 = 2CH 1:18
2CH 2:2-18 = 2CH 2:1-17
2CH 14:1 = 2CH 13:23
2CH 14:2-15 = 2CH 14:1-14
# All the 37th chapter maps across verse boundaries!
#-----------------------
# Prayer of Manasseh
2CH 37:1 = MAN 1:1
2CH 37:2 = MAN 1:2
2CH 37:2 = MAN 1:3
2CH 37:2 = MAN 1:4
2CH 37:2 = MAN 1:5
2CH 37:3 = MAN 1:5
2CH 37:4 = MAN 1:6
2CH 37:5 = MAN 1:7
2CH 37:6 = MAN 1:7
2CH 37:6 = MAN 1:8
2CH 37:7 = MAN 1:8
2CH 37:7 = MAN 1:9
2CH 37:8 = MAN 1:9
2CH 37:8 = MAN 1:10
2CH 37:9 = MAN 1:10
2CH 37:10 = MAN 1:10
2CH 37:10 = MAN 1:11
2CH 37:11 = MAN 1:12
2CH 37:11 = MAN 1:13
2CH 37:11 = MAN 1:14
2CH 37:11 = MAN 1:15
2CH 37:12 = MAN 1:15
#--------------------------
NEH 4:1-6 = NEH 3:33-38
NEH 4:7-23 = NEH 4:1-17
# NEH 7:67-68 = NEH 7:67
NEH 7:67 = NEH 7:67
NEH 7:68 = NEH 7:67
NEH 7:69-73 = NEH 7:68-72
NEH 9:38 = NEH 10:1
NEH 10:1-39 = NEH 10:2-40
JOB 39:31-35 = JOB 40:1-5
JOB 40:1-19 = JOB 40:6-24
JOB 40:20-27 = JOB 40:25-32
# PSA 9 = 9+10
PSA 9:22 = PSA 10:0
PSA 9:22-39 = PSA 10:1-18
PSA 10:0-7 = PSA 11:0-7
PSA 11:0-9 = PSA 12:0-9
PSA 12:0-6 = PSA 13:0-6
PSA 13:0-7 = PSA 14:0-7
PSA 14:0-5 = PSA 15:0-5
PSA 15:0-11 = PSA 16:0-11
PSA 16:0-15 = PSA 17:0-15
PSA 17:0-51 = PSA 18:0-51
PSA 18:0-15 = PSA 19:0-15
PSA 19:0-10 = PSA 20:0-10
PSA 20:0-14 = PSA 21:0-14
PSA 21:0-32 = PSA 22:0-32
PSA 22:0-6 = PSA 23:0-6
PSA 23:0-10 = PSA 24:0-10
PSA 24:0-22 = PSA 25:0-22
PSA 25:0-12 = PSA 26:0-12
PSA 26:0-14 = PSA 27:0-14
PSA 27:0-9 = PSA 28:0-9
PSA 28:0-11 = PSA 29:0-11
PSA 29:0-13 = PSA 30:0-13
PSA 30:0-25 = PSA 31:0-25
PSA 31:0-11 = PSA 32:0-11
PSA 32:0-22 = PSA 33:0-22
PSA 33:0-23 = PSA 34:0-23
PSA 34:0-28 = PSA 35:0-28
PSA 35:0-13 = PSA 36:0-13
PSA 36:0-40 = PSA 37:0-40
PSA 37:0-23 = PSA 38:0-23
PSA 38:0-14 = PSA 39:0-14
PSA 39:0-18 = PSA 40:0-18
PSA 40:0-14 = PSA 41:0-14
PSA 41:0-12 = PSA 42:0-12
PSA 42:0-5 = PSA 43:0-5
PSA 43:0-27 = PSA 44:0-27
PSA 44:0-18 = PSA 45:0-18
PSA 45:0-12 = PSA 46:0-12
PSA 46:0-10 = PSA 47:0-10
PSA 47:0-15 = PSA 48:0-15
PSA 48:0-21 = PSA 49:0-21
PSA 49:0-23 = PSA 50:0-23
PSA 50:0-21 = PSA 51:0-21
PSA 51:0-11 = PSA 52:0-11
PSA 52:0-7 = PSA 53:0-7
PSA 53:0-9 = PSA 54:0-9
PSA 54:0-24 = PSA 55:0-24
PSA 55:0-14 = PSA 56:0-14
PSA 56:0-12 = PSA 57:0-12
PSA 57:0-12 = PSA 58:0-12
PSA 58:0-18 = PSA 59:0-18
PSA 59:0-14 = PSA 60:0-14
PSA 60:0-9 = PSA 61:0-9
PSA 61:0-13 = PSA 62:0-13
PSA 62:0-12 = PSA 63:0-12
PSA 63:0-11 = PSA 64:0-11
PSA 64:0-14 = PSA 65:0-14
PSA 65:0-20 = PSA 66:0-20
PSA 66:0-8 = PSA 67:0-8
PSA 67:0-36 = PSA 68:0-36
PSA 68:0-37 = PSA 69:0-37
PSA 69:0-6 = PSA 70:0-6
PSA 70:0-24 = PSA 71:0-24
PSA 71:0-20 = PSA 72:0-20
PSA 72:0-28 = PSA 73:0-28
PSA 73:0-23 = PSA 74:0-23
PSA 74:0-11 = PSA 75:0-11
PSA 75:0-13 = PSA 76:0-13
PSA 76:0-21 = PSA 77:0-21
PSA 77:0-72 = PSA 78:0-72
PSA 78:0-13 = PSA 79:0-13
PSA 79:0-20 = PSA 80:0-20
PSA 80:0-17 = PSA 81:0-17
PSA 81:0-8 = PSA 82:0-8
PSA 82:0-19 = PSA 83:0-19
PSA 83:0-13 = PSA 84:0-13
PSA 84:0-14 = PSA 85:0-14
PSA 85:0-17 = PSA 86:0-17
PSA 86:0-1 = PSA 87:1
PSA 86:2 = PSA 87:1
PSA 86:2-7 = PSA 87:2-7
PSA 87:0-19 = PSA 88:0-19
PSA 88:0-53 = PSA 89:0-53
PSA 89:0-1 = PSA 90:0-1
PSA 89:2-6 = PSA 90:1-6
PSA 89:7-17 = PSA 90:7-17
PSA 90:0-16 = PSA 91:0-16
PSA 91:0-16 = PSA 92:0-16
PSA 92:0-5 = PSA 93:0-5
PSA 93:0-23 = PSA 94:0-23
PSA 94:0-11 = PSA 95:0-11
PSA 95:0-13 = PSA 96:0-13
PSA 96:0-12 = PSA 97:0-12
PSA 97:0-9 = PSA 98:0-9
PSA 98:0-9 = PSA 99:0-9
PSA 99:0-5 = PSA 100:0-5
PSA 100:0-8 = PSA 101:0-8
PSA 101:0-29 = PSA 102:0-29
PSA 102:0-22 = PSA 103:0-22
PSA 103:0-35 = PSA 104:0-35
PSA 104:0-45 = PSA 105:0-45
PSA 105:0-48 = PSA 106:0-48
PSA 106:0-43 = PSA 107:0-43
PSA 107:0-14 = PSA 108:0-14
PSA 108:0-31 = PSA 109:0-31
PSA 109:0-7 = PSA 110:0-7
PSA 110:0-10 = PSA 111:0-10
PSA 111:0-10 = PSA 112:0-10
PSA 112:0-9 = PSA 113:0-9
PSA 113:0-8 = PSA 114:0-8
PSA 113:9 = PSA 115:0
PSA 113:9-26 = PSA 115:1-18
PSA 114:0-8 = PSA 116:0-8
PSA 114:8 = PSA 116:9
PSA 115:0-10 = PSA 116:10-19	
PSA 116:0-2 = PSA 117:0-2
PSA 117:0-29 = PSA 118:0-29
PSA 118:0-176 = PSA 119:0-176
PSA 119:0-7 = PSA 120:0-7
PSA 120:0-8 = PSA 121:0-8
PSA 121:0-9 = PSA 122:0-9
PSA 122:0-4 = PSA 123:0-4
PSA 123:0-8 = PSA 124:0-8
PSA 124:0-5 = PSA 125:0-5
PSA 125:0-6 = PSA 126:0-6
PSA 126:0-5 = PSA 127:0-5
PSA 127:0-6 = PSA 128:0-6
PSA 128:0-8 = PSA 129:0-8
PSA 129:0-8 = PSA 130:0-8
PSA 130:0-3 = PSA 131:0-3
PSA 131:0-18 = PSA 132:0-18
PSA 132:0-3 = PSA 133:0-3
PSA 133:0-3 = PSA 134:0-3
PSA 134:0-21 = PSA 135:0-21
PSA 135:0-26 = PSA 136:0-26
PSA 136:0-9 = PSA 137:0-9
PSA 137:0-8 = PSA 138:0-8
PSA 138:0-24 = PSA 139:0-24
PSA 139:0-14 = PSA 140:0-14
PSA 140:0-10 = PSA 141:0-10
PSA 141:0 = PSA 142:0
PSA 141:1-7 = PSA 142:2-8
PSA 142:0-12 = PSA 143:0-12
PSA 143:0-15 = PSA 144:0-15
PSA 144:0-21 = PSA 145:0-21
PSA 145:0-10 = PSA 146:0-10
# 146 + 147 -> 147
PSA 146:0-11 = PSA 147:0-11
PSA 147:0 = PSA 147:12
PSA 147:1-9 = PSA 147:12-20
#---------------------------
# additional LXX Psalm
PSA 151:1-7 = PS2 1:1-7
#----------------------------
PRO 13:15-26 = PRO 13:14-25
PRO 18:9-25 = PRO 18:8-24
SNG 1:1-16 = SNG 1:2-17
# ISA 3:19 = ISA 3:19-20
ISA 3:19 = ISA 3:19
ISA 3:19 = ISA 3:20
ISA 3:20-25 = ISA 3:16-21
ISA 9:1 = ISA 8:23
ISA 9:2-21 = ISA 9:1-20
ISA 63:19 = ISA 63:19
ISA 64:1 = ISA 63:19
ISA 64:2-12 = ISA 64:1-11
JER 9:1 = JER 8:23
JER 9:2-26 = JER 9:1-25
EZK 20:45-49 = EZK 21:1-5
EZK 21:1-32 = EZK 21:6-37
HOS 1:10-11 = HOS 2:1-2
HOS 2:1-23 = HOS 2:3-25
HOS 11:12 = HOS 12:1
HOS 12:1-14 = HOS 12:2-15
JOL 2:28-32 = JOL 3:1-5
JOL 3:1-21 = JOL 4:1-21
MIC 5:1 = MIC 4:14
MIC 5:2-15 = MIC 5:1-14
NAM 1:15 = NAM 2:1
NAM 2:1-13 = NAM 2:2-14
ZEC 1:18-21 = ZEC 2:1-4
ZEC 2:1-13 = ZEC 2:5-17
MAL 4:1-6 = MAL 3:19-24
ROM 14:24-26 = ROM 16:25-27
# 2CO 11:32 = 2CO 11:32-33
2CO 11:32 = 2CO 11:32
2CO 11:32 = 2CO 11:33
# REV 13:1 = REV 12:18-13:1
REV 13:1 = REV 12:18
REV 13:1 = REV 13:1
#----------------------------
2ES 7:36-70 = 2ES 7:106-140
# 2ES 10:59-60 = 2ES 10:59
2ES 10:59 = 2ES 10:59
2ES 10:60 = 2ES 10:59
#---------------------------------------------------------
# Mapping 2 Esdras onto the older Apocalypse of Ezra [Studge]
2ES 3:1-36 = EZA 1:1-36
2ES 4:1-52 = EZA 2:1-52
2ES 5:1-56 = EZA 3:1-56
2ES 6:1-59 = EZA 4:1-59
2ES 7:1-35 = EZA 5:1-35
2ES 7:106-140 = EZA 5:36-70
2ES 8:1-63 = EZA 6:1-63
2ES 9:1-47 = EZA 7:1-47
2ES 10:1-60 = EZA 8:1-60
2ES 11:1-46 = EZA 9:1-46
2ES 12:1-51 = EZA 10:1-51
2ES 13:1-58 = EZA 11:1-58
2ES 14:1-48 = EZA 12:1-48
#----------------------------------------------------
# Mapping Daniel to Hebrew Daniel and Greek additions [HAB]
DAN 3:24-90 = DAG 3:24-90
DAN 3:91-100 = DAN 3:24-33
# Susanna
DAN 13:1-64 = SUS 1:1-64
# Bel and the Dragon
DAN 14:1-42 = BEL 1:1-42
#--------------------------------------------------
# Mapping Esther Greek onto LXX Esther Greek
#
# This maps the standard verses generated by Create Book
# to the actual verse numbers and segments found in the LXX
# ESG chapter 1
ESG 1:1 = ESG 1:1a
ESG 1:2 = ESG 1:1b
ESG 1:3 = ESG 1:1c
ESG 1:4 = ESG 1:1d
ESG 1:5 = ESG 1:1e
ESG 1:6 = ESG 1:1f
ESG 1:7 = ESG 1:1g
ESG 1:8 = ESG 1:1h
ESG 1:9 = ESG 1:1i
ESG 1:10 = ESG 1:1k
ESG 1:11 = ESG 1:1l
ESG 1:12 = ESG 1:1m
ESG 1:13 = ESG 1:1n
ESG 1:14 = ESG 1:1o
ESG 1:15 = ESG 1:1p
ESG 1:16 = ESG 1:1q
ESG 1:17 = ESG 1:1r
ESG 1:18 = ESG 1:1s
ESG 1:19-39 = ESG 1:2-22
# ESG chapter 3
ESG 3:14 = ESG 3:13a
ESG 3:15 = ESG 3:13b
ESG 3:16 = ESG 3:13c
ESG 3:17 = ESG 3:13d
ESG 3:18 = ESG 3:13e
ESG 3:19 = ESG 3:13f
ESG 3:20 = ESG 3:13g
ESG 3:21 = ESG 3:14
ESG 3:22 = ESG 3:15
# ESG chapter 4
ESG 4:18 = ESG 4:17a
ESG 4:19 = ESG 4:17b
ESG 4:20 = ESG 4:17c
ESG 4:21 = ESG 4:17c
ESG 4:22 = ESG 4:17d
ESG 4:23 = ESG 4:17d
ESG 4:24 = ESG 4:17e
ESG 4:25 = ESG 4:17f
ESG 4:26 = ESG 4:17g
ESG 4:27 = ESG 4:17h
ESG 4:28 = ESG 4:17i
ESG 4:29 = ESG 4:17k
ESG 4:30 = ESG 4:17k
ESG 4:31 = ESG 4:17k
ESG 4:32 = ESG 4:17l
ESG 4:33 = ESG 4:17m
ESG 4:34 = ESG 4:17n
ESG 4:35 = ESG 4:17n
ESG 4:36 = ESG 4:17o
ESG 4:37 = ESG 4:17o
ESG 4:38 = ESG 4:17p
ESG 4:39 = ESG 4:17q
ESG 4:40 = ESG 4:17r
ESG 4:41 = ESG 4:17s
ESG 4:42 = ESG 4:17t
ESG 4:43 = ESG 4:17u
ESG 4:44 = ESG 4:17w
ESG 4:45 = ESG 4:17x
ESG 4:46 = ESG 4:17y
ESG 4:47 = ESG 4:17z
# ESG chapter 5
ESG 5:2 = ESG 5:1a
ESG 5:3 = ESG 5:1a
ESG 5:4 = ESG 5:1a
ESG 5:5 = ESG 5:1b
ESG 5:6 = ESG 5:1c
ESG 5:7 = ESG 5:1d
ESG 5:8 = ESG 5:1e
ESG 5:9 = ESG 5:1f
ESG 5:10 = ESG 5:1f
ESG 5:11 = ESG 5:2
ESG 5:12 = ESG 5:2
ESG 5:13 = ESG 5:2a
ESG 5:14 = ESG 5:2a
ESG 5:15 = ESG 5:2b
ESG 5:16 = ESG 5:2b
ESG 5:17-28 = ESG 5:3-14
# ESG chapter 8
ESG 8:13 = ESG 8:12a
ESG 8:14 = ESG 8:12b
ESG 8:15 = ESG 8:12c
ESG 8:16 = ESG 8:12d
ESG 8:17 = ESG 8:12e
ESG 8:18 = ESG 8:12f
ESG 8:19 = ESG 8:12g
ESG 8:20 = ESG 8:12h
ESG 8:21 = ESG 8:12i
ESG 8:22 = ESG 8:12k
ESG 8:23 = ESG 8:12l
ESG 8:24 = ESG 8:12m
ESG 8:25 = ESG 8:12n
ESG 8:26 = ESG 8:12o
ESG 8:27 = ESG 8:12p
ESG 8:28 = ESG 8:12q
ESG 8:29 = ESG 8:12r
ESG 8:30 = ESG 8:12s
ESG 8:31 = ESG 8:12t
ESG 8:32 = ESG 8:12u
ESG 8:33 = ESG 8:12x
ESG 8:34 = ESG 8:12y
ESG 8:35 = ESG 8:12y
ESG 8:36 = ESG 8:12y
ESG 8:37-41 = ESG 8:13-17
# ESG chapter 10
ESG 10:4 = ESG 10:3a
ESG 10:5 = ESG 10:3b
ESG 10:6 = ESG 10:3c
ESG 10:7 = ESG 10:3d
ESG 10:8 = ESG 10:3e
ESG 10:9 = ESG 10:3f
ESG 10:10 = ESG 10:3g
ESG 10:11 = ESG 10:3h
ESG 10:12 = ESG 10:3i
ESG 10:13 = ESG 10:3k
ESG 10:14 = ESG 10:3l
`;
  }
});

// node_modules/proskomma-core/src/model/versifications/vul_vrs.cjs
var require_vul_vrs = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/vul_vrs.cjs"(exports, module) {
    init_process();
    init_buffer();
    module.exports = `# Versification  "Vulgate"
# Version=1.5
# 
# modifications by Studge 26/June/2009
# this is for Bibles which follow the versification of the Vulgate, mainly Catholic Bibles
# therefore this includes deuterocanonical books from Vulgate and Latin manuscripts
# Vulgate projects in Paratext are VUL83 (Stuttgart text) and NVL98 (Nova Vulgata) [Studge]
#
# mapping for XXA -> PSA has been deleted  [requested by RdB - Barb]
# XXB has been moved to LAO [Barb] Jan 2011
#
# No mapping done for TOB, JDT and SIR, since they seem to follow another 'vorlage' than LXX
# The versification of 2ES present here should become THE standard/original versification of this book! (Vulgate is 'the original' text of this book)
#
# List of books, chapters, verses
# One line per book.
# One entry for each chapter.
# Verse number is the maximum verse number for that chapter.
# See the lines containing ='s below for verse mappings.
#
#-----------------------------------------------------------
# Old Testament
GEN 1:31 2:25 3:24 4:26 5:32 6:22 7:24 8:22 9:29 10:32 11:32 12:20 13:18 14:24 15:21 16:16 17:27 18:33 19:38 20:18 21:34 22:24 23:20 24:67 25:34 26:35 27:46 28:22 29:35 30:43 31:55 32:32 33:20 34:31 35:29 36:43 37:36 38:30 39:23 40:23 41:57 42:38 43:34 44:34 45:28 46:34 47:31 48:22 49:32 50:25
EXO 1:22 2:25 3:22 4:31 5:23 6:30 7:25 8:32 9:35 10:29 11:10 12:51 13:22 14:31 15:27 16:36 17:16 18:27 19:25 20:26 21:36 22:31 23:33 24:18 25:40 26:37 27:21 28:43 29:46 30:38 31:18 32:35 33:23 34:35 35:35 36:38 37:29 38:31 39:43 40:36
LEV 1:17 2:16 3:17 4:35 5:19 6:30 7:38 8:36 9:24 10:20 11:47 12:8 13:59 14:57 15:33 16:34 17:16 18:30 19:37 20:27 21:24 22:33 23:44 24:23 25:55 26:45 27:34
NUM 1:54 2:34 3:51 4:49 5:31 6:27 7:89 8:26 9:23 10:36 11:34 12:15 13:34 14:45 15:41 16:50 17:13 18:32 19:22 20:30 21:35 22:41 23:30 24:25 25:18 26:65 27:23 28:31 29:39 30:17 31:54 32:42 33:56 34:29 35:34 36:13
DEU 1:46 2:37 3:29 4:49 5:33 6:25 7:26 8:20 9:29 10:22 11:32 12:32 13:18 14:29 15:23 16:22 17:20 18:22 19:21 20:20 21:23 22:30 23:25 24:22 25:19 26:19 27:26 28:68 29:29 30:20 31:30 32:52 33:29 34:12
JOS 1:18 2:24 3:17 4:25 5:16 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:43 22:34 23:16 24:33
JDG 1:36 2:23 3:31 4:24 5:32 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:24
RUT 1:22 2:23 3:18 4:22
1SA 1:28 2:36 3:21 4:22 5:12 6:21 7:17 8:22 9:27 10:27 11:15 12:25 13:23 14:52 15:35 16:23 17:58 18:30 19:24 20:43 21:15 22:23 23:28 24:23 25:44 26:25 27:12 28:25 29:11 30:31 31:13
2SA 1:27 2:32 3:39 4:12 5:25 6:23 7:29 8:18 9:13 10:19 11:27 12:31 13:39 14:33 15:37 16:23 17:29 18:33 19:43 20:26 21:22 22:51 23:39 24:25
1KI 1:53 2:46 3:28 4:34 5:18 6:38 7:51 8:66 9:28 10:29 11:43 12:33 13:34 14:31 15:34 16:34 17:24 18:46 19:21 20:43 21:29 22:54
2KI 1:18 2:25 3:27 4:44 5:27 6:33 7:20 8:29 9:37 10:36 11:21 12:21 13:25 14:29 15:38 16:20 17:41 18:37 19:37 20:21 21:26 22:20 23:37 24:20 25:30
1CH 1:54 2:55 3:24 4:43 5:26 6:81 7:40 8:40 9:44 10:14 11:46 12:40 13:14 14:17 15:29 16:43 17:27 18:17 19:19 20:7 21:30 22:19 23:32 24:31 25:31 26:32 27:34 28:21 29:30
2CH 1:17 2:18 3:17 4:22 5:14 6:42 7:22 8:18 9:31 10:19 11:23 12:16 13:22 14:15 15:19 16:14 17:19 18:34 19:11 20:37 21:20 22:12 23:21 24:27 25:28 26:23 27:9 28:27 29:36 30:27 31:21 32:33 33:25 34:33 35:27 36:23
EZR 1:11 2:70 3:13 4:24 5:17 6:22 7:28 8:36 9:15 10:44
# EZR is for the Vulgate book called 1 Esdras
NEH 1:11 2:20 3:31 4:23 5:19 6:19 7:73 8:18 9:38 10:39 11:36 12:46 13:31
# NEH is for the Vulgate book called 2 Esdras
#------------------------------------
# In the Vulgate projects VUL83 Esther is the Greek Esther not Hebrew Esther, this definition is for Greek Esther. The book has been put under EST instead of ESG [Studge]
# in VUL83 the definition of EST is
#EST 1:22 2:23 3:15 4:17 5:14 6:14 7:10 8:17 9:32 10:13 11:12 12:6 13:18 14:19 15:19 16:24
# in NVL98 Nova Vulgata the definition of EST is
EST 1:32 2:23 3:15 4:47 5:28 6:14 7:10 8:41 9:32 10:13 
# Note that chapter 3 v 15 is 15a-i
# Note that chapter 4 v 47 is 17aa-kk
#-----------------------------------
JOB 1:22 2:13 3:26 4:21 5:27 6:30 7:21 8:22 9:35 10:22 11:20 12:25 13:28 14:22 15:35 16:23 17:16 18:21 19:29 20:29 21:34 22:30 23:17 24:25 25:6 26:14 27:23 28:28 29:25 30:31 31:40 32:22 33:33 34:37 35:16 36:33 37:24 38:41 39:35 40:28 41:25 42:16
PSA 1:6 2:13 3:9 4:10 5:13 6:11 7:18 8:10 9:39 10:8 11:9 12:6 13:7 14:5 15:10 16:15 17:51 18:15 19:10 20:14 21:32 22:6 23:10 24:22 25:12 26:14 27:9 28:11 29:13 30:25 31:11 32:22 33:23 34:28 35:13 36:40 37:23 38:14 39:18 40:14 41:12 42:5 43:26 44:18 45:12 46:10 47:15 48:21 49:23 50:21 51:11 52:7 53:9 54:24 55:13 56:12 57:12 58:18 59:14 60:9 61:13 62:12 63:11 64:14 65:20 66:8 67:36 68:37 69:6 70:24 71:20 72:28 73:23 74:11 75:13 76:21 77:72 78:13 79:20 80:17 81:8 82:19 83:13 84:14 85:17 86:7 87:19 88:53 89:17 90:16 91:16 92:5 93:23 94:11 95:13 96:12 97:9 98:9 99:5 100:8 101:29 102:22 103:35 104:45 105:48 106:43 107:14 108:31 109:7 110:10 111:10 112:9 113:26 114:9 115:19 116:2 117:29 118:176 119:7 120:8 121:9 122:4 123:8 124:5 125:6 126:5 127:6 128:8 129:8 130:3 131:18 132:3 133:3 134:21 135:26 136:9 137:8 138:24 139:14 140:10 141:8 142:12 143:15 144:21 145:10 146:11 147:20 148:14 149:9 150:6
PRO 1:33 2:22 3:35 4:27 5:23 6:35 7:27 8:36 9:18 10:32 11:31 12:28 13:25 14:35 15:33 16:33 17:28 18:24 19:29 20:30 21:31 22:29 23:35 24:34 25:28 26:28 27:27 28:28 29:27 30:33 31:31
ECC 1:18 2:26 3:22 4:17 5:19 6:11 7:30 8:17 9:18 10:20 11:10 12:14
SNG 1:16 2:17 3:11 4:16 5:17 6:12 7:13 8:14
ISA 1:31 2:22 3:26 4:6 5:30 6:13 7:25 8:22 9:21 10:34 11:16 12:6 13:22 14:32 15:9 16:14 17:14 18:7 19:25 20:6 21:17 22:25 23:18 24:23 25:12 26:21 27:13 28:29 29:24 30:33 31:9 32:20 33:24 34:17 35:10 36:22 37:38 38:22 39:8 40:31 41:29 42:25 43:28 44:28 45:25 46:13 47:15 48:22 49:26 50:11 51:23 52:15 53:12 54:17 55:13 56:12 57:21 58:14 59:21 60:22 61:11 62:12 63:19 64:12 65:25 66:24
JER 1:19 2:37 3:25 4:31 5:31 6:30 7:34 8:22 9:26 10:25 11:23 12:17 13:27 14:22 15:21 16:21 17:27 18:23 19:15 20:18 21:14 22:30 23:40 24:10 25:38 26:24 27:22 28:17 29:32 30:24 31:40 32:44 33:26 34:22 35:19 36:32 37:20 38:28 39:18 40:16 41:18 42:22 43:13 44:30 45:5 46:28 47:7 48:47 49:39 50:46 51:64 52:34
LAM 1:22 2:22 3:66 4:22 5:22
EZK 1:28 2:9 3:27 4:17 5:17 6:14 7:27 8:18 9:11 10:22 11:25 12:28 13:23 14:23 15:8 16:63 17:24 18:32 19:14 20:49 21:32 22:31 23:49 24:27 25:17 26:21 27:36 28:26 29:21 30:26 31:18 32:32 33:33 34:31 35:15 36:38 37:28 38:23 39:29 40:49 41:26 42:20 43:27 44:31 45:25 46:24 47:23 48:35
#-------------------
# Daniel in NVL98 has 14 chapters and is Greek LXX Daniel
# the Additions to Daniel are repeated in S3Y, SUS and BEL in NVL98
# in NVL98 and VUL83, DAN is used for Greek Daniel and it should be under DAG
DAN 1:21 2:49 3:100 4:34 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13 13:65 14:41
#
#--------------------
HOS 1:11 2:24 3:5 4:19 5:15 6:11 7:16 8:14 9:17 10:15 11:12 12:14 13:15 14:10
JOL 1:20 2:32 3:21
AMO 1:15 2:16 3:15 4:13 5:27 6:15 7:17 8:14 9:15
OBA 1:21
JON 1:16 2:11 3:10 4:11
MIC 1:16 2:13 3:12 4:13 5:14 6:16 7:20
NAM 1:15 2:13 3:19
HAB 1:17 2:20 3:19
ZEP 1:18 2:15 3:20
HAG 1:14 2:24
ZEC 1:21 2:13 3:10 4:14 5:11 6:15 7:14 8:23 9:17 10:12 11:17 12:14 13:9 14:21
MAL 1:14 2:17 3:18 4:6
#--------------------------------------
# New Testament books
MAT 1:25 2:23 3:17 4:25 5:48 6:34 7:29 8:34 9:38 10:42 11:30 12:50 13:58 14:36 15:39 16:28 17:26 18:35 19:30 20:34 21:46 22:46 23:39 24:51 25:46 26:75 27:66 28:20
MRK 1:45 2:28 3:35 4:40 5:43 6:56 7:37 8:39 9:49 10:52 11:33 12:44 13:37 14:72 15:47 16:20
LUK 1:80 2:52 3:38 4:44 5:39 6:49 7:50 8:56 9:62 10:42 11:54 12:59 13:35 14:35 15:32 16:31 17:37 18:43 19:48 20:47 21:38 22:71 23:56 24:53
JHN 1:51 2:25 3:36 4:54 5:47 6:72 7:53 8:59 9:41 10:42 11:57 12:50 13:38 14:31 15:27 16:33 17:26 18:40 19:42 20:31 21:25
ACT 1:26 2:47 3:26 4:37 5:42 6:15 7:59 8:40 9:43 10:48 11:30 12:25 13:52 14:27 15:41 16:40 17:34 18:28 19:40 20:38 21:40 22:30 23:35 24:27 25:27 26:32 27:44 28:31
ROM 1:32 2:29 3:31 4:25 5:21 6:23 7:25 8:39 9:33 10:21 11:36 12:21 13:14 14:23 15:33 16:27
1CO 1:31 2:16 3:23 4:21 5:13 6:20 7:40 8:13 9:27 10:33 11:34 12:31 13:13 14:40 15:58 16:24
2CO 1:24 2:17 3:18 4:18 5:21 6:18 7:16 8:24 9:15 10:18 11:33 12:21 13:13
GAL 1:24 2:21 3:29 4:31 5:26 6:18
EPH 1:23 2:22 3:21 4:32 5:33 6:24
PHP 1:30 2:30 3:21 4:23
COL 1:29 2:23 3:25 4:18
1TH 1:10 2:20 3:13 4:18 5:28
2TH 1:12 2:17 3:18
1TI 1:20 2:15 3:16 4:16 5:25 6:21
2TI 1:18 2:26 3:17 4:22
TIT 1:16 2:15 3:15
PHM 1:25
HEB 1:14 2:18 3:19 4:16 5:14 6:20 7:28 8:13 9:28 10:39 11:40 12:29 13:25
JAS 1:27 2:26 3:18 4:17 5:20
1PE 1:25 2:25 3:22 4:19 5:14
2PE 1:21 2:22 3:18
1JN 1:10 2:29 3:24 4:21 5:21
2JN 1:13
3JN 1:15
JUD 1:25
REV 1:20 2:29 3:22 4:11 5:14 6:17 7:17 8:13 9:21 10:11 11:19 12:18 13:18 14:20 15:8 16:21 17:18 18:24 19:21 20:15 21:27 22:21
#-------------------------------------------------
# Deuterocanonical books in the Catholic tradition
TOB 1:25 2:23 3:25 4:23 5:28 6:22 7:20 8:24 9:12 10:13 11:21 12:22 13:23 14:17
JDT 1:12 2:18 3:15 4:17 5:29 6:21 7:25 8:34 9:19 10:20 11:21 12:20 13:31 14:18 15:15 16:31
#---------
# ESG for Esther Greek has been put under EST in NVL98, a blank ESG was included in VUL83
# this definition for ESG is for the full Esther Greek which is in the Vulgate NVL98 [Studge]
ESG 1:39 2:23 3:22 4:47 5:28 6:14 7:10 8:39 9:32 10:13
#---------
WIS 1:16 2:25 3:19 4:20 5:24 6:27 7:30 8:21 9:19 10:21 11:27 12:27 13:19 14:31 15:19 16:29 17:20 18:25 19:20
SIR 1:40 2:23 3:34 4:36 5:18 6:37 7:40 8:22 9:25 10:34 11:36 12:19 13:32 14:27 15:22 16:31 17:31 18:33 19:28 20:33 21:31 22:33 23:38 24:47 25:36 26:28 27:33 28:30 29:35 30:27 31:42 32:28 33:33 34:31 35:26 36:28 37:34 38:39 39:41 40:32 41:28 42:26 43:37 44:27 45:31 46:23 47:31 48:28 49:19 50:31 51:38 52:13
BAR 1:22 2:35 3:38 4:37 5:9 6:72
LJE 1:72
# NB Letter of Jeremiah is chapter 6 of Baruch in the Vulgate tradition [Studge]
# the 3 additions to Daniel are part of Daniel in the Vulgate tradition [Studge]
S3Y 1:67
SUS 1:64
BEL 1:42
1MA 1:67 2:70 3:60 4:61 5:68 6:63 7:50 8:32 9:73 10:89 11:74 12:54 13:54 14:49 15:41 16:24
2MA 1:36 2:33 3:40 4:50 5:27 6:31 7:42 8:36 9:29 10:38 11:38 12:46 13:26 14:46 15:40
#--------------------------------------------------
# Note that 3MA and 4MA are in the LXX tradition but not in the Vulgate, and not in VUL83 Latin critical text, but maybe in Interconfessional editions [Studge]
3MA 1:29 2:33 3:30 4:21 5:51 6:41 7:23
4MA 1:35 2:24 3:21 4:26 5:38 6:35 7:23 8:29 9:32 10:21 11:27 12:19 13:27 14:20 15:32 16:25 17:24 18:24
#----------------------------------------------------
# 1ES, 2ES, MAN and PS2 are in the Vulgate Apocrypha, but not in modern Catholic Bibles, but maybe in Interconfessional editions [Studge]
1ES 1:58 2:31 3:24 4:63 5:73 6:34 7:15 8:97 9:56
# 1ES is for the Vulgate book called 3 Esdras
2ES 1:40 2:48 3:36 4:52 5:55 6:59 7:139 8:63 9:47 10:60 11:46 12:51 13:58 14:47 15:63 16:78
# 2ES is for the Vulgate book called 4 Esdras
MAN 1:15
PS2 1:7
#-----------------------------------------------------
# ODA and PSS are only in LXX and SYR and not needed in any Vulgate manuscripts or any Catholic Bibles, I am not convinced they are needed in this versification file [Studge]
#ODA 1:19 2:43 3:10 4:19 5:12 6:8 7:20 8:37 9:22 10:9 11:11 12:15 13:4 14:46
#PSS 1:8 2:37 3:12 4:25 5:19 6:6 7:10 8:34 9:11 10:8 11:9 12:6 13:12 14:10 15:13 16:15 17:46 18:12
#------------------------------------------------------
# Variant LXX books, only used in LXX, now obselete in Paratext 7, never part of Vulgate
# if these codes were used in any Vulgate versification projects they used the wrong code, and so the definitions are not relevant [Studge]
# JSA 1:18 2:24 3:17 4:24 5:15 6:27 7:26 8:35 9:27 10:43 11:23 12:24 13:33 14:15 15:63 16:10 17:18 18:28 19:51 20:9 21:45 22:34 23:16 24:33
# JDB 1:36 2:23 3:31 4:24 5:31 6:40 7:25 8:35 9:57 10:18 11:40 12:15 13:25 14:20 15:20 16:31 17:13 18:31 19:30 20:48 21:25
# TBS 1:22 2:14 3:17 4:21 5:23 6:19 7:17 8:21 9:6 10:14 11:19 12:22 13:18 14:15
# SST 1:64
# DNT 1:21 2:49 3:97 4:37 5:30 6:29 7:28 8:27 9:27 10:21 11:45 12:13
# BLT 1:42
#------------------------------------------------------
# add in versifications for 4,5 & 6 Ezra which are in Latin manuscripts [Studge]
5EZ 1:40 2:48 
EZA 1:36 2:52 3:55 4:59 5:139 6:63 7:47 8:60 9:46 10:51 11:58 12:47 
6EZ 1:63 12:78
#------------------------------------------------------
# XXA and XXB books in project VUL83, left for backward compatability
# XXA was used for a variant form of Psalms, but should be in a Latin Variant project [Studge]
# XXA 1:6 2:13 3:9 4:10 5:13 6:11 7:18 8:10 9:39 10:8 11:9 12:6 13:7 14:5 15:10 16:15 17:51 18:15 19:10 20:14 21:32 22:6 23:10 24:22 25:12 26:14 27:9 28:11 29:13 30:25 31:11 32:22 33:23 34:28 35:13 36:40 37:23 38:14 39:18 40:14 41:12 42:5 43:26 44:18 45:12 46:10 47:15 48:21 49:23 50:21 51:11 52:7 53:9 54:24 55:13 56:12 57:12 58:18 59:14 60:9 61:13 62:12 63:11 64:14 65:20 66:8 67:36 68:37 69:6 70:24 71:20 72:28 73:23 74:11 75:13 76:21 77:72 78:13 79:20 80:17 81:8 82:19 83:13 84:14 85:17 86:7 87:19 88:53 89:17 90:16 91:16 92:5 93:23 94:11 95:13 96:12 97:9 98:9 99:5 100:8 101:29 102:22 103:35 104:45 105:48 106:43 107:14 108:31 109:7 110:10 111:10 112:9 113:26 114:9 115:19 116:2 117:29 118:176 119:7 120:8 121:9 122:4 123:8 124:5 125:6 126:5 127:6 128:8 129:8 130:3 131:18 132:3 133:3 134:21 135:26 136:9 137:8 138:24 139:14 140:10 141:8 142:12 143:15 144:21 145:10 146:11 147:20 148:14 149:9 150:6
# XXB was used for the Letter to the Laodiceans, but should be under LAO [Studge]
# XXB 1:20
#----------------------------------------------------------
# Daniel Greek is currently under DAN [Studge]
DAG 1:21 2:49 3:97 4:37 5:31 6:28 7:28 8:27 9:27 10:21 11:45 12:13 13:64 14:42
# Letter to the Laodiceans in the VUL83 and some mediaeval translations of the Vulgate e.g. John Wycliffe's English Bible, appeared after Revelation [Studge]
LAO 1:20
#----------------------------------------------------------
# Mapping
#----------------------------------------------------------
# Vulgate = BHS (see org.vrs)
#
# (Note: for performance reasons ranges must not span a chapter, e.g. 4:10-5:11 is illegal)
#
GEN 31:55 = GEN 32:1
GEN 32:1-32 = GEN 32:2-33
# missing <- GEN 49:32
GEN 49:31 = GEN 49:31
GEN 49:31 = GEN 49:32
GEN 49:32 = GEN 49:33
# GEN 50:22 <- GEN 50:22-23
GEN 50:22 = GEN 50:22
GEN 50:22 = GEN 50:23
GEN 50:23-25 = GEN 50:24-26
EXO 8:1-4 = EXO 7:26-29
EXO 8:5-32 = EXO 8:1-28
EXO 22:1 = EXO 21:37
EXO 22:2-31 = EXO 22:1-30
# EXO 40:13 <- EXO 40:13-15
EXO 40:13 = EXO 40:13
EXO 40:13 = EXO 40:14
EXO 40:13 = EXO 40:15
EXO 40:14-36 = EXO 40:16-38
LEV 6:1-7 = LEV 5:20-26
LEV 6:8-30 = LEV 6:1-23
# LEV 26:45 <- LEV 26:45-46
LEV 26:45 = LEV 26:45
LEV 26:45 = LEV 26:46
# NUM 11:34 <- NUM 11:34-35
NUM 11:34 = NUM 11:34
NUM 11:34 = NUM 11:35
NUM 13:1 = NUM 12:16
NUM 13:2-34 = NUM 13:1-33
NUM 16:36-50 = NUM 17:1-15
NUM 17:1-13 = NUM 17:16-28
# NUM 20:28-29 -> NUM 20:28
NUM 20:28 = NUM 20:28
NUM 20:29 = NUM 20:28
NUM 20:30 = NUM 20:29
# NUM 26:1 <- NUM 25:19--26:1
NUM 26:1 = NUM 25:19
NUM 26:1 = NUM 26:1
DEU 12:32 = DEU 13:1
DEU 13:1-18 = DEU 13:2-19
DEU 22:30 = DEU 23:1
DEU 23:1-25 = DEU 23:2-26
DEU 29:1 = DEU 28:69
DEU 29:2-29 = DEU 29:1-28
# JOS 4:23-24 -> JOS 4:23
JOS 4:23 = JOS 4:23
JOS 4:24 = JOS 4:23
JOS 4:25 = JOS 4:24
# JOS 5:14-15 -> JOS 5:14
JOS 5:14 = JOS 5:14
JOS 5:15 = JOS 5:14
JOS 5:16 = JOS 5:15
# JOS 21:36 (missing) <- JOS 21:36-37
JOS 21:36 = JOS 21:36
JOS 21:36 = JOS 21:37
# JOS 21:37 <- JOS 21:38-39
JOS 21:37 = JOS 21:38
JOS 21:37 = JOS 21:39
JOS 21:38-43 = JOS 21:40-45
# JDG 5:31-32 -> JDG 5:31
JDG 5:31 = JDG 5:31
JDG 5:32 = JDG 5:31
# JDG 21:24 <- JDG 21:24-25
JDG 21:24 = JDG 21:24
JDG 21:24 = JDG 21:25
1SA 20:43 = 1SA 21:1
1SA 21:1-15 = 1SA 21:2-16
2SA 18:33 = 2SA 19:1
2SA 19:1-43 = 2SA 19:2-44
1KI 4:21-34 = 1KI 5:1-14
1KI 5:1-18 = 1KI 5:15-32
2KI 11:21 = 2KI 12:1
2KI 12:1-21 = 2KI 12:2-22
1CH 6:1-15 = 1CH 5:27-41
1CH 6:16-81 = 1CH 6:1-66
# 1CH 11:46 <- 1CH 11:46-47
1CH 11:46 = 1CH 11:46
1CH 11:46 = 1CH 11:47
# 1CH 12:4 <- 1CH 12:4-5
1CH 12:4 = 1CH 12:4
1CH 12:4 = 1CH 12:5
1CH 12:5-40 = 1CH 12:6-41
# 1CH 20:7 <- 1CH 20:7-8
1CH 20:7 = 1CH 20:7
1CH 20:7 = 1CH 20:8
2CH 2:1 = 2CH 1:18
2CH 2:2-18 = 2CH 2:1-17
2CH 14:1 = 2CH 13:23
2CH 14:2-15 = 2CH 14:1-14
# NEH 3:30 <- NEH 3:30-31
NEH 3:30 = NEH 3:30
NEH 3:30 = NEH 3:31
NEH 3:31 = NEH 3:32
NEH 4:1-6 = NEH 3:33-38
NEH 4:7-23 = NEH 4:1-17
# NEH 7:68 (missing) -> NEH 7:67b
NEH 7:67 = NEH 7:67
NEH 7:68 = NEH 7:67
NEH 7:69-73 = NEH 7:68-72
NEH 9:38 = NEH 10:1
NEH 10:1-39 = NEH 10:2-40
# NEH 12:33 <- NEH 12:33-34
NEH 12:33 = NEH 12:33
NEH 12:33 = NEH 12:34
NEH 12:34-46 = NEH 12:35-47
# mapping EST onto ESG, it should map ESG onto EST
#EST 10:4-13 = ESG 1:4-13
#EST 11:1-12 = ESG 2:1-12
#EST 12:1-6 = ESG 3:1-6
#EST 13:1-18 = ESG 4:1-18
#EST 14:1-19 = ESG 5:1-19
#EST 15:1-16 = ESG 6:1-16
#EST 16:1-24 = ESG 7:1-24
# JOB 16:4-5 -> JOB 16:4
JOB 16:4 = JOB 16:4
JOB 16:5 = JOB 16:4
JOB 16:6-23 = JOB 16:5-22
JOB 39:31-35 = JOB 40:1-5
JOB 40:1-27 = JOB 40:6-32
JOB 40:28 = JOB 41:1
JOB 41:1-25 = JOB 41:2-26
# JOB 42:16 <- JOB 42:16-17
JOB 42:16 = JOB 42:16
JOB 42:16 = JOB 42:17
# In PSA, the equivalent mappings (in chs. 1-9; 147-150) are given too, because XXA is mapped to PSA as well !!!
# There could still be some errors regarding the irregular mapping of psalm titles (like in PSA 12:1 <- PSA 13:1-2)
PSA 1:0-6 = PSA 1:0-6
PSA 2:0-11 = PSA 2:0-11
# PSA 2:12-13 -> PSA 2:12
PSA 2:12 = PSA 2:12
PSA 2:13 = PSA 2:12
PSA 3:0-9 = PSA 3:0-9
PSA 4:0-8 = PSA 4:0-8
# PSA 4:9-10 -> PSA 4:9
PSA 4:9 = PSA 4:9
PSA 4:10 = PSA 4:9
PSA 5:0-13 = PSA 5:0-13
PSA 6:0-11 = PSA 6:0-11
PSA 7:0-18 = PSA 7:0-18
PSA 8:0-10 = PSA 8:0-10
PSA 9:0-21 = PSA 9:0-21
PSA 9:22 = PSA 10:0
PSA 9:22-39 = PSA 10:1-18
# PSA 10:1-2 -> PSA 11:1
PSA 10:0-1 = PSA 11:0-1
PSA 10:2 = PSA 11:1
PSA 10:3-8 = PSA 11:2-7
PSA 11:0-9 = PSA 12:0-9
# PSA 12:1 <- PSA 13:1-2
PSA 12:0-1 = PSA 13:0-1
PSA 12:1 = PSA 13:2
# PSA 12:2-3 -> PSA 13:3
PSA 12:2 = PSA 13:3
PSA 12:3 = PSA 13:3
PSA 12:4-6 = PSA 13:4-6
PSA 13:0-7 = PSA 14:0-7
PSA 14:0-1 = PSA 15:0-1
# PSA 14:3a = PSA 15:2b
PSA 14:2 = PSA 15:2
PSA 14:3 = PSA 15:2
PSA 14:3 = PSA 15:3
PSA 14:4-5 = PSA 15:4-5
PSA 15:0-9 = PSA 16:0-9
# PSA 15:10 <- PSA 16:10-11
PSA 15:10 = PSA 16:10
PSA 15:10 = PSA 16:11
PSA 16:0-15 = PSA 17:0-15
PSA 17:0-51 = PSA 18:0-51
PSA 18:0-15 = PSA 19:0-15
PSA 19:0-10 = PSA 20:0-10
PSA 20:0-14 = PSA 21:0-14
PSA 21:0-32 = PSA 22:0-32
PSA 22:0-6 = PSA 23:0-6
PSA 23:0-10 = PSA 24:0-10
PSA 24:0-22 = PSA 25:0-22
PSA 25:0-12 = PSA 26:0-12
PSA 26:0-14 = PSA 27:0-14
PSA 27:0-9 = PSA 28:0-9
PSA 28:0-11 = PSA 29:0-11
PSA 29:0-13 = PSA 30:0-13
PSA 30:0-25 = PSA 31:0-25
PSA 31:0-11 = PSA 32:0-11
PSA 32:0-22 = PSA 33:0-22
PSA 33:0-23 = PSA 34:0-23
PSA 34:0-28 = PSA 35:0-28
PSA 35:0-13 = PSA 36:0-13
PSA 36:0-40 = PSA 37:0-40
PSA 37:0-23 = PSA 38:0-23
PSA 38:0-14 = PSA 39:0-14
PSA 39:0-18 = PSA 40:0-18
PSA 40:0-14 = PSA 41:0-14
PSA 41:0-12 = PSA 42:0-12
PSA 42:0-5 = PSA 43:0-5
PSA 43:0-21 = PSA 44:0-21
# PSA 43:22 <- PSA 44:22-23
PSA 43:22 = PSA 44:22
PSA 43:22 = PSA 44:23
PSA 43:23-26 = PSA 44:24-27
PSA 44:0-18 = PSA 45:0-18
PSA 45:0-12 = PSA 46:0-12
PSA 46:0-10 = PSA 47:0-10
PSA 47:0-15 = PSA 48:0-15
PSA 48:0-21 = PSA 49:0-21
PSA 49:0-23 = PSA 50:0-23
PSA 50:0-21 = PSA 51:0-21
PSA 51:0-11 = PSA 52:0-11
PSA 52:0-7 = PSA 53:0-7
PSA 53:0-9 = PSA 54:0-9
PSA 54:0-24 = PSA 55:0-24
PSA 55:0-10 = PSA 56:0-10
# PSA 55:11 <- PSA 56:11-12
PSA 55:11 = PSA 56:11
PSA 55:11 = PSA 56:12
PSA 55:12-13 = PSA 56:13-14
PSA 56:0-12 = PSA 57:0-12
PSA 57:0-12 = PSA 58:0-12
PSA 58:0-18 = PSA 59:0-18
PSA 59:0-14 = PSA 60:0-14
PSA 60:0-9 = PSA 61:0-9
PSA 61:0-13 = PSA 62:0-13
PSA 62:0-12 = PSA 63:0-12
PSA 63:0-11 = PSA 64:0-11
PSA 64:0-14 = PSA 65:0-14
PSA 65:0-20 = PSA 66:0-20
PSA 66:0-8 = PSA 67:0-8
PSA 67:0-36 = PSA 68:0-36
PSA 68:0-37 = PSA 69:0-37
PSA 69:0-6 = PSA 70:0-6
PSA 70:0-24 = PSA 71:0-24
PSA 71:0-20 = PSA 72:0-20
PSA 72:0-28 = PSA 73:0-28
PSA 73:0-23 = PSA 74:0-23
PSA 74:0-11 = PSA 75:0-11
PSA 75:0-13 = PSA 76:0-13
PSA 76:0-21 = PSA 77:0-21
PSA 77:0-72 = PSA 78:0-72
PSA 78:0-13 = PSA 79:0-13
PSA 79:0-20 = PSA 80:0-20
PSA 80:0-17 = PSA 81:0-17
PSA 81:0-8 = PSA 82:0-8
PSA 82:0-19 = PSA 83:0-19
PSA 83:0-13 = PSA 84:0-13
PSA 84:0-14 = PSA 85:0-14
PSA 85:0-17 = PSA 86:0-17
PSA 86:0-7 = PSA 87:0-7
PSA 87:0-19 = PSA 88:0-19
PSA 88:0-53 = PSA 89:0-53
PSA 89:0-17 = PSA 90:0-17
PSA 90:0-16 = PSA 91:0-16
PSA 91:0-16 = PSA 92:0-16
PSA 92:0-5 = PSA 93:0-5
PSA 93:0-23 = PSA 94:0-23
PSA 94:0-11 = PSA 95:0-11
PSA 95:0-13 = PSA 96:0-13
PSA 96:0-12 = PSA 97:0-12
PSA 97:0-9 = PSA 98:0-9
PSA 98:0-9 = PSA 99:0-9
PSA 99:0-5 = PSA 100:0-5
PSA 100:0-8 = PSA 101:0-8
PSA 101:0-29 = PSA 102:0-29
PSA 102:0-22 = PSA 103:0-22
PSA 103:0-35 = PSA 104:0-35
PSA 104:0-45 = PSA 105:0-45
PSA 105:0-48 = PSA 106:0-48
PSA 106:0-43 = PSA 107:0-43
PSA 107:0-14 = PSA 108:0-14
PSA 108:0-31 = PSA 109:0-31
PSA 109:0-7 = PSA 110:0-7
PSA 110:0-10 = PSA 111:0-10
PSA 111:0-10 = PSA 112:0-10
PSA 112:0-9 = PSA 113:0-9
PSA 113:0-8 = PSA 114:0-8
PSA 113:9 = PSA 115:0
PSA 113:9-26 = PSA 115:1-18
PSA 114:1-9 = PSA 116:1-9
# What does 115:1-9 map to?  this seems very wrong
PSA 115:10-19 = PSA 116:10-19
PSA 116:0-2 = PSA 117:0-2
PSA 117:0-29 = PSA 118:0-29
PSA 118:0-176 = PSA 119:0-176
PSA 119:0-7 = PSA 120:0-7
PSA 120:0-8 = PSA 121:0-8
PSA 121:0-9 = PSA 122:0-9
PSA 122:0-4 = PSA 123:0-4
PSA 123:0-8 = PSA 124:0-8
PSA 124:0-5 = PSA 125:0-5
PSA 125:0-6 = PSA 126:0-6
PSA 126:0-5 = PSA 127:0-5
PSA 127:0-6 = PSA 128:0-6
PSA 128:0-8 = PSA 129:0-8
PSA 129:0-8 = PSA 130:0-8
PSA 130:0-3 = PSA 131:0-3
PSA 131:0-18 = PSA 132:0-18
PSA 132:0-3 = PSA 133:0-3
PSA 133:0-3 = PSA 134:0-3
PSA 134:0-21 = PSA 135:0-21
PSA 135:0-26 = PSA 136:0-26
PSA 136:0-9 = PSA 137:0-9
PSA 137:0-8 = PSA 138:0-8
PSA 138:0-24 = PSA 139:0-24
PSA 139:0-14 = PSA 140:0-14
PSA 140:0-10 = PSA 141:0-10
PSA 141:0-8 = PSA 142:0-8
PSA 142:0-12 = PSA 143:0-12
PSA 143:0-15 = PSA 144:0-15
PSA 144:0-21 = PSA 145:0-21
# PSA 145:2a = PSA 146:1b
PSA 145:0-1 = PSA 146:0-1
PSA 145:2 = PSA 146:1
PSA 145:2 = PSA 146:2
PSA 145:3-10 = PSA 146:3-10
PSA 146:0-11 = PSA 147:0-11
PSA 147:12-20 = PSA 147:12-20
PSA 148:0-14 = PSA 148:0-14
PSA 149:0-9 = PSA 149:0-9
PSA 150:0-6 = PSA 150:0-6
ECC 7:1 = ECC 6:12
ECC 7:2-30 = ECC 7:1-29
SNG 1:1 = SNG 1:1
SNG 1:1-16 = SNG 1:2-17
SNG 5:17 = SNG 6:1
SNG 6:1-11 = SNG 6:2-12
# SNG 6:12 -> SNG 7:1a
# SNG 7:1 <- SNG 7:1b-2
# or:  SNG 6:12--7:1 = SNG 7:1-2
SNG 6:12 = SNG 7:1
SNG 7:1 = SNG 7:1
SNG 7:1 = SNG 7:2
SNG 7:2-13 = SNG 7:3-14
# ISA 8:22d = ISA 8:23a
ISA 8:22 = ISA 8:22
ISA 8:22 = ISA 8:23
ISA 9:1 = ISA 8:23
ISA 9:2-21 = ISA 9:1-20
# ISA 9:20d = ISA 9:20ab
ISA 9:20 = ISA 9:19
ISA 9:20 = ISA 9:20
ISA 9:21 = ISA 9:20
# ISA 64:1 -> ISA 63:19cd
ISA 63:19 = ISA 63:19
ISA 64:1 = ISA 63:19
ISA 64:2-12 = ISA 64:1-11
JER 9:1 = JER 8:23
JER 9:2-26 = JER 9:1-25
# JER 37:4 <- JER 37:4-5
JER 37:4 = JER 37:4
JER 37:4 = JER 37:5
JER 37:5-20 = JER 37:6-21
# EZK 2:9 <- EZK 2:9-10
EZK 2:9 = EZK 2:9
EZK 2:9 = EZK 2:10
EZK 20:45-49 = EZK 21:1-5
EZK 21:1-32 = EZK 21:6-37
DAN 3:24-90 = S3Y 1:1-67
DAN 3:91-100 = DAN 3:24-33
DAN 5:31 = DAN 6:1
DAN 6:1-28 = DAN 6:2-29
DAN 13:1-64 = SUS 1:1-64
DAN 13:65 = BEL 1:1
DAN 14:1 = BEL 1:1
DAN 14:2-41 = BEL 1:2-41
HOS 1:10-11 = HOS 2:1-2
HOS 2:1-22 = HOS 2:3-24
# HOS 2:23-24 -> HOS 2:25
HOS 2:23 = HOS 2:25
HOS 2:24 = HOS 2:25
HOS 11:12 = HOS 12:1
HOS 12:1-14 = HOS 12:2-15
JOL 2:28-32 = JOL 3:1-5
JOL 3:1-21 = JOL 4:1-21
# AMO 6:10-11 -> AMO 6:10
AMO 6:10 = AMO 6:10
AMO 6:11 = AMO 6:10
AMO 6:12-15 = AMO 6:11-14
MIC 5:1 = MIC 4:14
MIC 5:2-10 = MIC 5:1-9
# MIC 5:11 <- MIC 5:10-11
MIC 5:11 = MIC 5:10
MIC 5:11 = MIC 5:11
# MIC 5:12-14 = MIC 5:12-14
JON 1:17 = JON 2:1
JON 2:1-10 = JON 2:2-11
NAM 1:15 = NAM 2:1
NAM 2:1-13 = NAM 2:2-14
HAG 2:1 = HAG 1:15
HAG 2:2-24 = HAG 2:1-23
ZEC 1:18-21 = ZEC 2:1-4
ZEC 2:1-13 = ZEC 2:5-17
MAL 4:1-6 = MAL 3:19-24
#
#
# Mapping
# Vulgate = UBS GNT
#
#
# MAT 17:14 <- MAT 17:14-15
MAT 17:15-26 = MAT 17:16-27
# MRK 4:40 <- MRK 4:40-41
MRK 4:40 = MRK 4:40
MRK 4:40 = MRK 4:41
MRK 8:39 = MRK 9:1
MRK 9:1-49 = MRK 9:2-50
# JHN 6:51-52 -> JHN 6:51
JHN 6:51 = JHN 6:51
JHN 6:52 = JHN 6:51
JHN 6:53-72 = JHN 6:52-71
# ACT 7:55 <- ACT 7:55-56
ACT 7:55 = ACT 7:55
ACT 7:55 = ACT 7:56
ACT 7:56-59 = ACT 7:57-60
# ACT 14:6 <- ACT 14:6-7
ACT 14:6 = ACT 14:6
ACT 14:6 = ACT 14:7
ACT 14:7-27 = ACT 14:8-28
#
#
#
# Mapping
# Vulgate = +/-LXX
#
#
# WIS 2:24-25 -> WIS 2:24
WIS 2:24 = WIS 2:24
WIS 2:25 = WIS 2:24
# WIS 5:13-14 -> WIS 5:13
WIS 5:13 = WIS 5:13
WIS 5:14 = WIS 5:13
WIS 5:15-24 = WIS 5:14-23
# WIS 6:1 -> missing
WIS 6:2-21 = WIS 6:1-20
WIS 6:22 = WIS 6:21
WIS 6:23 = WIS 6:21
# WIS 6:23 -> missing
WIS 6:24-27 = WIS 6:22-25
# WIS 9:18-19 -> WIS 9:18
WIS 9:18 = WIS 9:18
WIS 9:19 = WIS 9:18
# WIS 11:5-6 -> WIS 11:5
WIS 11:5 = WIS 11:5
WIS 11:6 = WIS 11:5
WIS 11:7-27 = WIS 11:6-26
# WIS 19:12 <- WIS 19:12-13
WIS 19:12 = WIS 19:12
WIS 19:12 = WIS 19:13
WIS 19:13-19 = WIS 19:14-20
# WIS 19:20 <- WIS 19:21-22
WIS 19:20 = WIS 19:21
WIS 19:20 = WIS 19:22
BAR 6:1-72 = LJE 1:1-72
# 1MA 1:4-5 -> 1MA 1:4
1MA 1:4 = 1MA 1:4
1MA 1:5 = 1MA 1:4
1MA 1:6-31 = 1MA 1:5-30
# 1MA 1:31-32 -> 1MA 1:30
1MA 1:31 = 1MA 1:30
1MA 1:32 = 1MA 1:30
1MA 1:33-35 = 1MA 1:31-33
# 1MA 1:36ab <- 1MA 1:34
# 1MA 1:36bc = 1MA 1:35a
# 1MA 1:37 -> 1MA 1:35b
1MA 1:36 = 1MA 1:34
1MA 1:36 = 1MA 1:35
1MA 1:37 = 1MA 1:35
1MA 1:38-46 = 1MA 1:36-44
# 1MA 1:47-48 -> 1MA 1:45
1MA 1:47 = 1MA 1:45
1MA 1:48 = 1MA 1:45
1MA 1:49-67 = 1MA 1:46-64
# 1MA 12:53-54 -> 1MA 12:53
1MA 12:53 = 1MA 12:53
1MA 12:54 = 1MA 12:53
# 1MA 13:52-53 -> 1MA 13:52
1MA 13:52 = 1MA 13:52
1MA 13:53 = 1MA 13:52
1MA 13:54 = 1MA 13:53
# 2MA 2:18-19 -> 2MA 2:18
2MA 2:18 = 2MA 2:18
2MA 2:19 = 2MA 2:18
2MA 2:20-33 = 2MA 2:19-32
# 2MA 12:45-46 -> 2MA 12:45
2MA 12:45 = 2MA 12:45
2MA 12:46 = 2MA 12:45
# 2MA 15:36-37 -> 2MA 15:36
2MA 15:36 = 2MA 15:36
2MA 15:37 = 2MA 15:36
2MA 15:38-40 = 2MA 15:37-39
#
#
# For 1ES the mapping info is taken from the Bible Works program
# mapping Vulgate onto LXX
#
1ES 1:4 = 1ES 1:3
1ES 1:4 = 1ES 1:4
1ES 1:5 = 1ES 1:4
1ES 1:5 = 1ES 1:5
1ES 1:10 = 1ES 1:10
1ES 1:10 = 1ES 1:11
1ES 1:11 = 1ES 1:12
1ES 1:12 = 1ES 1:13
1ES 1:13 = 1ES 1:13
1ES 1:13 = 1ES 1:14
1ES 1:14 = 1ES 1:14
1ES 1:15 = 1ES 1:15
1ES 1:16 = 1ES 1:15
1ES 1:17 = 1ES 1:16
1ES 1:18 = 1ES 1:16
1ES 1:19-50 = 1ES 1:17-48
1ES 1:51 = 1ES 1:49
1ES 1:52 = 1ES 1:49
1ES 1:53-58 = 1ES 1:50-55
1ES 2:1 = 1ES 2:1
1ES 2:2 = 1ES 2:1
1ES 2:3 = 1ES 2:2
1ES 2:4 = 1ES 2:2
1ES 2:5 = 1ES 2:3
1ES 2:6 = 1ES 2:4
1ES 2:7 = 1ES 2:4
1ES 2:8 = 1ES 2:5
1ES 2:9 = 1ES 2:6
1ES 2:10 = 1ES 2:7
1ES 2:11 = 1ES 2:8
1ES 2:12 = 1ES 2:8
1ES 2:13 = 1ES 2:9
1ES 2:13 = 1ES 2:10
1ES 2:14 = 1ES 2:11
1ES 2:15 = 1ES 2:11
1ES 2:16-19 = 1ES 2:12-15
1ES 2:20 = 1ES 2:16
1ES 2:21 = 1ES 2:16
1ES 2:22 = 1ES 2:17
1ES 2:23 = 1ES 2:17
1ES 2:24 = 1ES 2:18
1ES 2:25 = 1ES 2:19
1ES 2:26 = 1ES 2:20
1ES 2:26 = 1ES 2:21
1ES 2:27 = 1ES 2:21
1ES 2:27 = 1ES 2:22
1ES 2:28 = 1ES 2:23
1ES 2:29 = 1ES 2:24
1ES 2:30 = 1ES 2:25
1ES 2:30 = 1ES 2:26
1ES 3:14 = 1ES 3:14
1ES 3:15 = 1ES 3:14
1ES 3:16 = 1ES 3:15
1ES 3:17 = 1ES 3:16
1ES 3:17 = 1ES 3:17
1ES 4:10 = 1ES 4:10
1ES 4:10 = 1ES 4:11
1ES 4:11 = 1ES 4:11
1ES 4:33 = 1ES 4:33
1ES 4:33 = 1ES 4:34
1ES 4:39 = 1ES 4:39
1ES 4:40 = 1ES 4:39
1ES 4:40 = 1ES 4:40
1ES 5:41 = 1ES 5:41
1ES 5:42 = 1ES 5:41
1ES 5:43-53 = 1ES 5:42-52
1ES 5:54 = 1ES 5:53
1ES 5:55 = 1ES 5:53
1ES 5:56 = 1ES 5:54
1ES 5:57 = 1ES 5:55
1ES 5:58 = 1ES 5:56
1ES 5:58 = 1ES 5:57
1ES 5:59 = 1ES 5:57
1ES 5:60 = 1ES 5:57
1ES 5:61-72 = 1ES 5:58-69
1ES 5:73 = 1ES 5:70
1ES 5:73 = 1ES 5:71
1ES 6:8 = 1ES 6:8
1ES 6:9 = 1ES 6:8
1ES 6:10-34 = 1ES 6:9-33
1ES 8:5 = 1ES 8:5
1ES 8:6 = 1ES 8:5
1ES 8:6 = 1ES 8:6
1ES 8:13 = 1ES 8:13
1ES 8:14 = 1ES 8:13
1ES 8:14 = 1ES 8:14
1ES 8:19 = 1ES 8:19
1ES 8:20 = 1ES 8:19
1ES 8:20 = 1ES 8:20
1ES 8:43 = 1ES 8:43
1ES 8:44 = 1ES 8:43
1ES 8:45-49 = 1ES 8:44-48
1ES 8:50 = 1ES 8:49
1ES 8:50 = 1ES 8:50
1ES 8:56 = 1ES 8:56
1ES 8:57 = 1ES 8:56
1ES 8:58-62 = 1ES 8:57-61
1ES 8:63 = 1ES 8:62
1ES 8:64 = 1ES 8:62
1ES 8:65 = 1ES 8:63
1ES 8:66 = 1ES 8:63
1ES 8:67-85 = 1ES 8:64-82
1ES 8:86 = 1ES 8:83
1ES 8:86 = 1ES 8:84
1ES 8:87 = 1ES 8:84
1ES 8:88-92 = 1ES 8:85-89
1ES 8:93 = 1ES 8:90
1ES 8:94 = 1ES 8:90
1ES 8:95 = 1ES 8:91
1ES 8:96 = 1ES 8:92
#
#--------------------------------------------------------------------------
# mapping XXA onto PSA, XXA should be in a variant Vulgate project [Studge]
# Both PSA and XXA are synchronized to PSA in the original versification.
# Is this allowed???
# by request of RdB, XXA mapping to PSA has been deleted - [Barb] 20110127
# XXA has been moved to PSA and the old PSA is now the Resource VULGP83 [Barb]
# There could still be some errors regarding the irregular mapping of psalm titles (like in PSA 12:1 <- PSA 13:1-2)
#
#
#-------------------------------------------------------
# Removing the following lines (FB 52696)
#2ES 3:1-36 = EZA 1:1-36
#2ES 4:1-52 = EZA 2:1-52
#2ES 5:1-56 = EZA 3:1-56
#2ES 6:1-59 = EZA 4:1-59
#2ES 7:1-35 = EZA 5:1-35
#2ES 7:106-140 = EZA 5:36-70
#2ES 8:1-63 = EZA 6:1-63
#2ES 9:1-47 = EZA 7:1-47
#2ES 10:1-60 = EZA 8:1-60
#2ES 11:1-46 = EZA 9:1-46
#2ES 12:1-51 = EZA 10:1-51
#2ES 13:1-58 = EZA 11:1-58
#2ES 14:1-48 = EZA 12:1-48
#-----------------------------------------------------
# map Letter to the Laodiceans [Studge]
# XXB 1:1-7 = LAO 1:1-7
#-----------------------------------------------------
# map Esther Greek onto Hebrew Esther [Studge]
# to be added in
#-----------------------------------------------------
# Mapping Additions to Daniel onto Hebrew Daniel [Studge]
DAG 1:1-21 = DAN 1:1-21
DAG 2:1-49 = DAN 2:1-49
DAG 3:24-52 = S3Y 1:1-29
DAG 3:52-23 = S3Y 1:30-31
DAG 3:54 = S3Y 1:33
DAG 3:55 = S3Y 1:32
DAG 3:56-57 = S3Y 1:34-35
DAG 3:58 = S3Y 1:37
DAG 3:59 = S3Y 1:36
DAG 3:60-90 = S3Y 1:38-68
DAG 3:91-97 = DAN 3:24-30
DAG 4:1-3 = DAN 3:31-33
DAG 4:4-37 = DAN 4:1-34
DAG 5:1-31 = DAN 5:1-31
DAG 6:1-28 = DAN 6:1-28
DAG 7:1-28 = DAN 7:1-28
DAG 8:1-27 = DAN 8:1-27
DAG 9:1-27 = DAN 9:1-27
DAG 10:1-21 = DAN 10:1-21
DAG 11:1-45 = DAN 11:1-45 
DAG 12:1-13 = DAN 12:1-13
# Susanna
DAG 13:1-63 = SUS 1:63
# Bel and the Dragon
DAG 14:1-42 = BEL 1:42
#-------------------------------------------------------
`;
  }
});

// node_modules/proskomma-core/src/model/versifications/index.cjs
var require_versifications = __commonJS({
  "node_modules/proskomma-core/src/model/versifications/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var engText = require_eng_vrs();
    var lxxText = require_lxx_vrs();
    var orgText = require_org_vrs();
    var rscText = require_rsc_vrs();
    var rsoText = require_rso_vrs();
    var vulText = require_vul_vrs();
    var exporting = {
      eng: { raw: engText },
      lxx: { raw: lxxText },
      org: { raw: orgText },
      rsc: { raw: rscText },
      rso: { raw: rsoText },
      vul: { raw: vulText }
    };
    var cvRegex = /^([A-Z0-9]{3}) (([0-9]+:[0-9]+) ?)*$/;
    for (const [vrsName, vrsRecord] of Object.entries(exporting)) {
      vrsRecord.cv = {};
      const lineMatches = vrsRecord.raw.split("\n").filter((l) => l.match(cvRegex));
      if (!lineMatches) {
        continue;
      }
      for (const line of lineMatches) {
        const cvBook = line.slice(0, 3);
        vrsRecord.cv[cvBook] = {};
        for (const cvString of line.substr(4).split(" ")) {
          const [c, v] = cvString.split(":");
          vrsRecord.cv[cvBook][c] = v;
        }
      }
    }
    module.exports = exporting;
  }
});

// node_modules/proskomma-core/src/graph/queries/index.cjs
var require_queries = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { bookCodeCompareFunctions } = require_sort5();
    var versifications = require_versifications();
    var querySchemaString = `
"""The top level of Proskomma queries"""
type Query {
  """The id of the processor, which is different for each Proskomma instance"""
  id: String!
  """A string describing the processor class"""
  processor: String!
  """The NPM package version"""
  packageVersion: String!
  """The selectors used to define docSets"""
  selectors: [selectorSpec!]!
  """The number of docSets"""
  nDocSets: Int!
  """The docSets in the processor"""
  docSets(
    """A whitelist of ids of docSets to include"""
    ids: [String!]
    """Only return docSets that match the list of selector values"""
    withSelectors: [InputKeyValue!]
    """Only return docSets containing a document with the specified bookCode"""
    withBook: String
    """Only return docSets with all the specified tags"""
    withTags: [String!]
    """Only return docSets with none of the specified tags"""
    withoutTags: [String!]
  ): [DocSet!]!
  """The docSet with the specified id"""
  docSet(
    """The id of the docSet"""
    id: String!
  ): DocSet
  """The number of documents in the processor"""
  nDocuments: Int!
  """The documents in the processor"""
  documents(
    """A whitelist of ids of documents to include"""
    ids: [String!]
    """Only return documents with the specified bookCode"""
    withBook: String
    """Only return documents with the specified header key/values"""
    withHeaderValues: [InputKeyValue!]
    """Only return documents with all the specified tags"""
    withTags: [String!]
    """Only return documents with none of the specified tags"""
    withoutTags: [String!]
    """Sort returned documents by the designated method (currently ${Object.keys(bookCodeCompareFunctions).join(", ")})"""
    sortedBy: String
  ): [Document!]!
  """The document with the specified id, or the specified docSet and withBook"""
  document(
    """The id of the document"""
    id: String
    """The docSet of the document (use with withBook)"""
    docSetId: String
    """The book of the document (use with docSetId)"""
    withBook: String
  ) : Document
  """Reference information about standard versifications"""
  versifications: [versification!]!
  """Reference information about a named, standard versification"""
  versification(
    """The id of the versification"""
    id: String!
  ) : versification!
}
`;
    var queryResolvers = {
      id: (root) => root.processorId,
      selectors: (root) => root.selectors,
      docSets: (root, args) => {
        const docSetMatchesSelectors = (ds, selectors) => {
          for (const selector of selectors) {
            if (ds.selectors[selector.key].toString() !== selector.value) {
              return false;
            }
          }
          return true;
        };
        let ret = ("withBook" in args ? root.docSetsWithBook(args.withBook) : Object.values(root.docSets)).filter((ds) => !args.ids || args.ids.includes(ds.id));
        if (args.withSelectors) {
          ret = ret.filter((ds) => docSetMatchesSelectors(ds, args.withSelectors));
        }
        if (args.withTags) {
          ret = ret.filter((ds) => args.withTags.filter((t) => ds.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((ds) => args.withoutTags.filter((t) => ds.tags.has(t)).length === 0);
        }
        return ret;
      },
      docSet: (root, args) => root.docSetById(args.id),
      documents: (root, args) => {
        const headerValuesMatch = (docHeaders, requiredHeaders) => {
          for (const requiredHeader of requiredHeaders || []) {
            if (!(requiredHeader.key in docHeaders) || docHeaders[requiredHeader.key] !== requiredHeader.value) {
              return false;
            }
          }
          return true;
        };
        let ret = args.withBook ? root.documentsWithBook(args.withBook) : root.documentList();
        ret = ret.filter((d) => !args.ids || args.ids.includes(d.id));
        if (args.withHeaderValues) {
          ret = ret.filter((d) => headerValuesMatch(d.headers, args.withHeaderValues));
        }
        if (args.withTags) {
          ret = ret.filter((d) => args.withTags.filter((t) => d.tags.has(t)).length === args.withTags.length);
        }
        if (args.withoutTags) {
          ret = ret.filter((d) => args.withoutTags.filter((t) => d.tags.has(t)).length === 0);
        }
        if (args.sortedBy) {
          if (!(args.sortedBy in bookCodeCompareFunctions)) {
            throw new Error(`sortedBy value must be one of [${Object.keys(bookCodeCompareFunctions).join(", ")}], not ${args.sortedBy}`);
          }
          ret.sort(bookCodeCompareFunctions[args.sortedBy]);
        }
        return ret;
      },
      document: (root, args) => {
        if (args.id && !args.docSetId && !args.withBook) {
          return root.documentById(args.id);
        } else if (!args.id && args.docSetId && args.withBook) {
          return root.documentsWithBook(args.withBook).filter((d) => d.docSetId === args.docSetId)[0];
        } else {
          throw new Error("document requires either id or both docSetId and withBook (but not all three)");
        }
      },
      versifications: () => Object.entries(versifications),
      versification: (root, args) => Object.entries(versifications).filter((v) => v[0] === args.id)[0]
    };
    module.exports = {
      querySchemaString,
      queryResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/selector_spec.cjs
var require_selector_spec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/selector_spec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var selectorSpecSchemaString = `
"""Specification of a selector"""
type selectorSpec {
  """Name (ie the key)"""
  name: String!
  """Data type (string or integer)"""
  type: String!
  """Regex for validating string selector"""
  regex: String
  """Inclusive minimum value for integer selector"""
  min: String
  """Inclusive maximum value for integer selector"""
  max: String
  """Enum of permitted string values"""
  enum: [String!]
}
`;
    var selectorSpecResolvers = {
      regex: (root) => root.regex || null,
      min: (root) => root.min || null,
      max: (root) => root.max || null,
      enum: (root) => root.enum || null
    };
    module.exports = {
      selectorSpecSchemaString,
      selectorSpecResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/input_selector_spec.cjs
var require_input_selector_spec = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/input_selector_spec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var inputSelectorSpecSchemaString = `
"""Input specification of a selector"""
input inputSelectorSpec {
  """Name (ie the key)"""
  name: String!
  """Data type (string or integer)"""
  type: String!
  """Regex for validating string selector"""
  regex: String
  """Inclusive minimum value for integer selector"""
  min: String
  """Inclusive maximum value for integer selector"""
  max: String
  """Enum of permitted string values"""
  enum: [String!]
}
`;
    module.exports = { inputSelectorSpecSchemaString };
  }
});

// node_modules/proskomma-core/src/graph/lib/remake_blocks.cjs
var require_remake_blocks = __commonJS({
  "node_modules/proskomma-core/src/graph/lib/remake_blocks.cjs"(exports, module) {
    init_process();
    init_buffer();
    var remakeBlocks = (docSet, document2, sequence, blocksSpec) => {
      const nBlocks = sequence.blocks.length;
      for (let blockN = 0; blockN < nBlocks; blockN++) {
        document2.deleteBlock(sequence.id, 0, false);
      }
      for (let blockN = 0; blockN < blocksSpec.length; blockN++) {
        const block2 = blocksSpec[blockN];
        document2.newBlock(sequence.id, blockN, block2.bs.payload, null, false);
        const bgResult = docSet.updateBlockGrafts(
          document2.id,
          sequence.id,
          blockN,
          block2.bg
        );
        if (!bgResult) {
          return false;
        }
        const osResult = docSet.updateOpenScopes(
          document2.id,
          sequence.id,
          blockN,
          block2.os
        );
        if (!osResult) {
          return false;
        }
        const isResult = docSet.updateIncludedScopes(
          document2.id,
          sequence.id,
          blockN,
          block2.is
        );
        if (!isResult) {
          return false;
        }
        const itemsResult = docSet.updateItems(
          document2.id,
          sequence.id,
          blockN,
          block2.items
        );
        if (!itemsResult) {
          return false;
        }
      }
    };
    module.exports = { remakeBlocks };
  }
});

// node_modules/proskomma-core/src/graph/mutations/add.cjs
var require_add = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/add.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { remakeBlocks } = require_remake_blocks();
    var addMutationsSchemaString = `
  """Adds a document which will be assigned to an existing or new docSet on the basis of the specified selectors"""
  addDocument(
    """The selectors for this document, the keys of which must match those of the Proskomma instance"""
    selectors: [InputKeyValue!]!
    """The format of the content (probably usfm or usx)"""
    contentType: String!
    """The document content as a string"""
    content: String!
    """A list of tags to be added"""
    tags: [String!]
  ): Boolean!
  """Creates a new, empty sequence"""
  newSequence(
    """The id of the document to which the sequence will be added"""
    documentId: String!
    """The type of the new sequence (main, heading...)"""
    type: String!
    """The JSON describing blocks, if any, for the new sequence"""
    blocksSpec: [inputBlockSpec!]
    """If true, graft to the first block of the main sequence"""
    graftToMain: Boolean
    """'A list of tags to be added"""
    tags: [String!]
  ): String!
  """Adds a new block to a sequence"""
  newBlock(
    """The id of the document containing the sequence to which the block will be added"""
    documentId: String!
    """The id of the sequence to which the block will be added"""
    sequenceId: String!
    """The zero-indexed position at which to add the block"""
    blockN: Int!
    """The scope to be applied to the block, eg blockScope/p"""
    blockScope: String!
  ): Boolean!
`;
    var addMutationsResolvers = {
      addDocument: (root, args) => {
        const selectorsObject = {};
        args.selectors.forEach(
          (s) => {
            selectorsObject[s.key] = s.value;
          }
        );
        return !!root.importDocument(selectorsObject, args.contentType, args.content, null, null, null, args.tags || []);
      },
      newSequence: (root, args) => {
        const document2 = root.documents[args.documentId];
        const docSet = document2.processor.docSets[document2.docSetId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        const newSeqId = document2.newSequence(args.type, args.tags);
        if (args.blocksSpec) {
          remakeBlocks(docSet, document2, document2.sequences[newSeqId], args.blocksSpec);
          document2.buildChapterVerseIndex();
        }
        if (args.graftToMain) {
          docSet.maybeBuildPreEnums();
          const mainSequenceBG = document2.sequences[document2.mainId].blocks[0].bg;
          const graftTypeEnumIndex = docSet.enumForCategoryValue("graftTypes", args.type, true);
          const seqEnumIndex = docSet.enumForCategoryValue("ids", newSeqId, true);
          utils.succinct.pushSuccinctGraftBytes(mainSequenceBG, graftTypeEnumIndex, seqEnumIndex);
        }
        return newSeqId;
      },
      newBlock: (root, args) => {
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        return document2.newBlock(args.sequenceId, args.blockN, args.blockScope);
      }
    };
    module.exports = {
      addMutationsSchemaString,
      addMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/delete.cjs
var require_delete = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/delete.cjs"(exports, module) {
    init_process();
    init_buffer();
    var deleteMutationsSchemaString = `
  """Deletes a docSet"""
  deleteDocSet(
    """The id of the docSet containing the document to be deleted"""
    docSetId: String!
  ): Boolean
  """Deletes a document"""
  deleteDocument(
    """The id of the docSet containing the document to be deleted"""
    docSetId: String!
    """The id of the document to be deleted"""
    documentId: String!
  ): Boolean
  """Deletes a sequence from a document"""
  deleteSequence(
    """The id of the document containing the sequence to be deleted"""
    documentId: String!
    """The id of the sequence to be deleted"""
    sequenceId: String!
  ): Boolean
  """Deletes a block from a sequence"""
  deleteBlock(
    """The id of the document containing the sequence from which the block will be deleted"""
    documentId: String!
    """The id of the sequence from which the block will be deleted"""
    sequenceId: String!
    """The zero-indexed number of the block to be deleted"""
    blockN: Int!
  ): Boolean
`;
    var deleteMutationsResolvers = {
      deleteDocSet: (root, args) => root.deleteDocSet(args.docSetId),
      deleteDocument: (root, args) => root.deleteDocument(args.docSetId, args.documentId),
      deleteSequence: (root, args) => {
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        return document2.deleteSequence(args.sequenceId);
      },
      deleteBlock: (root, args) => {
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        return document2.deleteBlock(args.sequenceId, args.blockN);
      }
    };
    module.exports = {
      deleteMutationsSchemaString,
      deleteMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/rehash.cjs
var require_rehash2 = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/rehash.cjs"(exports, module) {
    init_process();
    init_buffer();
    var rehashMutationsSchemaString = `
  """Explicitly rebuild the text lookup tables for a docSet. (You probably don't need to do this)"""
  rehashDocSet(
    """The id of the docSet"""
    docSetId: String!
  ): Boolean!
`;
    var rehashMutationsResolvers = {
      rehashDocSet: (root, args) => root.rehashDocSet(args.docSetId)
    };
    module.exports = {
      rehashMutationsSchemaString,
      rehashMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/tags.cjs
var require_tags2 = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/tags.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var tagMutationsSchemaString = `
  """Add one or more tags to a docSet, if they are not already present"""
  addDocSetTags(
    """The id of the docSet to which the tags will be added"""
    docSetId: String!
    """A list of tags to be added"""
    tags: [String]!
  ): [String!]!
  """Add one or more tags to a document, if they are not already present"""
  addDocumentTags(
    """The id of the docSet containing the document to which the tags will be added"""
    docSetId: String!
    """The id of the document to which the tags will be added"""
    documentId: String!
    """A list of tags to be added"""
    tags: [String]!
  ): [String!]
  """Add one or more tags to a sequence, if they are not already present"""
  addSequenceTags(
    """The id of the docSet containing the document containing the sequence to which the tags will be added"""
    docSetId: String!
    """The id of the document containing the sequence to which the tags will be added"""
    documentId: String!
    """The id of the sequence to which the tags will be added"""
    sequenceId: String!
    """A list of tags to be added"""
    tags: [String]!
  ) : [String!]
  """Remove one or more tags from a docSet, if they are present"""
  removeDocSetTags(
    """The id of the docSet from which the tags will be removed"""
    docSetId: String!
    """A list of tags to be removed"""
    tags: [String]!
  ): [String!]
  """Remove one or more tags from a document, if they are present"""
  removeDocumentTags(
    """The id of the docSet containing the document from which the tags will be removed"""
    docSetId: String!
    """The id of the document from which the tags will be removed"""
    documentId: String!
    """A list of tags to be removed"""
    tags: [String]!
  ): [String!]
  """Remove one or more tags from a sequence, if they are present"""
  removeSequenceTags(
    """The id of the docSet containing the document containing the sequence from which the tags will be removed"""
    docSetId: String!
    """The id of the document containing the sequence from which the tags will be removed"""
    documentId: String!
    """The id of the sequence from which the tags will be removed"""
    sequenceId: String!
    """A list of tags to be removed"""
    tags: [String]!
  ) : [String!]
`;
    var tagMutationsResolvers = {
      addDocSetTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        for (const tag of args.tags) {
          docSet.addTag(tag);
        }
        return Array.from(docSet.tags);
      },
      addDocumentTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        const document2 = docSet.processor.documents[args.documentId];
        for (const tag of args.tags) {
          document2.addTag(tag);
        }
        return Array.from(document2.tags);
      },
      addSequenceTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        const document2 = docSet.processor.documents[args.documentId];
        const sequence = document2.sequences[args.sequenceId];
        for (const tag of args.tags) {
          utils.tags.addTag(sequence.tags, tag);
        }
        return Array.from(sequence.tags);
      },
      removeDocSetTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        for (const tag of args.tags) {
          docSet.removeTag(tag);
        }
        return Array.from(docSet.tags);
      },
      removeDocumentTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        const document2 = docSet.processor.documents[args.documentId];
        for (const tag of args.tags) {
          document2.removeTag(tag);
        }
        return Array.from(document2.tags);
      },
      removeSequenceTags: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        const document2 = docSet.processor.documents[args.documentId];
        const sequence = document2.sequences[args.sequenceId];
        for (const tag of args.tags) {
          utils.tags.removeTag(sequence.tags, tag);
        }
        return Array.from(sequence.tags);
      }
    };
    module.exports = {
      tagMutationsSchemaString,
      tagMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/update.cjs
var require_update2 = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/update.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { PipelineHandler } = require_dist();
    var { remakeBlocks } = require_remake_blocks();
    var pipelines = require_perf2x();
    var customTransforms = require_transforms6();
    var updateMutationsSchemaString = `
  """Replaces the items of a block with a new set of items"""
  updateItems(
    """The id of the docSet containing the document containing the sequence containing the block for which the items will be updated"""
    docSetId: String!
    """The id of the document containing the sequence containing the block for which the items will be updated"""
    documentId: String!
    """The id of the sequence containing the block for which the items will be updated (defaults to the main sequence)"""
    sequenceId: String
    """The zero-indexed number of the block for which the items will be updated"""
    blockPosition: Int!
    """The new content for the block as item objects"""
    items: [InputItemObject!]
    """BlockGrafts for the block as item objects"""
    blockGrafts: [InputItemObject!]
    """Optional blockScope for the block as an item object"""
    blockScope: InputItemObject
  ): Boolean!
  """Replaces all the blocks of a sequence with a new set of blocks"""
  updateAllBlocks(
    """The id of the docSet containing the document containing the sequence for which the blocks will be updated"""
    docSetId: String!
    """The id of the document containing the sequence for which the blocks will be updated"""
    documentId: String!
    """The id of the sequence for which the blocks will be updated (defaults to the main sequence)"""
    sequenceId: String
    """The JSON describing blocks"""
    blocksSpec: [inputBlockSpec!]!
  ): Boolean!
  """Replaces all the blocks of a sequence with a new set of blocks derived from PERF"""
  updateSequenceFromPerf(
    """The id of the docSet containing the document containing the sequence for which the blocks will be updated"""
    docSetId: String!
    """The id of the document containing the sequence for which the blocks will be updated"""
    documentId: String!
    """The id of the sequence for which the blocks will be updated (defaults to the main sequence)"""
    sequenceId: String
    """The JSON describing blocks"""
    perf: String!
  ): Boolean!
  """Garbage collects unused sequences within a document. (You probably don\\'t need to do this.)"""
  gcSequences(
    """The id of the docSet containing the document to be garbage collected"""
    docSetId: String!
    """The id of the document to be garbage collected"""
    documentId: String!
  ) : Boolean!
 
`;
    var updateMutationsResolvers = {
      updateItems: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          throw new Error(`DocSet '${args.docSetId}' not found`);
        }
        if (!args.items) {
          throw new Error("Must provide items");
        }
        const itemsResult = docSet.updateItems(
          args.documentId,
          args.sequenceId,
          args.blockPosition,
          args.items
        );
        if (!itemsResult) {
          return false;
        }
        if (args.blockGrafts) {
          const bgResult = docSet.updateBlockGrafts(
            args.documentId,
            args.sequenceId,
            args.blockPosition,
            args.blockGrafts
          );
          if (!bgResult) {
            return false;
          }
        }
        if (args.blockScope) {
          const bsResult = docSet.updateBlockScope(
            args.documentId,
            args.sequenceId,
            args.blockPosition,
            args.blockScope
          );
          if (!bsResult) {
            return false;
          }
        }
        return true;
      },
      updateAllBlocks: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          throw new Error(`DocSet '${args.docSetId}' not found`);
        }
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        const sequence = document2.sequences[args.sequenceId || document2.mainId];
        if (!sequence) {
          throw new Error(`Sequence '${args.sequenceId || document2.mainId}' not found`);
        }
        remakeBlocks(docSet, document2, sequence, args.blocksSpec);
        document2.buildChapterVerseIndex();
        return true;
      },
      updateSequenceFromPerf: async (root, args) => {
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          throw new Error(`DocSet '${args.docSetId}' not found`);
        }
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        const sequence = document2.sequences[args.sequenceId || document2.mainId];
        if (!sequence) {
          throw new Error(`Sequence '${args.sequenceId || document2.mainId}' not found`);
        }
        const sequencePerf = JSON.parse(args.perf);
        const perf = {
          "schema": {
            "structure": "flat",
            "structure_version": "0.3.0",
            "constraints": [
              {
                "name": "perf",
                "version": "0.3.0"
              }
            ]
          },
          "metadata": {
            "translation": {},
            "document": {}
          },
          "sequences": {},
          "main_sequence_id": args.sequenceId
        };
        perf.sequences[args.sequenceId] = sequencePerf;
        let blocksSpec = {};
        try {
          const pipelineHandler = new PipelineHandler({
            pipelines,
            transforms: customTransforms,
            proskomma: root
          });
          const output = await pipelineHandler.runPipeline("perf2PkJsonPipeline", { perf });
          blocksSpec = Object.values(output.pkJson)[0];
        } catch (err) {
          console.error("pipelineHandler Error :\n", err);
          return false;
        }
        remakeBlocks(docSet, document2, sequence, blocksSpec);
        document2.buildChapterVerseIndex();
        return true;
      },
      gcSequences: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          throw new Error(`DocSet '${args.docSetId}' not found`);
        }
        const document2 = root.documents[args.documentId];
        if (!document2) {
          throw new Error(`Document '${args.documentId}' not found`);
        }
        if (document2.gcSequences()) {
          docSet.rehash();
          return true;
        } else {
          return false;
        }
      }
    };
    module.exports = {
      updateMutationsSchemaString,
      updateMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/versification.cjs
var require_versification2 = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/versification.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var versificationMutationsSchemaString = `
  """Adds verse mapping tables to the documents in a docSet, where the verse mapping may be provided in legacy .vrs or JSON format"""
  setVerseMapping(
    """the id of the docSet to which the verse mapping will be added"""
    docSetId: String!
    """The verse mapping, in legacy .vrs format (as a string)"""
    vrsSource: String
    """The verse mapping, in JSON format (as a string)"""
    jsonSource: String
  ): Boolean!
  """Removes verse mapping tables from the documents in a docSet"""
  unsetVerseMapping(
    """The id of the docSet from which verse mapping will be removed"""
    docSetId: String!
  ): Boolean!
`;
    var versificationMutationsResolvers = {
      setVerseMapping: (root, args) => {
        if (args.vrsSource && args.jsonSource) {
          throw new Error("Cannot specify both vrsSource and jsonSource");
        } else if (!args.vrsSource && !args.jsonSource) {
          throw new Error("Must specify either vrsSource or jsonSource");
        }
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          return false;
        }
        let jsonSource;
        if (args.vrsSource) {
          jsonSource = utils.versification.vrs2json(args.vrsSource);
        } else {
          jsonSource = args.jsonSource;
        }
        const forwardSuccinctTree = utils.versification.succinctifyVerseMappings(
          jsonSource.mappedVerses
        );
        const reversedJsonSource = utils.versification.reverseVersification(jsonSource);
        const reversedSuccinctTree = utils.versification.succinctifyVerseMappings(
          reversedJsonSource.reverseMappedVerses
        );
        for (const document2 of docSet.documents().filter((doc) => "bookCode" in doc.headers)) {
          const bookCode = document2.headers["bookCode"];
          const bookDocument = docSet.documentWithBook(bookCode);
          if (!bookDocument) {
            continue;
          }
          const bookMainSequence = bookDocument.sequences[bookDocument.mainId];
          bookMainSequence.verseMapping = {};
          if (bookCode in forwardSuccinctTree) {
            bookMainSequence.verseMapping.forward = forwardSuccinctTree[bookCode];
          }
          if (bookCode in reversedSuccinctTree) {
            bookMainSequence.verseMapping.reversed = reversedSuccinctTree[bookCode];
          }
        }
        docSet.tags.add("hasMapping");
        return true;
      },
      unsetVerseMapping: (root, args) => {
        const docSet = root.docSets[args.docSetId];
        if (!docSet) {
          return false;
        }
        for (const document2 of docSet.documents().filter((doc) => "bookCode" in doc.headers)) {
          const bookCode = document2.headers["bookCode"];
          const bookDocument = docSet.documentWithBook(bookCode);
          if (bookDocument) {
            const bookMainSequence = bookDocument.sequences[bookDocument.mainId];
            bookMainSequence.verseMapping = {};
          }
        }
        docSet.tags.delete("hasMapping");
        return true;
      }
    };
    module.exports = {
      versificationMutationsSchemaString,
      versificationMutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/mutations/index.cjs
var require_mutations = __commonJS({
  "node_modules/proskomma-core/src/graph/mutations/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var {
      addMutationsSchemaString,
      addMutationsResolvers
    } = require_add();
    var {
      deleteMutationsSchemaString,
      deleteMutationsResolvers
    } = require_delete();
    var {
      rehashMutationsSchemaString,
      rehashMutationsResolvers
    } = require_rehash2();
    var {
      tagMutationsSchemaString,
      tagMutationsResolvers
    } = require_tags2();
    var {
      updateMutationsSchemaString,
      updateMutationsResolvers
    } = require_update2();
    var {
      versificationMutationsSchemaString,
      versificationMutationsResolvers
    } = require_versification2();
    var mutationsSchemaString = `
type Mutation {
${addMutationsSchemaString}
${deleteMutationsSchemaString}
${rehashMutationsSchemaString}
${tagMutationsSchemaString}
${updateMutationsSchemaString}
${versificationMutationsSchemaString}
}`;
    var mutationsResolvers = {
      ...addMutationsResolvers,
      ...deleteMutationsResolvers,
      ...rehashMutationsResolvers,
      ...tagMutationsResolvers,
      ...updateMutationsResolvers,
      ...versificationMutationsResolvers
    };
    module.exports = {
      mutationsSchemaString,
      mutationsResolvers
    };
  }
});

// node_modules/proskomma-core/src/graph/queries/versification.cjs
var require_versification3 = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/versification.cjs"(exports, module) {
    init_process();
    init_buffer();
    var versificationSchemaString = `
"""Information about a standard versification scheme"""
type versification {
  """id, derived from the Paratext vrs filename"""
  id: String!
  """A string of the original vrs file"""
  vrs: String!
  """Chapter/verse information for each book"""
  cvBooks: [cvBook!]!
  """Chapter/verse information for one book"""
  cvBook(
    """The bookCode"""
    bookCode: String!
  ): cvBook!
}
`;
    var versificationResolvers = {
      id: (root) => root[0],
      vrs: (root) => root[1].raw,
      cvBooks: (root) => Object.entries(root[1].cv),
      cvBook: (root, args) => Object.entries(root[1].cv).filter((b) => b[0] === args.bookCode)[0]
    };
    module.exports = { versificationSchemaString, versificationResolvers };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvBook.cjs
var require_cvBook = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvBook.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cvBookSchemaString = `
"""Chapter/verse information for a book"""
type cvBook {
  """The bookCode"""
  bookCode: String!
  """The chapter records"""
  chapters: [cvChapter!]!
}
`;
    var cvBookResolvers = {
      bookCode: (root) => root[0],
      chapters: (root) => Object.entries(root[1])
    };
    module.exports = { cvBookSchemaString, cvBookResolvers };
  }
});

// node_modules/proskomma-core/src/graph/queries/cvChapter.cjs
var require_cvChapter = __commonJS({
  "node_modules/proskomma-core/src/graph/queries/cvChapter.cjs"(exports, module) {
    init_process();
    init_buffer();
    var cvChapterSchemaString = `
"""Information for a chapter"""
type cvChapter {
  """The chapter"""
  chapter: Int!
  """The maximum verse number"""
  maxVerse: Int!
}
`;
    var cvChapterResolvers = {
      chapter: (root) => parseInt(root[0]),
      maxVerse: (root) => parseInt(root[1])
    };
    module.exports = { cvChapterSchemaString, cvChapterResolvers };
  }
});

// node_modules/proskomma-core/src/graph/index.cjs
var require_graph = __commonJS({
  "node_modules/proskomma-core/src/graph/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var {
      keyValueSchemaString,
      keyValueResolvers
    } = require_key_value();
    var {
      cvSchemaString,
      cvResolvers
    } = require_cv();
    var {
      idPartsSchemaString,
      idPartsResolvers
    } = require_idParts();
    var { inputAttSpecSchemaString } = require_input_att_spec();
    var { keyMatchesSchemaString } = require_input_key_matches();
    var { inputKeyValueSchemaString } = require_input_key_value();
    var { keyValuesSchemaString } = require_input_key_values();
    var { inputItemObjectSchemaString } = require_inputItemObject();
    var {
      itemSchemaString,
      itemResolvers
    } = require_item2();
    var {
      itemGroupSchemaString,
      itemGroupResolvers
    } = require_itemGroup();
    var {
      kvEntrySchemaString,
      kvEntryResolvers
    } = require_kv_entry();
    var {
      regexIndexSchemaString,
      regexIndexResolvers
    } = require_regex_index();
    var { rowEqualsSpecSchemaString } = require_row_equals_spec();
    var { rowMatchSpecSchemaString } = require_row_match_spec();
    var { verseRangeSchemaString } = require_verseRange();
    var { origSchemaString } = require_orig();
    var {
      verseNumberSchemaString,
      verseNumberResolvers
    } = require_verseNumber();
    var {
      cellSchemaString,
      cellResolvers
    } = require_cell();
    var {
      cIndexSchemaString,
      cIndexResolvers
    } = require_cIndex();
    var {
      cvVerseElementSchemaString,
      cvVerseElementResolvers
    } = require_cvVerseElement();
    var {
      cvVersesSchemaString,
      cvVersesResolvers
    } = require_cvVerses();
    var {
      cvIndexSchemaString,
      cvIndexResolvers
    } = require_cvIndex();
    var {
      cvNavigationSchemaString,
      cvNavigationResolvers
    } = require_cvNavigation();
    var { inputBlockSpecSchemaString } = require_inputBlockSpec();
    var {
      nodeSchemaString,
      nodeResolvers
    } = require_node();
    var {
      kvSequenceSchemaString,
      kvSequenceResolvers
    } = require_kv_sequence();
    var {
      tableSequenceSchemaString,
      tableSequenceResolvers
    } = require_table_sequence();
    var {
      treeSequenceSchemaString,
      treeSequenceResolvers
    } = require_tree_sequence();
    var {
      blockSchemaString,
      blockResolvers
    } = require_block2();
    var {
      sequenceSchemaString,
      sequenceResolvers
    } = require_sequence();
    var {
      documentSchemaString,
      documentResolvers
    } = require_document2();
    var {
      docSetSchemaString,
      docSetResolvers
    } = require_doc_set2();
    var {
      querySchemaString,
      queryResolvers
    } = require_queries();
    var {
      selectorSpecSchemaString,
      selectorSpecResolvers
    } = require_selector_spec();
    var { inputSelectorSpecSchemaString } = require_input_selector_spec();
    var {
      mutationsSchemaString,
      mutationsResolvers
    } = require_mutations();
    var {
      versificationSchemaString,
      versificationResolvers
    } = require_versification3();
    var {
      cvBookSchemaString,
      cvBookResolvers
    } = require_cvBook();
    var {
      cvChapterSchemaString,
      cvChapterResolvers
    } = require_cvChapter();
    var typeDefs = `
      ${querySchemaString}
      ${mutationsSchemaString}
      ${keyValueSchemaString}
      ${cvSchemaString}
      ${idPartsSchemaString}
      ${inputAttSpecSchemaString}
      ${keyMatchesSchemaString}
      ${inputKeyValueSchemaString}
      ${keyValuesSchemaString}
      ${inputItemObjectSchemaString}
      ${itemSchemaString}
      ${itemGroupSchemaString}
      ${kvEntrySchemaString}
      ${regexIndexSchemaString}
      ${rowEqualsSpecSchemaString}
      ${rowMatchSpecSchemaString}
      ${verseRangeSchemaString}
      ${origSchemaString}
      ${verseNumberSchemaString}
      ${cellSchemaString}
      ${cIndexSchemaString}
      ${cvVerseElementSchemaString}
      ${cvVersesSchemaString}
      ${cvIndexSchemaString}
      ${cvNavigationSchemaString}
      ${inputBlockSpecSchemaString}
      ${nodeSchemaString}
      ${kvSequenceSchemaString}
      ${tableSequenceSchemaString}
      ${treeSequenceSchemaString}
      ${blockSchemaString}
      ${sequenceSchemaString}
      ${documentSchemaString}
      ${docSetSchemaString}
      ${selectorSpecSchemaString}
      ${inputSelectorSpecSchemaString}
      ${versificationSchemaString}
      ${cvBookSchemaString}
      ${cvChapterSchemaString}
  `;
    var resolvers = {
      Mutation: mutationsResolvers,
      Query: queryResolvers,
      KeyValue: keyValueResolvers,
      cv: cvResolvers,
      idParts: idPartsResolvers,
      Item: itemResolvers,
      ItemGroup: itemGroupResolvers,
      kvEntry: kvEntryResolvers,
      regexIndex: regexIndexResolvers,
      verseNumber: verseNumberResolvers,
      cell: cellResolvers,
      cIndex: cIndexResolvers,
      cvVerseElement: cvVerseElementResolvers,
      cvVerses: cvVersesResolvers,
      cvIndex: cvIndexResolvers,
      cvNavigation: cvNavigationResolvers,
      node: nodeResolvers,
      kvSequence: kvSequenceResolvers,
      tableSequence: tableSequenceResolvers,
      treeSequence: treeSequenceResolvers,
      Block: blockResolvers,
      Sequence: sequenceResolvers,
      Document: documentResolvers,
      DocSet: docSetResolvers,
      selectorSpec: selectorSpecResolvers,
      versification: versificationResolvers,
      cvBook: cvBookResolvers,
      cvChapter: cvChapterResolvers
    };
    module.exports = {
      typeDefs,
      resolvers
    };
  }
});

// node_modules/proskomma-core/src/util/scriptlike/blocksSpec.cjs
var require_blocksSpec = __commonJS({
  "node_modules/proskomma-core/src/util/scriptlike/blocksSpec.cjs"(exports, module) {
    init_process();
    init_buffer();
    var utils = require_util();
    var { labelForScope } = utils.scopeDefs;
    var { tokenizeString } = require_tokenize();
    var {
      flattenNodes,
      numberNodes
    } = require_nodes();
    var tsvToInputBlock = (tsv, hasHeadings) => {
      const ret = [];
      const rows = tsv.split(/[\n\r]+/);
      for (const [rowN, rowTSV] of rows.entries()) {
        if (hasHeadings && rowN === 0) {
          continue;
        }
        const row = rowTSV.split("	");
        for (const [cellN, cellString] of row.entries()) {
          const cellRecord = {
            os: [],
            bg: [],
            bs: {
              type: "scope",
              subType: "start",
              payload: labelForScope("tTableRow", [`${rowN}`])
            },
            is: [],
            items: []
          };
          const colScope = `tTableCol/${cellN}`;
          cellRecord.is.push({
            type: "scope",
            subType: "start",
            payload: colScope
          });
          cellRecord.items.push({
            type: "scope",
            subType: "start",
            payload: colScope
          });
          for (const [token, tokenType] of tokenizeString(cellString)) {
            cellRecord.items.push({
              type: "token",
              subType: tokenType,
              payload: token
            });
          }
          cellRecord.items.push({
            type: "scope",
            subType: "end",
            payload: colScope
          });
          ret.push(cellRecord);
        }
      }
      return ret;
    };
    var tsvHeadingTags = (tsv) => {
      const firstRow = tsv.split(/[\n\r]+/)[0];
      return firstRow.split("	").map((c, n) => `col${n}:${c.trim()}`);
    };
    var treeToInputBlock = (treeJson) => {
      const ret = [];
      for (const node of flattenNodes(numberNodes(treeJson))) {
        const nodeRecord = {
          os: [],
          bg: [],
          bs: {
            type: "scope",
            subType: "start",
            payload: labelForScope("tTreeNode", [`${node.id}`])
          },
          is: [],
          items: []
        };
        const scopePayload = labelForScope("tTreeParent", [`${node.parentId}`]);
        nodeRecord.items.push({
          type: "scope",
          subType: "start",
          payload: scopePayload
        });
        nodeRecord.is.push({
          type: "scope",
          subType: "start",
          payload: scopePayload
        });
        if (node.content) {
          for (const [name, content] of Object.entries(node.content)) {
            const treeContentStart = nodeRecord.items.length;
            const tokenized = tokenizeString(content);
            const scopePayload2 = labelForScope("tTreeContent", [name, node.id, `${treeContentStart}`, `${tokenized.length}`]);
            nodeRecord.items.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            nodeRecord.is.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            for (const [payload, subType] of tokenized) {
              nodeRecord.items.push({
                type: "token",
                subType,
                payload
              });
            }
            nodeRecord.items.push({
              type: "scope",
              subType: "end",
              payload: scopePayload2
            });
          }
        }
        if (node.children) {
          for (const [childN, childNodeN] of node.children.entries()) {
            const scopePayload2 = labelForScope("tTreeChild", [childN, childNodeN]);
            nodeRecord.items.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            nodeRecord.is.push({
              type: "scope",
              subType: "start",
              payload: scopePayload2
            });
            nodeRecord.items.push({
              type: "scope",
              subType: "end",
              payload: scopePayload2
            });
          }
        }
        nodeRecord.items.push({
          type: "scope",
          subType: "end",
          payload: scopePayload
        });
        ret.push(nodeRecord);
      }
      return ret;
    };
    var escapePayload = (str) => str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    var object2Query = (obs) => "[" + obs.map(
      (ob) => `
    {
      type: "${ob.type}" 
      subType: "${ob.subType}" 
      payload: "${escapePayload(ob.payload)}"
    }`
    ).join(",") + "]";
    var oneObject2Query = (ob) => `{
      type: "${ob.type}" 
      subType: "${ob.subType}" 
      payload: "${escapePayload(ob.payload)}"}`;
    var blocksSpec2Query = (bSpec) => "[\n" + bSpec.map(
      (b) => `  {
    bs: ${oneObject2Query(b.bs)}, 
    bg: ${object2Query(b.bg)}, 
    os: ${object2Query(b.os)}, 
    is: ${object2Query(b.is)}, 
    items: ${object2Query(b.items)}}
`
    ) + "]";
    module.exports = {
      tokenizeString,
      tsvToInputBlock,
      tsvHeadingTags,
      treeToInputBlock,
      blocksSpec2Query,
      object2Query,
      oneObject2Query
    };
  }
});

// node_modules/proskomma-core/src/index.cjs
var require_src = __commonJS({
  "node_modules/proskomma-core/src/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var xre = require_lib();
    var { makeExecutableSchema } = require_cjs3();
    var { Mutex } = require_lib2();
    var checksum = require_checksum();
    var {
      graphql: graphql2,
      graphqlSync: graphqlSync2
    } = (init_graphql2(), __toCommonJS(graphql_exports));
    var BitSet = require_bitset();
    var packageJson = require_package();
    var utils = require_util();
    var { DocSet } = require_doc_set();
    var { Document } = require_document();
    var {
      typeDefs,
      resolvers
    } = require_graph();
    var { lexingRegexes: lexingRegexes2 } = require_lexingRegexes();
    var blocksSpecUtils2 = require_blocksSpec();
    var {
      flattenNodes,
      numberNodes
    } = require_nodes();
    var tree2nodes = (tree) => flattenNodes(numberNodes(tree));
    var executableSchema = makeExecutableSchema({
      typeDefs,
      resolvers
    });
    var Proskomma2 = class {
      constructor(selectors) {
        this.processorId = utils.generateId();
        this.documents = {};
        this.docSetsBySelector = {};
        this.docSets = {};
        this.filters = {};
        this.customTags = {
          heading: [],
          paragraph: [],
          char: [],
          word: [],
          intro: [],
          introHeading: []
        };
        this.emptyBlocks = [];
        this.selectors = selectors || [
          {
            name: "lang",
            type: "string",
            regex: "[a-z]{3}"
          },
          {
            name: "abbr",
            type: "string"
          }
        ];
        this.validateSelectorSpec(this.selectors);
        this.mutex = new Mutex();
        this.nextPeriph = 0;
        this.nextTable = 0;
        this.nextNodes = 0;
      }
      validateSelectors() {
        if (this.selectors.length === 0) {
          throw new Error("No selectors found");
        }
        for (const [n, selector] of this.selectors.entries()) {
          if (!("name" in selector)) {
            throw new Error(`Selector ${n} has no name`);
          }
          if (!("type" in selector)) {
            throw new Error(`Selector ${n} has no type`);
          }
          if (!["string", "integer"].includes(selector.type)) {
            throw new Error(`Type for selector ${n} must be string or number, not ${selector.type}`);
          }
          if (selector.type === "string") {
            if ("min" in selector) {
              throw new Error("String selector should not include 'min'");
            }
            if ("max" in selector) {
              throw new Error("String selector should not include 'max'");
            }
            if ("regex" in selector) {
              try {
                xre(selector.regex);
              } catch (err) {
                throw new Error(`Regex '${selector.regex}' is not valid: ${err}`);
              }
            }
            if ("enum" in selector) {
              for (const enumElement of selector.enum) {
                if (typeof enumElement !== "string") {
                  throw new Error(`Enum values for selector ${selector.name} should be strings, not '${enumElement}'`);
                }
              }
            }
          } else {
            if ("regex" in selector) {
              throw new Error("Integer selector should not include 'regex'");
            }
            if ("min" in selector && typeof selector.min !== "number") {
              throw new Error(`'min' must be a number, not '${selector.min}'`);
            }
            if ("max" in selector && typeof selector.max !== "number") {
              throw new Error(`'max' must be a number, not '${selector.max}'`);
            }
            if ("min" in selector && "max" in selector && selector.min > selector.max) {
              throw new Error(`'min' cannot be greater than 'max' (${selector.min} > ${selector.max})`);
            }
            if ("enum" in selector) {
              for (const enumElement of selector.enum) {
                if (typeof enumElement !== "number") {
                  throw new Error(`Enum values for selector ${selector.name} should be numbers, not '${enumElement}'`);
                }
              }
            }
          }
          for (const selectorKey of Object.keys(selector)) {
            if (!["name", "type", "regex", "min", "max", "enum"].includes(selectorKey)) {
              throw new Error(`Unexpected key '${selectorKey}' in selector ${n}`);
            }
          }
        }
      }
      validateSelectorSpec(spec) {
        for (const specElement of spec) {
          if (!specElement["name"]) {
            throw new Error(`name not found in selector spec element '${JSON.stringify(specElement)}'`);
          }
          if (!specElement["type"]) {
            throw new Error(`type not found in selector spec element '${JSON.stringify(specElement)}'`);
          }
          if (!["string", "integer"].includes(specElement.type)) {
            throw new Error(`Type for spec element must be string or number, not ${specElement.type}`);
          }
          for (const selectorKey of Object.keys(specElement)) {
            if (!["name", "type", "regex", "min", "max", "enum"].includes(selectorKey)) {
              throw new Error(`Unexpected key '${selectorKey}' in selectorSpec`);
            }
          }
        }
      }
      selectorString(docSetSelectors) {
        return this.selectors.map((s) => s.name).map((n) => `${docSetSelectors[n]}`).join("_");
      }
      processor() {
        return "Proskomma JS";
      }
      packageVersion() {
        return packageJson.version;
      }
      docSetList() {
        return Object.values(this.docSets);
      }
      docSetsById(ids) {
        return Object.values(this.docSets).filter((ds) => ids.includes(ds.id));
      }
      docSetById(id) {
        return this.docSets[id];
      }
      docSetsWithBook(bookCode) {
        const docIdsWithBook = Object.values(this.documents).filter((doc) => "bookCode" in doc.headers && doc.headers["bookCode"] === bookCode).map((doc) => doc.id);
        const docIdWithBookInDocSet = (ds) => {
          for (const docId of docIdsWithBook) {
            if (ds.docIds.includes(docId)) {
              return true;
            }
          }
          return false;
        };
        return Object.values(this.docSets).filter((ds) => docIdWithBookInDocSet(ds));
      }
      nDocSets() {
        return this.docSetList().length;
      }
      nDocuments() {
        return this.documentList().length;
      }
      documentList() {
        return Object.values(this.documents);
      }
      documentById(id) {
        return this.documents[id];
      }
      documentsById(ids) {
        return Object.values(this.documents).filter((doc) => ids.includes(doc.id));
      }
      documentsWithBook(bookCode) {
        return Object.values(this.documents).filter((doc) => "bookCode" in doc.headers && doc.headers["bookCode"] === bookCode);
      }
      importDocument(selectors, contentType, contentString, filterOptions, customTags, emptyBlocks, tags) {
        return this.importDocuments(selectors, contentType, [contentString], filterOptions, customTags, emptyBlocks, tags)[0];
      }
      importDocuments(selectors, contentType, contentStrings, filterOptions, customTags, emptyBlocks, tags) {
        if (!filterOptions) {
          filterOptions = this.filters;
        }
        if (!customTags) {
          customTags = this.customTags;
        }
        if (!emptyBlocks) {
          emptyBlocks = this.emptyBlocks;
        }
        if (!tags) {
          tags = [];
        }
        const docSetId = this.findOrMakeDocSet(selectors);
        const docSet = this.docSets[docSetId];
        docSet.buildPreEnums();
        const docs = [];
        for (const contentString of contentStrings) {
          let doc = new Document(this, docSetId, contentType, contentString, filterOptions, customTags, emptyBlocks, tags);
          const bookCode = doc.headers.bookCode;
          const existingBookCodes = Object.values(this.documents).filter((d) => docSet.docIds.includes(d.id)).map((d) => d.headers.bookCode);
          if (existingBookCodes.includes(bookCode)) {
            throw new Error(`Attempt to import document with bookCode '${bookCode}' which already exists in docSet ${docSetId}`);
          }
          this.addDocument(doc, docSetId);
          docs.push(doc);
        }
        docSet.preEnums = {};
        return docs;
      }
      importUsfmPeriph(selectors, contentString, filterOptions, customTags, emptyBlocks, tags) {
        const lines = contentString.toString().split(/[\n\r]+/);
        const bookCode = lines[0].substring(4, 7);
        if (!["FRT", "BAK", "INT"].includes(bookCode)) {
          throw new Error(`importUsfmInt() expected bookCode of FRT, BAK or INT, not '${bookCode}'`);
        }
        let periphs = [];
        for (const line of lines) {
          if (line.substring(0, 7) === "\\periph") {
            let matchedBits = xre.exec(line, xre('^\\\\periph (.*)\\|\\s*id\\s*=\\s*"([^"]+)"\\s*$'));
            if (!matchedBits) {
              throw new Error(`Unable to parse periph line '${line}'`);
            }
            const periphDesc = matchedBits[1];
            const periphId = matchedBits[2];
            const periphBookCode = `\\id P${this.nextPeriph > 9 ? this.nextPeriph : "0" + this.nextPeriph}`;
            periphs.push([`${periphBookCode} INT ${periphId} - ${periphDesc}`]);
            this.nextPeriph++;
          } else if (periphs.length > 0 && line.substring(0, 3) !== "\\id") {
            periphs[periphs.length - 1].push(line);
          }
        }
        this.importDocuments(
          selectors,
          "usfm",
          periphs.map((p) => p.join("\n")),
          filterOptions,
          customTags,
          emptyBlocks,
          tags
        );
      }
      cleanUsfm(usfm, options) {
        options = options || {};
        const lines = usfm.toString().split(/[\n\r]+/);
        const ret = [];
        let inHeaders = true;
        const headers = ["\\id", "\\ide", "\\usfm", "\\sts", "\\rem", "\\h", "\\toc"];
        for (const line of lines) {
          const firstWord = line.split(" ")[0].replace(/[0-9]+/g, "");
          if ("remove" in options && options.remove.includes(firstWord)) {
            continue;
          }
          const isHeaderLine = headers.includes(firstWord);
          if (inHeaders && !isHeaderLine && firstWord !== "\\mt") {
            ret.push("\\mt1 USFM");
          }
          ret.push(line);
          if (!isHeaderLine) {
            inHeaders = false;
          }
        }
        return ret.join("\n");
      }
      deleteDocSet(docSetId) {
        if (!(docSetId in this.docSets)) {
          return false;
        }
        for (const docId of Object.entries(this.documents).filter((tup) => tup[1].docSetId === docSetId).map((tup) => tup[0])) {
          this.deleteDocument(docSetId, docId, false, false);
        }
        let selected = this.docSetsBySelector;
        const parentSelectors = this.selectors.slice(0, this.selectors.length - 1);
        for (const selector of parentSelectors) {
          selected = selected[this.docSets[docSetId].selectors[selector.name]];
        }
        const lastSelectorName = this.selectors[this.selectors.length - 1].name;
        const lastSelectorValue = this.docSets[docSetId].selectors[lastSelectorName];
        if (!selected[lastSelectorValue]) {
          throw new Error(`Could not find docSetId '${docSetId}' in docSetsBySelector in deleteDocSet`);
        }
        delete selected[lastSelectorValue];
        delete this.docSets[docSetId];
        return true;
      }
      deleteDocument(docSetId, documentId, maybeDeleteDocSet, maybeRehashDocSet) {
        maybeDeleteDocSet = maybeDeleteDocSet === void 0 ? true : maybeDeleteDocSet;
        maybeRehashDocSet = maybeRehashDocSet === void 0 ? true : maybeRehashDocSet;
        if (!(docSetId in this.docSets)) {
          return false;
        }
        if (!(documentId in this.documents)) {
          return false;
        }
        delete this.documents[documentId];
        if (this.docSets[docSetId].docIds.length > 1) {
          this.docSets[docSetId].docIds = this.docSets[docSetId].docIds.filter((i) => i !== documentId);
          if (maybeRehashDocSet) {
            this.rehashDocSet(docSetId);
          }
        } else if (maybeDeleteDocSet) {
          this.deleteDocSet(docSetId);
        }
        return true;
      }
      rehashDocSet(docSetId) {
        if (!(docSetId in this.docSets)) {
          return false;
        }
        const docSet = this.docSets[docSetId];
        return docSet.rehash();
      }
      addDocument(doc, docSetId) {
        this.documents[doc.id] = doc;
        this.docSets[docSetId].docIds.push(doc.id);
        this.docSets[docSetId].buildEnumIndexes();
      }
      loadSuccinctDocSet(succinctOb) {
        const succinctId = succinctOb.id;
        if (succinctId in this.docSets) {
          throw new Error(`Attempting to succinct load docSet ${succinctId} which is already loaded`);
        }
        const docSet = new DocSet(this, null, null, succinctOb);
        const docSetId = docSet.id;
        this.docSets[docSetId] = docSet;
        let selectorTree = this.docSetsBySelector;
        const selectors = succinctOb.metadata.selectors;
        for (const selector of this.selectors) {
          if (selector.name === this.selectors[this.selectors.length - 1].name) {
            if (!(selectors[selector.name] in selectorTree)) {
              selectorTree[selectors[selector.name]] = docSet;
              this.docSets[docSet.id] = docSet;
            }
          } else {
            if (!(selectors[selector.name] in selectorTree)) {
              selectorTree[selectors[selector.name]] = {};
            }
            selectorTree = selectorTree[selectors[selector.name]];
          }
        }
        docSet.buildPreEnums();
        const docs = [];
        for (const docId of Object.keys(succinctOb.docs)) {
          let doc = this.newDocumentFromSuccinct(docId, succinctOb);
          docs.push(doc);
        }
        docSet.preEnums = {};
        return docs;
      }
      newDocumentFromSuccinct(docId, succinctOb) {
        const doc = new Document(this, succinctOb.id);
        doc.id = docId;
        const succinctDocOb = succinctOb.docs[docId];
        doc.filterOptions = {};
        doc.customTags = [];
        doc.emptyBlocks = [];
        doc.tags = new Set(succinctDocOb.tags);
        doc.headers = succinctDocOb.headers;
        doc.mainId = succinctDocOb.mainId;
        doc.sequences = {};
        for (const [seqId, seq] of Object.entries(succinctDocOb.sequences)) {
          doc.sequences[seqId] = {
            id: seqId,
            type: seq.type,
            tags: new Set(seq.tags),
            blocks: []
          };
          if (seq.type === "main") {
            doc.sequences[seqId].chapters = {};
            if (!("chapters" in seq)) {
              throw new Error("chapters not found in main sequence");
            }
            for (const [chK, chV] of Object.entries(seq.chapters)) {
              const bA = new utils.ByteArray();
              bA.fromBase64(chV);
              doc.sequences[seqId].chapters[chK] = bA;
            }
            doc.sequences[seqId].chapterVerses = {};
            if (!("chapterVerses" in seq)) {
              throw new Error("chapterVerses not found in main sequence");
            }
            for (const [chvK, chvV] of Object.entries(seq.chapterVerses)) {
              const bA = new utils.ByteArray();
              bA.fromBase64(chvV);
              doc.sequences[seqId].chapterVerses[chvK] = bA;
            }
            if (!("tokensPresent" in seq)) {
              throw new Error("tokensPresent not found in main sequence");
            }
            doc.sequences[seqId].tokensPresent = new BitSet(seq.tokensPresent);
          }
          for (const succinctBlock of seq.blocks) {
            const block2 = {};
            for (const [blockField, blockSuccinct] of Object.entries(succinctBlock)) {
              const ba = new utils.ByteArray(256);
              ba.fromBase64(blockSuccinct);
              block2[blockField] = ba;
            }
            doc.sequences[seqId].blocks.push(block2);
          }
        }
        this.addDocument(doc, succinctOb.id);
        return doc;
      }
      findOrMakeDocSet(selectors) {
        let selectorTree = this.docSetsBySelector;
        let docSet;
        for (const selector of this.selectors) {
          if (selector.name === this.selectors[this.selectors.length - 1].name) {
            if (selectors[selector.name] in selectorTree) {
              docSet = selectorTree[selectors[selector.name]];
            } else {
              docSet = new DocSet(this, selectors);
              selectorTree[selectors[selector.name]] = docSet;
              this.docSets[docSet.id] = docSet;
            }
          } else {
            if (!(selectors[selector.name] in selectorTree)) {
              selectorTree[selectors[selector.name]] = {};
            }
            selectorTree = selectorTree[selectors[selector.name]];
          }
        }
        return docSet.id;
      }
      async gqlQuery(query, callback) {
        const release2 = await this.mutex.acquire();
        try {
          const result = await graphql2({
            schema: executableSchema,
            source: query,
            rootValue: this,
            contextValue: {}
          });
          if (callback) {
            callback(result);
          }
          return result;
        } finally {
          release2();
        }
      }
      gqlQuerySync(query, callback) {
        const result = graphqlSync2({
          schema: executableSchema,
          source: query,
          rootValue: this,
          contextValue: {}
        });
        if (callback) {
          callback(result);
        }
        return result;
      }
      serializeSuccinct(docSetId) {
        return this.docSets[docSetId].serializeSuccinct();
      }
      checksum() {
        const dsChecksums = Object.values(this.docSets).map((ds) => ds.checksum()).sort().join(" ");
        return checksum(dsChecksums);
      }
    };
    module.exports = {
      Proskomma: Proskomma2,
      typeDefs,
      resolvers,
      lexingRegexes: lexingRegexes2,
      blocksSpecUtils: blocksSpecUtils2,
      tree2nodes,
      utils
    };
  }
});

// node_modules/proskomma-core/index.cjs
var require_proskomma_core = __commonJS({
  "node_modules/proskomma-core/index.cjs"(exports, module) {
    init_process();
    init_buffer();
    var { Proskomma: Proskomma2, lexingRegexes: lexingRegexes2 } = require_src();
    var blocksSpecUtils2 = require_blocksSpec();
    module.exports = {
      Proskomma: Proskomma2,
      lexingRegexes: lexingRegexes2,
      blocksSpecUtils: blocksSpecUtils2
    };
  }
});

// node_modules/proskomma-core/esm/wrapper.mjs
init_process();
init_buffer();
var import__ = __toESM(require_proskomma_core(), 1);
var Proskomma = import__.default.Proskomma;
var lexingRegexes = import__.default.lexingRegexes;
var blocksSpecUtils = import__.default.blocksSpecUtils;
export {
  Proskomma,
  blocksSpecUtils,
  lexingRegexes
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*! Bundled license information:

xregexp/lib/xregexp.js:
  (*!
   * XRegExp 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2007-present MIT License
   *)

xregexp/lib/addons/build.js:
  (*!
   * XRegExp.build 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2012-present MIT License
   *)

xregexp/lib/addons/matchrecursive.js:
  (*!
   * XRegExp.matchRecursive 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2009-present MIT License
   *)

xregexp/lib/addons/unicode-base.js:
  (*!
   * XRegExp Unicode Base 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2008-present MIT License
   *)

xregexp/lib/addons/unicode-categories.js:
  (*!
   * XRegExp Unicode Categories 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2010-present MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

xregexp/lib/addons/unicode-properties.js:
  (*!
   * XRegExp Unicode Properties 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2012-present MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

xregexp/lib/addons/unicode-scripts.js:
  (*!
   * XRegExp Unicode Scripts 5.1.1
   * <xregexp.com>
   * Steven Levithan (c) 2010-present MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   *)

checksum/checksum.js:
  (*!
   * checksum
   * Copyright(c) 2013 Daniel D. Shaw <dshaw@dshaw.com>
   * MIT Licensed
   *)

bitset/bitset.js:
  (**
   * @license BitSet.js v5.1.1 2/1/2020
   * http://www.xarg.org/2014/03/javascript-bit-array/
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

pure-uuid/uuid.js:
  (*!
  **  Pure-UUID -- Pure JavaScript Based Universally Unique Identifier (UUID)
  **  Copyright (c) 2004-2021 Dr. Ralf S. Engelschall <rse@engelschall.com>
  **
  **  Permission is hereby granted, free of charge, to any person obtaining
  **  a copy of this software and associated documentation files (the
  **  "Software"), to deal in the Software without restriction, including
  **  without limitation the rights to use, copy, modify, merge, publish,
  **  distribute, sublicense, and/or sell copies of the Software, and to
  **  permit persons to whom the Software is furnished to do so, subject to
  **  the following conditions:
  **
  **  The above copyright notice and this permission notice shall be included
  **  in all copies or substantial portions of the Software.
  **
  **  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  **  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  **  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  **  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  **  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  **  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  **  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
//# sourceMappingURL=proskomma-core.js.map
