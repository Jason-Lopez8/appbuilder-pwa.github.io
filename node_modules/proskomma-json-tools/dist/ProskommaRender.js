"use strict";

var ProskommaRenderAction = require('./ProskommaRenderAction');
class ProskommaRender {
  constructor(spec) {
    if (this.constructor === ProskommaRender) {
      throw new Error("Abstract class ProskommaRender cannot be instantiated - make as subclass!");
    }
    var actions = spec.actions || {};
    this.debugLevel = spec.debugLevel || 0;
    this.actions = {};
    for (var event of ["startDocument", "endDocument", "startSequence", "endSequence", "unresolvedBlockGraft", "blockGraft", "startParagraph", "endParagraph", "metaContent", "mark", "unresolvedInlineGraft", "inlineGraft", "startWrapper", "endWrapper", "startMilestone", "endMilestone", "text"]) {
      if (actions[event]) {
        this.actions[event] = actions[event].map(a => new ProskommaRenderAction(a));
      } else {
        this.actions[event] = [];
      }
    }
  }
  addRenderActionObject(event, actionOb) {
    if (!this.actions[event]) {
      throw new Error("Unknown event '".concat(event));
    }
    this.actions[event].push(actionOb);
  }
  addRenderAction(event, actionSpec) {
    this.addRenderActionObject(event, new ProskommaRenderAction(actionSpec));
  }
  describeRenderActions(event) {
    if (!this.actions[event]) {
      throw new Error("Unknown event '".concat(event));
    }
    var ret = ["**Actions for ".concat(event, "**\n")];
    for (var actionOb of this.actions[event]) {
      ret.push("IF ".concat(actionOb.test.toString(), ":"));
      ret.push("    DO ".concat(actionOb.description));
    }
    return ret.join('\n');
  }
  renderDocument(_ref) {
    var {
      docId,
      config,
      output
    } = _ref;
    var context = {};
    var workspace = {};
    this.renderDocument1({
      docId,
      config,
      context,
      workspace,
      output
    });
    return output;
  }
  renderDocument1(_ref2) {
    var {
      docId,
      config,
      context,
      workspace,
      output
    } = _ref2;
    throw new Error("Define renderDocument1() in subclass");
  }

  // renderEnvironment => {config, context, workspace, output}
  renderEvent(event, renderEnvironment) {
    var context = renderEnvironment.context;
    if (this.debugLevel > 1) {
      console.log("".concat("    ".repeat(context.sequences.length), "EVENT ").concat(event));
    }
    if (!this.actions[event]) {
      throw new Error("Unknown event '".concat(event));
    }
    var found = false;
    for (var actionOb of this.actions[event]) {
      var testResult = false;
      try {
        testResult = actionOb.test(renderEnvironment);
      } catch (err) {
        var msg = "Exception from test of action '".concat(actionOb.description, "' for event ").concat(event, " in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: ").concat(err);
        throw new Error(msg);
      }
      if (testResult) {
        found = true;
        if (this.debugLevel > 0) {
          console.log("".concat("    ".repeat(context.sequences.length), "    ").concat(event, " action: ").concat(actionOb.description));
        }
        var actionResult = false;
        try {
          actionResult = actionOb.action(renderEnvironment);
        } catch (err) {
          throw new Error("Exception from action '".concat(actionOb.description, "' for event ").concat(event, " in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: ").concat(err));
        }
        if (!actionResult) {
          break;
        }
      }
    }
    if (['unresolvedBlockGraft', 'unresolvedInlineGraft'].includes(event) && this.actions[event].length === 0) {
      throw new Error("No action for ".concat(event, " graft event in ").concat(context.sequences.length > 0 ? context.sequences[0].type : "no", " sequence: add an action or fix your data!"));
    }
    if (!found && this.debugLevel > 1) {
      console.log("".concat("    ".repeat(context.sequences.length), "    No matching action"));
    }
  }
}
module.exports = ProskommaRender;