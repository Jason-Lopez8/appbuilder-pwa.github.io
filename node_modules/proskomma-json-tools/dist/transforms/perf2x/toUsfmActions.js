"use strict";

var _usfmHelps = _interopRequireDefault(require("../../usfmHelps"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var initNestedLevel = (workspace, level) => {
  workspace.nestInx = level;
  workspace.usfmBits[level] = [];
};
var wsPushStrAtLevel = function wsPushStrAtLevel(workspace, str) {
  var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  str && workspace.usfmBits[level].push(str);
};
var wsPushStr = (workspace, str) => wsPushStrAtLevel(workspace, str, workspace.nestInx);
var upNestingLevel = (workspace, saveEl) => {
  workspace.savedEl.push(saveEl);
  initNestedLevel(workspace, workspace.nestInx + 1);
};
var wsCheckAndPushTag = (workspace, tag, str) => {
  var checkTags = ['ts', 'c', ..._usfmHelps.default.bodyTags];
  // Strategy - delay output and wait until able to keep the strict order
  // unless tag is outside of valid list
  // then output all delayed items and current one (while keeping the order)
  if (checkTags.includes(tag)) {
    if (_usfmHelps.default.bodyTags.includes(tag)) {
      workspace.strictTagOrderStore.usfmBits.push(str);
    } else {
      workspace.strictTagOrderStore[tag] = str;
    }
  } else {
    wsPushStr(workspace, workspace.strictTagOrderStore.ts);
    wsPushStr(workspace, workspace.strictTagOrderStore.c);
    wsPushStr(workspace, workspace.strictTagOrderStore.usfmBits.join());
    wsPushStr(workspace, str);
    workspace.strictTagOrderStore = {
      usfmBits: []
    };
  }
};
var popNestedElement = workspace => workspace.savedEl.pop();
var popNestedUsfmBits = workspace => {
  // To do: probably first output all content in "strictTagOrder"
  var retArr = workspace.usfmBits[workspace.nestInx];
  workspace.usfmBits[workspace.nestInx] = [];
  return retArr;
};
var downNestingLevel = workspace => {
  var tempArr = popNestedUsfmBits(workspace);
  if (workspace.nestInx > 0) {
    workspace.nestInx--;
  }
  workspace.usfmBits[workspace.nestInx].push(...tempArr);
};
var oneifyTag = t => {
  if (['toc', 'toca', 'mt'].includes(t)) {
    return t + '1';
  }
  return t;
};
var toUsfmActions = {
  startDocument: [{
    description: "Set up environment",
    test: () => true,
    action: _ref => {
      var {
        context,
        workspace
      } = _ref;
      workspace.usfmBits = [];
      workspace.savedEl = [];
      workspace.strictTagOrderStore = {
        usfmBits: []
      };
      initNestedLevel(workspace, 0);
      for (var [key, value] of Object.entries(context.document.metadata.document).filter(kv => !['tags', 'properties', 'bookCode'].includes(kv[0]))) {
        wsCheckAndPushTag(workspace, key, "\\".concat(oneifyTag(key), " ").concat(value, "\n"));
      }
      ;
    }
  }],
  blockGraft: [{
    description: "Follow block grafts",
    test: _ref2 => {
      var {
        context
      } = _ref2;
      return ['title', 'heading', 'introduction'].includes(context.sequences[0].block.subType);
    },
    action: environment => {
      var target = environment.context.sequences[0].block.target;
      if (target) {
        environment.context.renderer.renderSequenceId(environment, target);
      }
    }
  }],
  inlineGraft: [{
    description: "Follow inline grafts",
    test: () => false,
    action: environment => {
      var target = environment.context.sequences[0].element.target;
      if (target) {
        environment.context.renderer.renderSequenceId(environment, target);
      }
    }
  }],
  startParagraph: [{
    description: "Output paragraph tag",
    test: () => true,
    action: _ref3 => {
      var {
        context,
        workspace
      } = _ref3;
      var tag = context.sequences[0].block.subType.split(':')[1];
      wsCheckAndPushTag(workspace, tag, "\n\\".concat(oneifyTag(tag), "\n"));
    }
  }],
  endParagraph: [{
    description: "Output nl",
    test: () => true,
    action: _ref4 => {
      var {
        workspace
      } = _ref4;
      wsPushStr(workspace, "\n");
    }
  }],
  text: [{
    description: "Output text",
    test: () => true,
    action: _ref5 => {
      var {
        context,
        workspace
      } = _ref5;
      var text = context.sequences[0].element.text;
      wsPushStr(workspace, text);
    }
  }],
  mark: [{
    description: "Output chapter or verses",
    test: () => true,
    action: _ref6 => {
      var {
        context,
        workspace
      } = _ref6;
      var element = context.sequences[0].element;
      if (element.subType === 'chapter') {
        wsCheckAndPushTag(workspace, 'c', "\n\\c ".concat(element.atts['number'], "\n"));
      } else if (element.subType === 'verses') {
        wsCheckAndPushTag(workspace, 'v', "\\v ".concat(element.atts['number'], "\n"));
      }
    }
  }],
  endDocument: [{
    description: "Build output",
    test: () => true,
    action: _ref7 => {
      var {
        workspace,
        output
      } = _ref7;
      var reorderedChapters = workspace.usfmBits[0];
      output.usfm = reorderedChapters.join('');
    }
  }],
  startMilestone: [{
    description: "Output start of milestone",
    test: () => true,
    action: _ref8 => {
      var {
        context,
        workspace
      } = _ref8;
      var element = context.sequences[0].element;
      if (element && element.atts) {
        if (Object.keys(element.atts).length > 0) {
          wsPushStr(workspace, "\\zaln-s |");
          var separatorCh = "";
          Object.keys(element.atts).forEach(key => {
            wsPushStr(workspace, "".concat(separatorCh).concat(key, "=\"").concat(element.atts[key], "\""));
            separatorCh = " ";
          });
          wsPushStr(workspace, "\\*");
        } else if (element.subType === "usfm:ts") {
          wsCheckAndPushTag(workspace, 'ts', "\n\n\\ts\\* ");
        }
      }
    }
  }],
  endMilestone: [{
    description: "Output end of milestone",
    test: () => true,
    action: _ref9 => {
      var {
        workspace
      } = _ref9;
      wsPushStr(workspace, "\\zaln-e\\*");
    }
  }],
  startWrapper: [{
    description: "Handle start of wrapper",
    test: () => true,
    action: _ref10 => {
      var {
        context,
        workspace
      } = _ref10;
      upNestingLevel(workspace, context.sequences[0].element);
    }
  }],
  endWrapper: [{
    description: "Output start and end of wrapper, incl. wrapped text",
    test: () => true,
    action: _ref11 => {
      var {
        context,
        workspace
      } = _ref11;
      var savedStartEl = popNestedElement(workspace);
      var nestedUsfmBits = popNestedUsfmBits(workspace);
      downNestingLevel(workspace);
      if (savedStartEl && savedStartEl.atts && Object.keys(savedStartEl.atts).length > 0) {
        wsPushStr(workspace, "\\w ".concat(nestedUsfmBits.join(''), "|"));
        var separatorCh = "";
        Object.keys(savedStartEl.atts).forEach(key => {
          wsPushStr(workspace, "".concat(separatorCh).concat(key, "=\"").concat(savedStartEl.atts[key], "\""));
          separatorCh = " ";
        });
      }
      wsPushStr(workspace, "\\w*");
    }
  }]
};
module.exports = toUsfmActions;